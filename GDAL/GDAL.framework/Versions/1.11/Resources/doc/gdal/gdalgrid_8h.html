<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>GDAL: gdalgrid.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>gdalgrid.h File Reference</h1>  </div>
</div>
<div class="contents">

<p>GDAL gridder related entry points and definitions.  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="gdal__alg_8h_source.html">gdal_alg.h</a>&quot;</code><br/>

<p><a href="gdalgrid_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa09eeb8e24b43cfde54e6a2c4f90edd8"></a><!-- doxytag: member="gdalgrid.h::GDALGridFunction" ref="aa09eeb8e24b43cfde54e6a2c4f90edd8" args=")(const void *, GUInt32, const double *, const double *, const double *, double, double, double *, void *)" -->
typedef CPLErr(*&nbsp;</td><td class="memItemRight" valign="bottom"><b>GDALGridFunction</b> )(const void *, GUInt32, const double *, const double *, const double *, double, double, double *, void *)</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPLErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdalgrid_8h.html#ac8f080bcefc5f13e73d572be68a69fc1">GDALGridInverseDistanceToAPower</a> (const void *, GUInt32, const double *, const double *, const double *, double, double, double *, void *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inverse distance to a power.  <a href="#ac8f080bcefc5f13e73d572be68a69fc1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPLErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdalgrid_8h.html#a9f738c9330ad36df7acbf8de5b3f7105">GDALGridInverseDistanceToAPowerNoSearch</a> (const void *, GUInt32, const double *, const double *, const double *, double, double, double *, void *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inverse distance to a power for whole data set.  <a href="#a9f738c9330ad36df7acbf8de5b3f7105"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPLErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdalgrid_8h.html#a697dc64e23f0228146ddebf48743bb02">GDALGridMovingAverage</a> (const void *, GUInt32, const double *, const double *, const double *, double, double, double *, void *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moving average.  <a href="#a697dc64e23f0228146ddebf48743bb02"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPLErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdalgrid_8h.html#ac497ce19f63f4d22e18685077fedf6ed">GDALGridNearestNeighbor</a> (const void *, GUInt32, const double *, const double *, const double *, double, double, double *, void *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Nearest neighbor.  <a href="#ac497ce19f63f4d22e18685077fedf6ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPLErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdalgrid_8h.html#a301b7e824fadf9697fc9da4b204263f3">GDALGridDataMetricMinimum</a> (const void *, GUInt32, const double *, const double *, const double *, double, double, double *, void *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Minimum data value (data metric).  <a href="#a301b7e824fadf9697fc9da4b204263f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPLErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdalgrid_8h.html#a131d5a851413c39708b285a6c3e0bf1d">GDALGridDataMetricMaximum</a> (const void *, GUInt32, const double *, const double *, const double *, double, double, double *, void *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum data value (data metric).  <a href="#a131d5a851413c39708b285a6c3e0bf1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPLErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdalgrid_8h.html#ae9c980b4fe3f58df17df0d9d6035f667">GDALGridDataMetricRange</a> (const void *, GUInt32, const double *, const double *, const double *, double, double, double *, void *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data range (data metric).  <a href="#ae9c980b4fe3f58df17df0d9d6035f667"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPLErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdalgrid_8h.html#aa2804df02327d19f5923d79dd593813e">GDALGridDataMetricCount</a> (const void *, GUInt32, const double *, const double *, const double *, double, double, double *, void *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of data points (data metric).  <a href="#aa2804df02327d19f5923d79dd593813e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPLErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdalgrid_8h.html#ae3e729ec25e035ed32c307195c005d9f">GDALGridDataMetricAverageDistance</a> (const void *, GUInt32, const double *, const double *, const double *, double, double, double *, void *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Average distance (data metric).  <a href="#ae3e729ec25e035ed32c307195c005d9f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPLErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdalgrid_8h.html#aaaee3f9584ebda977a6df1130c959784">GDALGridDataMetricAverageDistancePts</a> (const void *, GUInt32, const double *, const double *, const double *, double, double, double *, void *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Average distance between points (data metric).  <a href="#aaaee3f9584ebda977a6df1130c959784"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a7de1627876aa46c3b66759930e8fe4"></a><!-- doxytag: member="gdalgrid.h::ParseAlgorithmAndOptions" ref="a3a7de1627876aa46c3b66759930e8fe4" args="(const char *, GDALGridAlgorithm *, void **)" -->
CPLErr&nbsp;</td><td class="memItemRight" valign="bottom"><b>ParseAlgorithmAndOptions</b> (const char *, <a class="el" href="gdal__alg_8h.html#a590d1a2d0bac1d34b95034c1f616de21">GDALGridAlgorithm</a> *, void **)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>GDAL gridder related entry points and definitions. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ae3e729ec25e035ed32c307195c005d9f"></a><!-- doxytag: member="gdalgrid.h::GDALGridDataMetricAverageDistance" ref="ae3e729ec25e035ed32c307195c005d9f" args="(const void *, GUInt32, const double *, const double *, const double *, double, double, double *, void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPLErr GDALGridDataMetricAverageDistance </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>poOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GUInt32&nbsp;</td>
          <td class="paramname"> <em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>padfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>padfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>padfZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfXPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfYPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pdfValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>hExtraParamsIn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Average distance (data metric). </p>
<p>An average distance between the grid node (center of the search ellipse) and all of the data points found in grid node search ellipse. If there are no points found, the specified NODATA value will be returned.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ Z=\frac{\sum_{i = 1}^n r_i}{n} \]" src="form_14.png"/>
</p>
<p>where </p>
<ul>
<li>
<img class="formulaInl" alt="$Z$" src="form_0.png"/> is a resulting value at the grid node, </li>
<li>
<img class="formulaInl" alt="$r_i$" src="form_4.png"/> is an Euclidean distance from the grid node to point <img class="formulaInl" alt="$i$" src="form_3.png"/>, </li>
<li>
<img class="formulaInl" alt="$n$" src="form_6.png"/> is a total number of points in search ellipse. </li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poOptions</em>&nbsp;</td><td>Algorithm parameters. This should point to <a class="el" href="structGDALGridDataMetricsOptions.html" title="Data metrics method control options.">GDALGridDataMetricsOptions</a> object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nPoints</em>&nbsp;</td><td>Number of elements in input arrays. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfX</em>&nbsp;</td><td>Input array of X coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfY</em>&nbsp;</td><td>Input array of Y coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfZ</em>&nbsp;</td><td>Input array of Z values. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfXPoint</em>&nbsp;</td><td>X coordinate of the point to compute. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfYPoint</em>&nbsp;</td><td>Y coordinate of the point to compute. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pdfValue</em>&nbsp;</td><td>Pointer to variable where the computed grid node value will be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CE_None on success or CE_Failure if something goes wrong. </dd></dl>

</div>
</div>
<a class="anchor" id="aaaee3f9584ebda977a6df1130c959784"></a><!-- doxytag: member="gdalgrid.h::GDALGridDataMetricAverageDistancePts" ref="aaaee3f9584ebda977a6df1130c959784" args="(const void *, GUInt32, const double *, const double *, const double *, double, double, double *, void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPLErr GDALGridDataMetricAverageDistancePts </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>poOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GUInt32&nbsp;</td>
          <td class="paramname"> <em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>padfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>padfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>padfZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfXPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfYPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pdfValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>hExtraParamsIn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Average distance between points (data metric). </p>
<p>An average distance between the data points found in grid node search ellipse. The distance between each pair of points within ellipse is calculated and average of all distances is set as a grid node value. If there are no points found, the specified NODATA value will be returned.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ Z=\frac{\sum_{i = 1}^{n-1}\sum_{j=i+1}^{n} r_{ij}}{\left(n-1\right)\,n-\frac{n+{\left(n-1\right)}^{2}-1}{2}} \]" src="form_15.png"/>
</p>
<p>where </p>
<ul>
<li>
<img class="formulaInl" alt="$Z$" src="form_0.png"/> is a resulting value at the grid node, </li>
<li>
<img class="formulaInl" alt="$r_{ij}$" src="form_16.png"/> is an Euclidean distance between points <img class="formulaInl" alt="$i$" src="form_3.png"/> and <img class="formulaInl" alt="$j$" src="form_17.png"/>, </li>
<li>
<img class="formulaInl" alt="$n$" src="form_6.png"/> is a total number of points in search ellipse. </li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poOptions</em>&nbsp;</td><td>Algorithm parameters. This should point to <a class="el" href="structGDALGridDataMetricsOptions.html" title="Data metrics method control options.">GDALGridDataMetricsOptions</a> object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nPoints</em>&nbsp;</td><td>Number of elements in input arrays. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfX</em>&nbsp;</td><td>Input array of X coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfY</em>&nbsp;</td><td>Input array of Y coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfZ</em>&nbsp;</td><td>Input array of Z values. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfXPoint</em>&nbsp;</td><td>X coordinate of the point to compute. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfYPoint</em>&nbsp;</td><td>Y coordinate of the point to compute. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pdfValue</em>&nbsp;</td><td>Pointer to variable where the computed grid node value will be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CE_None on success or CE_Failure if something goes wrong. </dd></dl>

</div>
</div>
<a class="anchor" id="aa2804df02327d19f5923d79dd593813e"></a><!-- doxytag: member="gdalgrid.h::GDALGridDataMetricCount" ref="aa2804df02327d19f5923d79dd593813e" args="(const void *, GUInt32, const double *, const double *, const double *, double, double, double *, void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPLErr GDALGridDataMetricCount </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>poOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GUInt32&nbsp;</td>
          <td class="paramname"> <em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>padfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>padfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>padfZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfXPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfYPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pdfValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>hExtraParamsIn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Number of data points (data metric). </p>
<p>A number of data points found in grid node search ellipse.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ Z=n \]" src="form_13.png"/>
</p>
<p>where </p>
<ul>
<li>
<img class="formulaInl" alt="$Z$" src="form_0.png"/> is a resulting value at the grid node, </li>
<li>
<img class="formulaInl" alt="$n$" src="form_6.png"/> is a total number of points in search ellipse. </li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poOptions</em>&nbsp;</td><td>Algorithm parameters. This should point to <a class="el" href="structGDALGridDataMetricsOptions.html" title="Data metrics method control options.">GDALGridDataMetricsOptions</a> object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nPoints</em>&nbsp;</td><td>Number of elements in input arrays. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfX</em>&nbsp;</td><td>Input array of X coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfY</em>&nbsp;</td><td>Input array of Y coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfZ</em>&nbsp;</td><td>Input array of Z values. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfXPoint</em>&nbsp;</td><td>X coordinate of the point to compute. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfYPoint</em>&nbsp;</td><td>Y coordinate of the point to compute. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pdfValue</em>&nbsp;</td><td>Pointer to variable where the computed grid node value will be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CE_None on success or CE_Failure if something goes wrong. </dd></dl>

</div>
</div>
<a class="anchor" id="a131d5a851413c39708b285a6c3e0bf1d"></a><!-- doxytag: member="gdalgrid.h::GDALGridDataMetricMaximum" ref="a131d5a851413c39708b285a6c3e0bf1d" args="(const void *, GUInt32, const double *, const double *, const double *, double, double, double *, void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPLErr GDALGridDataMetricMaximum </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>poOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GUInt32&nbsp;</td>
          <td class="paramname"> <em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>padfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>padfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>padfZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfXPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfYPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pdfValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>hExtraParamsIn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Maximum data value (data metric). </p>
<p>Maximum value found in grid node search ellipse. If there are no points found, the specified NODATA value will be returned.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ Z=\max{(Z_1,Z_2,\ldots,Z_n)} \]" src="form_11.png"/>
</p>
<p>where </p>
<ul>
<li>
<img class="formulaInl" alt="$Z$" src="form_0.png"/> is a resulting value at the grid node, </li>
<li>
<img class="formulaInl" alt="$Z_i$" src="form_2.png"/> is a known value at point <img class="formulaInl" alt="$i$" src="form_3.png"/>, </li>
<li>
<img class="formulaInl" alt="$n$" src="form_6.png"/> is a total number of points in search ellipse. </li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poOptions</em>&nbsp;</td><td>Algorithm parameters. This should point to <a class="el" href="structGDALGridDataMetricsOptions.html" title="Data metrics method control options.">GDALGridDataMetricsOptions</a> object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nPoints</em>&nbsp;</td><td>Number of elements in input arrays. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfX</em>&nbsp;</td><td>Input array of X coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfY</em>&nbsp;</td><td>Input array of Y coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfZ</em>&nbsp;</td><td>Input array of Z values. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfXPoint</em>&nbsp;</td><td>X coordinate of the point to compute. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfYPoint</em>&nbsp;</td><td>Y coordinate of the point to compute. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pdfValue</em>&nbsp;</td><td>Pointer to variable where the computed grid node value will be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CE_None on success or CE_Failure if something goes wrong. </dd></dl>

</div>
</div>
<a class="anchor" id="a301b7e824fadf9697fc9da4b204263f3"></a><!-- doxytag: member="gdalgrid.h::GDALGridDataMetricMinimum" ref="a301b7e824fadf9697fc9da4b204263f3" args="(const void *, GUInt32, const double *, const double *, const double *, double, double, double *, void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPLErr GDALGridDataMetricMinimum </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>poOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GUInt32&nbsp;</td>
          <td class="paramname"> <em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>padfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>padfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>padfZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfXPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfYPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pdfValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>hExtraParamsIn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Minimum data value (data metric). </p>
<p>Minimum value found in grid node search ellipse. If there are no points found, the specified NODATA value will be returned.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ Z=\min{(Z_1,Z_2,\ldots,Z_n)} \]" src="form_10.png"/>
</p>
<p>where </p>
<ul>
<li>
<img class="formulaInl" alt="$Z$" src="form_0.png"/> is a resulting value at the grid node, </li>
<li>
<img class="formulaInl" alt="$Z_i$" src="form_2.png"/> is a known value at point <img class="formulaInl" alt="$i$" src="form_3.png"/>, </li>
<li>
<img class="formulaInl" alt="$n$" src="form_6.png"/> is a total number of points in search ellipse. </li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poOptions</em>&nbsp;</td><td>Algorithm parameters. This should point to <a class="el" href="structGDALGridDataMetricsOptions.html" title="Data metrics method control options.">GDALGridDataMetricsOptions</a> object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nPoints</em>&nbsp;</td><td>Number of elements in input arrays. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfX</em>&nbsp;</td><td>Input array of X coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfY</em>&nbsp;</td><td>Input array of Y coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfZ</em>&nbsp;</td><td>Input array of Z values. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfXPoint</em>&nbsp;</td><td>X coordinate of the point to compute. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfYPoint</em>&nbsp;</td><td>Y coordinate of the point to compute. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pdfValue</em>&nbsp;</td><td>Pointer to variable where the computed grid node value will be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CE_None on success or CE_Failure if something goes wrong. </dd></dl>

</div>
</div>
<a class="anchor" id="ae9c980b4fe3f58df17df0d9d6035f667"></a><!-- doxytag: member="gdalgrid.h::GDALGridDataMetricRange" ref="ae9c980b4fe3f58df17df0d9d6035f667" args="(const void *, GUInt32, const double *, const double *, const double *, double, double, double *, void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPLErr GDALGridDataMetricRange </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>poOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GUInt32&nbsp;</td>
          <td class="paramname"> <em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>padfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>padfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>padfZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfXPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfYPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pdfValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>hExtraParamsIn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Data range (data metric). </p>
<p>A difference between the minimum and maximum values found in grid node search ellipse. If there are no points found, the specified NODATA value will be returned.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ Z=\max{(Z_1,Z_2,\ldots,Z_n)}-\min{(Z_1,Z_2,\ldots,Z_n)} \]" src="form_12.png"/>
</p>
<p>where </p>
<ul>
<li>
<img class="formulaInl" alt="$Z$" src="form_0.png"/> is a resulting value at the grid node, </li>
<li>
<img class="formulaInl" alt="$Z_i$" src="form_2.png"/> is a known value at point <img class="formulaInl" alt="$i$" src="form_3.png"/>, </li>
<li>
<img class="formulaInl" alt="$n$" src="form_6.png"/> is a total number of points in search ellipse. </li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poOptions</em>&nbsp;</td><td>Algorithm parameters. This should point to <a class="el" href="structGDALGridDataMetricsOptions.html" title="Data metrics method control options.">GDALGridDataMetricsOptions</a> object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nPoints</em>&nbsp;</td><td>Number of elements in input arrays. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfX</em>&nbsp;</td><td>Input array of X coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfY</em>&nbsp;</td><td>Input array of Y coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfZ</em>&nbsp;</td><td>Input array of Z values. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfXPoint</em>&nbsp;</td><td>X coordinate of the point to compute. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfYPoint</em>&nbsp;</td><td>Y coordinate of the point to compute. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pdfValue</em>&nbsp;</td><td>Pointer to variable where the computed grid node value will be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CE_None on success or CE_Failure if something goes wrong. </dd></dl>

</div>
</div>
<a class="anchor" id="ac8f080bcefc5f13e73d572be68a69fc1"></a><!-- doxytag: member="gdalgrid.h::GDALGridInverseDistanceToAPower" ref="ac8f080bcefc5f13e73d572be68a69fc1" args="(const void *, GUInt32, const double *, const double *, const double *, double, double, double *, void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPLErr GDALGridInverseDistanceToAPower </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>poOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GUInt32&nbsp;</td>
          <td class="paramname"> <em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>padfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>padfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>padfZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfXPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfYPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pdfValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>hExtraParamsIn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inverse distance to a power. </p>
<p>The Inverse Distance to a Power gridding method is a weighted average interpolator. You should supply the input arrays with the scattered data values including coordinates of every data point and output grid geometry. The function will compute interpolated value for the given position in output grid.</p>
<p>For every grid node the resulting value <img class="formulaInl" alt="$Z$" src="form_0.png"/> will be calculated using formula:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ Z=\frac{\sum_{i=1}^n{\frac{Z_i}{r_i^p}}}{\sum_{i=1}^n{\frac{1}{r_i^p}}} \]" src="form_1.png"/>
</p>
<p>where </p>
<ul>
<li>
<img class="formulaInl" alt="$Z_i$" src="form_2.png"/> is a known value at point <img class="formulaInl" alt="$i$" src="form_3.png"/>, </li>
<li>
<img class="formulaInl" alt="$r_i$" src="form_4.png"/> is an Euclidean distance from the grid node to point <img class="formulaInl" alt="$i$" src="form_3.png"/>, </li>
<li>
<img class="formulaInl" alt="$p$" src="form_5.png"/> is a weighting power, </li>
<li>
<img class="formulaInl" alt="$n$" src="form_6.png"/> is a total number of points in search ellipse. </li>
</ul>
<p>In this method the weighting factor <img class="formulaInl" alt="$w$" src="form_7.png"/> is</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ w=\frac{1}{r^p} \]" src="form_8.png"/>
</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poOptions</em>&nbsp;</td><td>Algorithm parameters. This should point to <a class="el" href="structGDALGridInverseDistanceToAPowerOptions.html" title="Inverse distance to a power method control options.">GDALGridInverseDistanceToAPowerOptions</a> object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nPoints</em>&nbsp;</td><td>Number of elements in input arrays. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfX</em>&nbsp;</td><td>Input array of X coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfY</em>&nbsp;</td><td>Input array of Y coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfZ</em>&nbsp;</td><td>Input array of Z values. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfXPoint</em>&nbsp;</td><td>X coordinate of the point to compute. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfYPoint</em>&nbsp;</td><td>Y coordinate of the point to compute. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pdfValue</em>&nbsp;</td><td>Pointer to variable where the computed grid node value will be returned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hExtraParamsIn</em>&nbsp;</td><td>extra parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CE_None on success or CE_Failure if something goes wrong. </dd></dl>

</div>
</div>
<a class="anchor" id="a9f738c9330ad36df7acbf8de5b3f7105"></a><!-- doxytag: member="gdalgrid.h::GDALGridInverseDistanceToAPowerNoSearch" ref="a9f738c9330ad36df7acbf8de5b3f7105" args="(const void *, GUInt32, const double *, const double *, const double *, double, double, double *, void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPLErr GDALGridInverseDistanceToAPowerNoSearch </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>poOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GUInt32&nbsp;</td>
          <td class="paramname"> <em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>padfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>padfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>padfZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfXPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfYPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pdfValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>hExtraParamsIn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inverse distance to a power for whole data set. </p>
<p>This is somewhat optimized version of the Inverse Distance to a Power method. It is used when the search ellips is not set. The algorithm and parameters are the same as in <a class="el" href="gdalgrid_8h.html#ac8f080bcefc5f13e73d572be68a69fc1" title="Inverse distance to a power.">GDALGridInverseDistanceToAPower()</a>, but this implementation works faster, because of no search.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="gdalgrid_8h.html#ac8f080bcefc5f13e73d572be68a69fc1" title="Inverse distance to a power.">GDALGridInverseDistanceToAPower()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a697dc64e23f0228146ddebf48743bb02"></a><!-- doxytag: member="gdalgrid.h::GDALGridMovingAverage" ref="a697dc64e23f0228146ddebf48743bb02" args="(const void *, GUInt32, const double *, const double *, const double *, double, double, double *, void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPLErr GDALGridMovingAverage </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>poOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GUInt32&nbsp;</td>
          <td class="paramname"> <em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>padfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>padfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>padfZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfXPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfYPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pdfValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>hExtraParamsIn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moving average. </p>
<p>The Moving Average is a simple data averaging algorithm. It uses a moving window of elliptic form to search values and averages all data points within the window. Search ellipse can be rotated by specified angle, the center of ellipse located at the grid node. Also the minimum number of data points to average can be set, if there are not enough points in window, the grid node considered empty and will be filled with specified NODATA value.</p>
<p>Mathematically it can be expressed with the formula:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ Z=\frac{\sum_{i=1}^n{Z_i}}{n} \]" src="form_9.png"/>
</p>
<p>where </p>
<ul>
<li>
<img class="formulaInl" alt="$Z$" src="form_0.png"/> is a resulting value at the grid node, </li>
<li>
<img class="formulaInl" alt="$Z_i$" src="form_2.png"/> is a known value at point <img class="formulaInl" alt="$i$" src="form_3.png"/>, </li>
<li>
<img class="formulaInl" alt="$n$" src="form_6.png"/> is a total number of points in search ellipse. </li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poOptions</em>&nbsp;</td><td>Algorithm parameters. This should point to <a class="el" href="structGDALGridMovingAverageOptions.html" title="Moving average method control options.">GDALGridMovingAverageOptions</a> object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nPoints</em>&nbsp;</td><td>Number of elements in input arrays. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfX</em>&nbsp;</td><td>Input array of X coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfY</em>&nbsp;</td><td>Input array of Y coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfZ</em>&nbsp;</td><td>Input array of Z values. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfXPoint</em>&nbsp;</td><td>X coordinate of the point to compute. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfYPoint</em>&nbsp;</td><td>Y coordinate of the point to compute. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pdfValue</em>&nbsp;</td><td>Pointer to variable where the computed grid node value will be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CE_None on success or CE_Failure if something goes wrong. </dd></dl>

</div>
</div>
<a class="anchor" id="ac497ce19f63f4d22e18685077fedf6ed"></a><!-- doxytag: member="gdalgrid.h::GDALGridNearestNeighbor" ref="ac497ce19f63f4d22e18685077fedf6ed" args="(const void *, GUInt32, const double *, const double *, const double *, double, double, double *, void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPLErr GDALGridNearestNeighbor </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>poOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GUInt32&nbsp;</td>
          <td class="paramname"> <em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>padfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>padfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>padfZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfXPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfYPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pdfValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>hExtraParamsIn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Nearest neighbor. </p>
<p>The Nearest Neighbor method doesn't perform any interpolation or smoothing, it just takes the value of nearest point found in grid node search ellipse and returns it as a result. If there are no points found, the specified NODATA value will be returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poOptions</em>&nbsp;</td><td>Algorithm parameters. This should point to <a class="el" href="structGDALGridNearestNeighborOptions.html" title="Nearest neighbor method control options.">GDALGridNearestNeighborOptions</a> object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nPoints</em>&nbsp;</td><td>Number of elements in input arrays. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfX</em>&nbsp;</td><td>Input array of X coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfY</em>&nbsp;</td><td>Input array of Y coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfZ</em>&nbsp;</td><td>Input array of Z values. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfXPoint</em>&nbsp;</td><td>X coordinate of the point to compute. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfYPoint</em>&nbsp;</td><td>Y coordinate of the point to compute. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pdfValue</em>&nbsp;</td><td>Pointer to variable where the computed grid node value will be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CE_None on success or CE_Failure if something goes wrong. </dd></dl>

</div>
</div>
</div>
<hr>

Generated for GDAL by 
<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.7.1.
</body>
</html>

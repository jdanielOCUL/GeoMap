<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>GDAL: GDALSimpleSURF Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>GDALSimpleSURF Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="GDALSimpleSURF" -->
<p>Class for searching corresponding points on images.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="gdal__simplesurf_8h_source.html">gdal_simplesurf.h</a>&gt;</code></p>

<p><a href="classGDALSimpleSURF-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>MatchedPointPairInfo</b></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class stores indexes of pair of point and distance between them. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALSimpleSURF.html#ac76389892468bc582a0fac18ec132f0f">GDALSimpleSURF</a> (int nOctaveStart, int nOctaveEnd)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepare class according to specified parameters.  <a href="#ac76389892468bc582a0fac18ec132f0f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classGDALFeaturePoint.html">GDALFeaturePoint</a> &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALSimpleSURF.html#a613db6521d7cdd679db1da8c5c53cfaf">ExtractFeaturePoints</a> (<a class="el" href="classGDALIntegralImage.html">GDALIntegralImage</a> *poImg, double dfThreshold)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find feature points using specified integral image.  <a href="#a613db6521d7cdd679db1da8c5c53cfaf"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static CPLErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALSimpleSURF.html#ad9c2f58697140b1971057877342ceea1">ConvertRGBToLuminosity</a> (<a class="el" href="classGDALRasterBand.html">GDALRasterBand</a> *red, <a class="el" href="classGDALRasterBand.html">GDALRasterBand</a> *green, <a class="el" href="classGDALRasterBand.html">GDALRasterBand</a> *blue, int nXSize, int nYSize, double **padfImg, int nHeight, int nWidth)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert image with RGB channels to grayscale using "luminosity" method.  <a href="#ad9c2f58697140b1971057877342ceea1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static CPLErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALSimpleSURF.html#ad37e8c216e791efb073f675e0621a71b">MatchFeaturePoints</a> (std::vector&lt; <a class="el" href="classGDALFeaturePoint.html">GDALFeaturePoint</a> * &gt; *poMatchPairs, std::vector&lt; <a class="el" href="classGDALFeaturePoint.html">GDALFeaturePoint</a> &gt; *poFirstCollect, std::vector&lt; <a class="el" href="classGDALFeaturePoint.html">GDALFeaturePoint</a> &gt; *poSecondCollect, double dfThreshold)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find corresponding points (equal points in two collections).  <a href="#ad37e8c216e791efb073f675e0621a71b"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Class for searching corresponding points on images. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Andrew Migal <a href="mailto:migal.drew@gmail.com">migal.drew@gmail.com</a></dd></dl>
<p>Provides capability for detection feature points and finding equal points on different images. Class implements simplified version of SURF algorithm (Speeded Up Robust Features). As original, this realization is scale invariant, but sensitive to rotation. Images should have similar rotation angles (maximum difference is up to 10-15 degrees), otherwise algorithm produces incorrect and very unstable results. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac76389892468bc582a0fac18ec132f0f"></a><!-- doxytag: member="GDALSimpleSURF::GDALSimpleSURF" ref="ac76389892468bc582a0fac18ec132f0f" args="(int nOctaveStart, int nOctaveEnd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GDALSimpleSURF::GDALSimpleSURF </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nOctaveStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nOctaveEnd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepare class according to specified parameters. </p>
<p>Octave numbers affects to amount of detected points and their robustness. Range between bottom and top octaves also affects to required time of detection points (if range is large, algorithm should perform more operations). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nOctaveStart</em>&nbsp;</td><td>Number of bottom octave. Octave numbers starts with one </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nOctaveEnd</em>&nbsp;</td><td>Number of top octave. Should be equal or greater than OctaveStart</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Every octave finds points with specific size. For small images use small octave numbers, for high resolution - large. For 1024x1024 images it's normal to use any octave numbers from range 1-6. (for example, octave start - 1, octave end - 3, or octave start - 2, octave end - 2.) For larger images, try 1-10 range or even higher. Pay attention that number of detected point decreases quickly per octave for particular image. Algorithm finds more points in case of small octave numbers. If method detects nothing, reduce bottom bound of octave range.</dd></dl>
<p>NOTICE that every octave requires time to compute. Use a little range or only one octave if execution time is significant. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ad9c2f58697140b1971057877342ceea1"></a><!-- doxytag: member="GDALSimpleSURF::ConvertRGBToLuminosity" ref="ad9c2f58697140b1971057877342ceea1" args="(GDALRasterBand *red, GDALRasterBand *green, GDALRasterBand *blue, int nXSize, int nYSize, double **padfImg, int nHeight, int nWidth)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPLErr GDALSimpleSURF::ConvertRGBToLuminosity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGDALRasterBand.html">GDALRasterBand</a> *&nbsp;</td>
          <td class="paramname"> <em>red</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGDALRasterBand.html">GDALRasterBand</a> *&nbsp;</td>
          <td class="paramname"> <em>green</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGDALRasterBand.html">GDALRasterBand</a> *&nbsp;</td>
          <td class="paramname"> <em>blue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nXSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nYSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>padfImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nWidth</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert image with RGB channels to grayscale using "luminosity" method. </p>
<p>Result is used in SURF-based algorithm, but may be used anywhere where grayscale images with nice contrast are required.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>red</em>&nbsp;</td><td>Image's red channel </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>green</em>&nbsp;</td><td>Image's green channel </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blue</em>&nbsp;</td><td>Image's blue channel </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nXSize</em>&nbsp;</td><td>Width of initial image </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nYSize</em>&nbsp;</td><td>Height of initial image </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfImg</em>&nbsp;</td><td>Array for resulting grayscale image </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nHeight</em>&nbsp;</td><td>Height of resulting image </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nWidth</em>&nbsp;</td><td>Width of resulting image</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CE_None or CE_Failure if error occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="a613db6521d7cdd679db1da8c5c53cfaf"></a><!-- doxytag: member="GDALSimpleSURF::ExtractFeaturePoints" ref="a613db6521d7cdd679db1da8c5c53cfaf" args="(GDALIntegralImage *poImg, double dfThreshold)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classGDALFeaturePoint.html">GDALFeaturePoint</a> &gt; * GDALSimpleSURF::ExtractFeaturePoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGDALIntegralImage.html">GDALIntegralImage</a> *&nbsp;</td>
          <td class="paramname"> <em>poImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfThreshold</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find feature points using specified integral image. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poImg</em>&nbsp;</td><td>Integral image to be used </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfThreshold</em>&nbsp;</td><td>Threshold for feature point recognition. Detected feature point will have Hessian value greater than this provided threshold.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Typical threshold's value is 0,001. But this value can be various in each case and depends on image's nature. For example, value can be 0.002 or 0.005. Fill free to experiment with it. If threshold is high, than number of detected feature points is small, and vice versa. </dd></dl>

</div>
</div>
<a class="anchor" id="ad37e8c216e791efb073f675e0621a71b"></a><!-- doxytag: member="GDALSimpleSURF::MatchFeaturePoints" ref="ad37e8c216e791efb073f675e0621a71b" args="(std::vector&lt; GDALFeaturePoint * &gt; *poMatchPairs, std::vector&lt; GDALFeaturePoint &gt; *poFirstCollect, std::vector&lt; GDALFeaturePoint &gt; *poSecondCollect, double dfThreshold)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPLErr GDALSimpleSURF::MatchFeaturePoints </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classGDALFeaturePoint.html">GDALFeaturePoint</a> * &gt; *&nbsp;</td>
          <td class="paramname"> <em>poMatchPairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classGDALFeaturePoint.html">GDALFeaturePoint</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>poFirstCollect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classGDALFeaturePoint.html">GDALFeaturePoint</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>poSecondCollect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfThreshold</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find corresponding points (equal points in two collections). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poMatchPairs</em>&nbsp;</td><td>Resulting collection for matched points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>poSecondCollect</em>&nbsp;</td><td>Points on the first image </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>poSecondCollect</em>&nbsp;</td><td>Points on the second image </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfThreshold</em>&nbsp;</td><td>Value from 0 to 1. Threshold affects to number of matched points. If threshold is lower, amount of corresponding points is larger, and vice versa</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CE_None or CE_Failure if error occurs.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poMatched</em>&nbsp;</td><td>Resulting collection for matched points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>poFirstCollection</em>&nbsp;</td><td>Points on the first image </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>poSecondCollection</em>&nbsp;</td><td>Points on the second image </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfThreshold</em>&nbsp;</td><td>Value from 0 to 1. Threshold affects to number of matched points. If threshold is higher, amount of corresponding points is larger, and vice versa</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Typical threshold's value is 0,1. BUT it's a very approximate guide. It can be 0,001 or even 1. This threshold provides direct adjustment of point matching. NOTICE that if threshold is lower, matches are more robust and correct, but number of matched points is smaller. Therefore if algorithm performs many false detections and produces bad results, reduce threshold. Otherwise, if algorithm finds nothing, increase threshold.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CE_None or CE_Failure if error occurs. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="gdal__simplesurf_8h_source.html">gdal_simplesurf.h</a></li>
<li>gdal_simplesurf.cpp</li>
</ul>
</div>
<hr>

Generated for GDAL by 
<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.7.1.
</body>
</html>

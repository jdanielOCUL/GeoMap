<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>GDAL: GDAL Driver Implementation Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>GDAL Driver Implementation Tutorial </h1>  </div>
</div>
<div class="contents">
<h2><a class="anchor" id="gdal_drivertut_overall"></a>
Overall Approach</h2>
<p>In general new formats are added to GDAL by implementing format specific drivers as subclasses of <a class="el" href="classGDALDataset.html" title="A set of associated raster bands, usually from one file.">GDALDataset</a>, and band accessors as subclasses of <a class="el" href="classGDALRasterBand.html" title="A single raster band (or channel).">GDALRasterBand</a>. As well, a <a class="el" href="classGDALDriver.html" title="Format specific driver.">GDALDriver</a> instance is created for the format, and registered with the <a class="el" href="classGDALDriverManager.html" title="Class for managing the registration of file format drivers.">GDALDriverManager</a>, to ensure that the system <em>knows</em> about the format.</p>
<p>This tutorial will start with implementing a simple read-only driver (based on the JDEM driver), and then proceed to utilizing the RawRasterBand helper class, implementing creatable and updatable formats, and some esoteric issues.</p>
<p>It is strongly advised that the <a href="gdal_datamodel.html">GDAL Data Model </a> description be reviewed and understood before attempting to implement a GDAL driver.</p>
<h2><a class="anchor" id="gdal_drivertut_toc"></a>
Contents</h2>
<ol>
<li>
<a class="el" href="gdal_drivertut.html#gdal_drivertut_dataset">Implementing the Dataset</a> </li>
<li>
<a class="el" href="gdal_drivertut.html#gdal_drivertut_rasterband">Implementing the RasterBand</a> </li>
<li>
<a class="el" href="gdal_drivertut.html#gdal_drivertut_driver">The Driver</a> </li>
<li>
<a class="el" href="gdal_drivertut.html#gdal_drivertut_addingdriver">Adding Driver to GDAL Tree</a> </li>
<li>
<a class="el" href="gdal_drivertut.html#gdal_drivertut_georef">Adding Georeferencing</a> </li>
<li>
<a class="el" href="gdal_drivertut.html#gdal_drivertut_overviews">Overviews</a> </li>
<li>
<a class="el" href="gdal_drivertut.html#gdal_drivertut_creation">File Creation</a> </li>
<li>
<a class="el" href="gdal_drivertut.html#gdal_drivertut_raw">RawDataset/RawRasterBand Helper Classes</a> </li>
<li>
<a class="el" href="gdal_drivertut.html#gdal_drivertut_metadata">Metadata, and Other Exotic Extensions</a> </li>
</ol>
<h2><a class="anchor" id="gdal_drivertut_dataset"></a>
Implementing the Dataset</h2>
<p>We will start showing minimal implementation of a read-only driver for the Japanese DEM format (<a href="jdemdataset.cpp.html">jdemdataset.cpp</a>). First we declare a format specific dataset class, JDEMDataset in this case.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>JDEMDataset : <span class="keyword">public</span> <a class="code" href="classGDALPamDataset.html" title="A subclass of GDALDataset which introduces the ability to save and restore auxilary information (coor...">GDALPamDataset</a>
{
    <span class="keyword">friend</span> <span class="keyword">class </span>JDEMRasterBand;

    FILE        *fp;
    GByte       abyHeader[1012];

  <span class="keyword">public</span>:
                ~JDEMDataset();
    
    <span class="keyword">static</span> <a class="code" href="classGDALDataset.html" title="A set of associated raster bands, usually from one file.">GDALDataset</a> *Open( <a class="code" href="classGDALOpenInfo.html">GDALOpenInfo</a> * );

    CPLErr      GetGeoTransform( <span class="keywordtype">double</span> * padfTransform );
    <span class="keyword">const</span> <span class="keywordtype">char</span> *GetProjectionRef();
};
</pre></div><p>In general we provide capabilities for a driver, by overriding the various virtual methods on the <a class="el" href="classGDALDataset.html" title="A set of associated raster bands, usually from one file.">GDALDataset</a> base class. However, the Open() method is special. This is not a virtual method on the base class, and we will need a freestanding function for this operation, so we declare it static. Implementing it as a method in the JDEMDataset class is convenient because we have privileged access to modify the contents of the database object.</p>
<p>The open method itself may look something like this:</p>
<div class="fragment"><pre class="fragment">
GDALDataset *JDEMDataset::Open( GDALOpenInfo * poOpenInfo )

{
// -------------------------------------------------------------------- //
//      Confirm that the header has what appears to be dates in the     //
//      expected locations.  Sadly this is a relatively weak test.      //
// -------------------------------------------------------------------- //
    if( poOpenInfo-&gt;nHeaderBytes &lt; 50 )
        return NULL;

    // check if century values seem reasonable //
    if( (!EQUALN((char *)poOpenInfo-&gt;pabyHeader+11,"19",2)
          &amp;&amp; !EQUALN((char *)poOpenInfo-&gt;pabyHeader+11,"20",2))
        || (!EQUALN((char *)poOpenInfo-&gt;pabyHeader+15,"19",2)
             &amp;&amp; !EQUALN((char *)poOpenInfo-&gt;pabyHeader+15,"20",2))
        || (!EQUALN((char *)poOpenInfo-&gt;pabyHeader+19,"19",2)
             &amp;&amp; !EQUALN((char *)poOpenInfo-&gt;pabyHeader+19,"20",2)) )
    {
        return NULL;
    }
    
// -------------------------------------------------------------------- //
//      Confirm the requested access is supported.                      //
// -------------------------------------------------------------------- //
    if( poOpenInfo-&gt;eAccess == GA_Update )
    {
        CPLError( CE_Failure, CPLE_NotSupported, 
                  "The JDEM driver does not support update access to existing"
                  " datasets.\n" );
        return NULL;
    }

// -------------------------------------------------------------------- //
//      Create a corresponding GDALDataset.                             //
// -------------------------------------------------------------------- //
    JDEMDataset 	*poDS;

    poDS = new JDEMDataset();

    poDS-&gt;fp = VSIFOpenL( poOpenInfo-&gt;pszFilename, "rb" );
    
// -------------------------------------------------------------------- //
//      Read the header.                                                //
// -------------------------------------------------------------------- //
    VSIFReadL( poDS-&gt;abyHeader, 1, 1012, poDS-&gt;fp );

    poDS-&gt;nRasterXSize = JDEMGetField( (char *) poDS-&gt;abyHeader + 23, 3 );
    poDS-&gt;nRasterYSize = JDEMGetField( (char *) poDS-&gt;abyHeader + 26, 3 );
    if  (poDS-&gt;nRasterXSize &lt;= 0 || poDS-&gt;nRasterYSize &lt;= 0 )
    {
        CPLError( CE_Failure, CPLE_AppDefined, 
                  "Invalid dimensions : %d x %d", 
                  poDS-&gt;nRasterXSize, poDS-&gt;nRasterYSize); 
        delete poDS;
        return NULL;
    }

// -------------------------------------------------------------------- //
//      Create band information objects.                                //
// -------------------------------------------------------------------- //
    poDS-&gt;SetBand( 1, new JDEMRasterBand( poDS, 1 ));

// -------------------------------------------------------------------- //
//      Initialize any PAM information.                                 //
// -------------------------------------------------------------------- //
    poDS-&gt;SetDescription( poOpenInfo-&gt;pszFilename );
    poDS-&gt;TryLoadXML();

// -------------------------------------------------------------------- //
//      Initialize default overviews.                                   //
// -------------------------------------------------------------------- //
    poDS-&gt;oOvManager.Initialize( poDS, poOpenInfo-&gt;pszFilename );
    return( poDS );
}
</pre></div><p>The first step in any database Open function is to verify that the file being passed is in fact of the type this driver is for. It is important to realize that each driver's Open function is called in turn till one succeeds. Drivers must quietly return NULL if the passed file is not of their format. They should only produce an error if the file does appear to be of their supported format, but is for some reason unsupported or corrupt.</p>
<p>The information on the file to be opened is passed in contained in a <a class="el" href="classGDALOpenInfo.html">GDALOpenInfo</a> object. The <a class="el" href="classGDALOpenInfo.html">GDALOpenInfo</a> includes the following public data members:</p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">char</span>        *pszFilename;
    <span class="keywordtype">char</span>        **papszSiblingFiles;

    <a class="code" href="gdal_8h.html#a045e3967c208993f70257bfd40c9f1d7">GDALAccess</a>  eAccess; <span class="comment">// GA_ReadOnly or GA_Update</span>

    <span class="keywordtype">int</span>         bStatOK;
    <span class="keywordtype">int</span>         bIsDirectory;
    
    FILE        *fp;

    <span class="keywordtype">int</span>         nHeaderBytes;
    GByte       *pabyHeader;
</pre></div><p>The driver can inspect these to establish if the file is supported. If the pszFilename refers to an object in the file system, the <b>bStatOK</b> flag will be set to TRUE. As well, if the file was successfully opened, the first kilobyte or so is read in, and put in <b>pabyHeader</b>, with the exact size in <b>nHeaderBytes</b>.</p>
<p>In this typical testing example it is verified that the file was successfully opened, that we have at least enough header information to perform our test, and that various parts of the header are as expected for this format. In this case, there are no <em>magic</em> numbers for JDEM format so we check various date fields to ensure they have reasonable century values. If the test fails, we quietly return NULL indicating this file isn't of our supported format.</p>
<div class="fragment"><pre class="fragment">    <span class="keywordflow">if</span>( poOpenInfo-&gt;nHeaderBytes &lt; 50 )
        <span class="keywordflow">return</span> NULL;

    <span class="comment">/* check if century values seem reasonable */</span>
    <span class="keywordflow">if</span>( (!EQUALN((<span class="keywordtype">char</span> *)poOpenInfo-&gt;pabyHeader+11,<span class="stringliteral">&quot;19&quot;</span>,2)
          &amp;&amp; !EQUALN((<span class="keywordtype">char</span> *)poOpenInfo-&gt;pabyHeader+11,<span class="stringliteral">&quot;20&quot;</span>,2))
        || (!EQUALN((<span class="keywordtype">char</span> *)poOpenInfo-&gt;pabyHeader+15,<span class="stringliteral">&quot;19&quot;</span>,2)
             &amp;&amp; !EQUALN((<span class="keywordtype">char</span> *)poOpenInfo-&gt;pabyHeader+15,<span class="stringliteral">&quot;20&quot;</span>,2))
        || (!EQUALN((<span class="keywordtype">char</span> *)poOpenInfo-&gt;pabyHeader+19,<span class="stringliteral">&quot;19&quot;</span>,2)
             &amp;&amp; !EQUALN((<span class="keywordtype">char</span> *)poOpenInfo-&gt;pabyHeader+19,<span class="stringliteral">&quot;20&quot;</span>,2)) )
    {
        <span class="keywordflow">return</span> NULL;
    }
</pre></div><p>It is important to make the <em>is this my format</em> test as stringent as possible. In this particular case the test is weak, and a file that happened to have 19s or 20s at a few locations could be erroneously recognized as JDEM format, causing it to not be handled properly.</p>
<p>Once we are satisfied that the file is of our format, we can do any other tests that are necessary to validate the file is usable, and in particular that we can provide the level of access desired. Since the JDEM driver</p>
<div class="fragment"><pre class="fragment">    <span class="keywordflow">if</span>( poOpenInfo-&gt;eAccess == <a class="code" href="gdal_8h.html#a045e3967c208993f70257bfd40c9f1d7a61c6081de474ef2a756982d3c53130a2">GA_Update</a> )
    {
        CPLError( CE_Failure, CPLE_NotSupported, 
                  <span class="stringliteral">&quot;The JDEM driver does not support update access to existing&quot;</span>
                  <span class="stringliteral">&quot; datasets.\n&quot;</span> );
        <span class="keywordflow">return</span> NULL;
    }
</pre></div><p>Next we need to create an instance of the database class in which we will set various information of interest.</p>
<div class="fragment"><pre class="fragment">    JDEMDataset         *poDS;

    poDS = <span class="keyword">new</span> JDEMDataset();

    poDS-&gt;fp = <a class="code" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file.">VSIFOpenL</a>( poOpenInfo-&gt;pszFilename, <span class="stringliteral">&quot;rb&quot;</span> );
</pre></div><p>At this point we open the file, to acquire a file handle for the dataset. Whenever possible, we try to use the VSI*L GDAL API to access files on disk. This virtualized POSIX-style API allows some special capabilities like supporting large files, in-memory files and zipped files.</p>
<p>Next the X and Y size are extracted from the header. The nRasterXSize and nRasterYSize are data fields inherited from the <a class="el" href="classGDALDataset.html" title="A set of associated raster bands, usually from one file.">GDALDataset</a> base class, and must be set by the Open() method.</p>
<div class="fragment"><pre class="fragment">    <a class="code" href="cpl__vsi_8h.html#aaddb197f5fb0d431a565b89281d42d93" title="Read bytes from file.">VSIFReadL</a>( poDS-&gt;abyHeader, 1, 1012, poDS-&gt;fp );

    poDS-&gt;nRasterXSize = JDEMGetField( (<span class="keywordtype">char</span> *) poDS-&gt;abyHeader + 23, 3 );
    poDS-&gt;nRasterYSize = JDEMGetField( (<span class="keywordtype">char</span> *) poDS-&gt;abyHeader + 26, 3 );

    <span class="keywordflow">if</span>  (poDS-&gt;nRasterXSize &lt;= 0 || poDS-&gt;nRasterYSize &lt;= 0 )
    {
        CPLError( CE_Failure, CPLE_AppDefined, 
                  <span class="stringliteral">&quot;Invalid dimensions : %d x %d&quot;</span>, 
                  poDS-&gt;nRasterXSize, poDS-&gt;nRasterYSize); 
        <span class="keyword">delete</span> poDS;
        <span class="keywordflow">return</span> NULL;
    }
</pre></div><p>All the bands related to this dataset must be created and attached using the SetBand() method. We will explore the JDEMRasterBand() class shortly.</p>
<div class="fragment"><pre class="fragment"><span class="comment">// -------------------------------------------------------------------- //</span>
<span class="comment">//      Create band information objects.                                //</span>
<span class="comment">// -------------------------------------------------------------------- //</span>
    poDS-&gt;SetBand( 1, <span class="keyword">new</span> JDEMRasterBand( poDS, 1 ));
</pre></div><p>Finally we assign a name to the dataset object, and call the <a class="el" href="classGDALPamDataset.html" title="A subclass of GDALDataset which introduces the ability to save and restore auxilary information (coor...">GDALPamDataset</a> TryLoadXML() method which can initialize auxiliary information from an .aux.xml file if available. For more details on these services review the <a class="el" href="classGDALPamDataset.html" title="A subclass of GDALDataset which introduces the ability to save and restore auxilary information (coor...">GDALPamDataset</a> and related classes.</p>
<div class="fragment"><pre class="fragment"><span class="comment">// -------------------------------------------------------------------- //</span>
<span class="comment">//      Initialize any PAM information.                                 //</span>
<span class="comment">// -------------------------------------------------------------------- //</span>
    poDS-&gt;SetDescription( poOpenInfo-&gt;pszFilename );
    poDS-&gt;TryLoadXML();

    <span class="keywordflow">return</span>( poDS );
}
</pre></div><h2><a class="anchor" id="gdal_drivertut_rasterband"></a>
Implementing the RasterBand</h2>
<p>Similar to the customized JDEMDataset class subclassed from <a class="el" href="classGDALDataset.html" title="A set of associated raster bands, usually from one file.">GDALDataset</a>, we also need to declare and implement a customized JDEMRasterBand derived from <a class="el" href="classGDALRasterBand.html" title="A single raster band (or channel).">GDALRasterBand</a> for access to the band(s) of the JDEM file. For JDEMRasterBand the declaration looks like this:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>JDEMRasterBand : <span class="keyword">public</span> <a class="code" href="classGDALPamRasterBand.html">GDALPamRasterBand</a>
{
  <span class="keyword">public</span>:
                JDEMRasterBand( JDEMDataset *, <span class="keywordtype">int</span> );
    <span class="keyword">virtual</span> CPLErr IReadBlock( <span class="keywordtype">int</span>, <span class="keywordtype">int</span>, <span class="keywordtype">void</span> * );
};
</pre></div><p>The constructor may have any signature, and is only called from the Open() method. Other virtual methods, such as IReadBlock() must be exactly matched to the method signature in <a class="el" href="gdal__priv_8h_source.html">gdal_priv.h</a>.</p>
<p>The constructor implementation looks like this:</p>
<div class="fragment"><pre class="fragment">JDEMRasterBand::JDEMRasterBand( JDEMDataset *poDS, <span class="keywordtype">int</span> nBand )

{
    this-&gt;poDS = poDS;
    this-&gt;nBand = nBand;
    
    eDataType = GDT_Float32;

    nBlockXSize = poDS-&gt;GetRasterXSize();
    nBlockYSize = 1;
}
</pre></div><p>The following data members are inherited from <a class="el" href="classGDALRasterBand.html" title="A single raster band (or channel).">GDALRasterBand</a>, and should generally be set in the band constructor.</p>
<ul>
<li>
<b>poDS</b>: Pointer to the parent <a class="el" href="classGDALDataset.html" title="A set of associated raster bands, usually from one file.">GDALDataset</a>. </li>
<li>
<b>nBand</b>: The band number within the dataset. </li>
<li>
<b>eDataType</b>: The data type of pixels in this band. </li>
<li>
<b>nBlockXSize</b>: The width of one block in this band. </li>
<li>
<b>nBlockYSize</b>: The height of one block in this band. </li>
</ul>
<p>The full set of possible GDALDataType values are declared in <a class="el" href="gdal_8h.html" title="Public (C callable) GDAL entry points.">gdal.h</a>, and include GDT_Byte, GDT_UInt16, GDT_Int16, and GDT_Float32. The block size is used to establish a <em>natural</em> or efficient block size to access the data with. For tiled datasets this will be the size of a tile, while for most other datasets it will be one scanline, as in this case.</p>
<p>Next we see the implementation of the code that actually reads the image data, IReadBlock().</p>
<div class="fragment"><pre class="fragment">CPLErr JDEMRasterBand::IReadBlock( <span class="keywordtype">int</span> nBlockXOff, <span class="keywordtype">int</span> nBlockYOff,
                                  <span class="keywordtype">void</span> * pImage )

{
    JDEMDataset *poGDS = (JDEMDataset *) poDS;
    <span class="keywordtype">char</span>        *pszRecord;
    <span class="keywordtype">int</span>         nRecordSize = nBlockXSize*5 + 9 + 2;
    <span class="keywordtype">int</span>         i;

    <a class="code" href="cpl__vsi_8h.html#aeac1c2bc2d4dac71e504f62be5c564f3" title="Seek to requested offset.">VSIFSeekL</a>( poGDS-&gt;fp, 1011 + nRecordSize*nBlockYOff, SEEK_SET );

    pszRecord = (<span class="keywordtype">char</span> *) CPLMalloc(nRecordSize);
    <a class="code" href="cpl__vsi_8h.html#aaddb197f5fb0d431a565b89281d42d93" title="Read bytes from file.">VSIFReadL</a>( pszRecord, 1, nRecordSize, poGDS-&gt;fp );

    <span class="keywordflow">if</span>( !EQUALN((<span class="keywordtype">char</span> *) poGDS-&gt;abyHeader,pszRecord,6) )
    {
        CPLFree( pszRecord );

        CPLError( CE_Failure, CPLE_AppDefined, 
                  <span class="stringliteral">&quot;JDEM Scanline corrupt.  Perhaps file was not transferred\n&quot;</span>
                  <span class="stringliteral">&quot;in binary mode?&quot;</span> );
        <span class="keywordflow">return</span> CE_Failure;
    }
    
    <span class="keywordflow">if</span>( JDEMGetField( pszRecord + 6, 3 ) != nBlockYOff + 1 )
    {
        CPLFree( pszRecord );

        CPLError( CE_Failure, CPLE_AppDefined, 
                  <span class="stringliteral">&quot;JDEM scanline out of order, JDEM driver does not\n&quot;</span>
                  <span class="stringliteral">&quot;currently support partial datasets.&quot;</span> );
        <span class="keywordflow">return</span> CE_Failure;
    }

    <span class="keywordflow">for</span>( i = 0; i &lt; nBlockXSize; i++ )
        ((<span class="keywordtype">float</span> *) pImage)[i] = JDEMGetField( pszRecord + 9 + 5 * i, 5) * 0.1;

    <span class="keywordflow">return</span> CE_None;
}
</pre></div><p>Key items to note are:</p>
<ul>
<li>
<p class="startli">It is typical to cast the GDALRasterBand::poDS member to the derived type of the owning dataset. If your RasterBand class will need privileged access to the owning dataset object, ensure it is declared as a friend (omitted above for brevity).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">If an error occurs, report it with <a class="el" href="cpl__error_8h.html#aad2b98dd58e4de706a245faddac90403" title="Report an error.">CPLError()</a>, and return CE_Failure. Otherwise return CE_None.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The pImage buffer should be filled with one block of data. The block is the size declared in nBlockXSize and nBlockYSize for the raster band. The type of the data within pImage should match the type declared in eDataType in the raster band object.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The nBlockXOff and nBlockYOff are block offsets, so with 128x128 tiled datasets values of 1 and 1 would indicate the block going from (128,128) to (255,255) should be loaded.</p>
<p class="endli"></p>
</li>
</ul>
<h2><a class="anchor" id="gdal_drivertut_driver"></a>
The Driver</h2>
<p>While the JDEMDataset and JDEMRasterBand are now ready to use to read image data, it still isn't clear how the GDAL system knows about the new driver. This is accomplished via the <a class="el" href="classGDALDriverManager.html" title="Class for managing the registration of file format drivers.">GDALDriverManager</a>. To register our format we implement a registration function:</p>
<div class="fragment"><pre class="fragment">CPL_C_START
<span class="keywordtype">void</span> CPL_DLL GDALRegister_JDEM(<span class="keywordtype">void</span>);
CPL_C_END

...

void GDALRegister_JDEM()

{
    <a class="code" href="classGDALDriver.html" title="Format specific driver.">GDALDriver</a>  *poDriver;

    <span class="keywordflow">if</span> (! <a class="code" href="gdal_8h.html#a10a0edfd51ed00f2460d4e8cfccbcc02" title="Helper macro for GDALCheckVersion().">GDAL_CHECK_VERSION</a>(<span class="stringliteral">&quot;JDEM&quot;</span>))
        <span class="keywordflow">return</span>;

    <span class="keywordflow">if</span>( <a class="code" href="gdal_8h.html#ae8ae868eef1e4773283d137b0a1adfc4" title="Fetch a driver based on the short name.">GDALGetDriverByName</a>( <span class="stringliteral">&quot;JDEM&quot;</span> ) == NULL )
    {
        poDriver = <span class="keyword">new</span> <a class="code" href="classGDALDriver.html" title="Format specific driver.">GDALDriver</a>();
        
        poDriver-&gt;<a class="code" href="classGDALMajorObject.html#af334bc8d152f130a55783ea36938735b" title="Set object description.">SetDescription</a>( <span class="stringliteral">&quot;JDEM&quot;</span> );
        poDriver-&gt;<a class="code" href="classGDALMajorObject.html#a3e157735f6ff6e11935c2a2dbcc24c92" title="Set single metadata item.">SetMetadataItem</a>( GDAL_DMD_LONGNAME, 
                                   <span class="stringliteral">&quot;Japanese DEM (.mem)&quot;</span> );
        poDriver-&gt;<a class="code" href="classGDALMajorObject.html#a3e157735f6ff6e11935c2a2dbcc24c92" title="Set single metadata item.">SetMetadataItem</a>( GDAL_DMD_HELPTOPIC, 
                                   <span class="stringliteral">&quot;frmt_various.html#JDEM&quot;</span> );
        poDriver-&gt;<a class="code" href="classGDALMajorObject.html#a3e157735f6ff6e11935c2a2dbcc24c92" title="Set single metadata item.">SetMetadataItem</a>( GDAL_DMD_EXTENSION, <span class="stringliteral">&quot;mem&quot;</span> );

        poDriver-&gt;pfnOpen = JDEMDataset::Open;

        GetGDALDriverManager()-&gt;<a class="code" href="classGDALDriverManager.html#aa33cc86affa255ac37b463c129fbe49f" title="Register a driver for use.">RegisterDriver</a>( poDriver );
    }
}
</pre></div><p>Note the use of GDAL_CHECK_VERSION macro (starting with GDAL 1.5.0). This is an optional macro for drivers inside GDAL tree that don't depend on external libraries, but that can be very usefull if you compile your driver as a plugin (that is to say, an out-of-tree driver). As the GDAL C++ ABI may, and will, change between GDAL releases (for example from GDAL 1.5.0 to 1.6.0), it may be necessary to recompile your driver against the header files of the GDAL version with which you want to make it work. The GDAL_CHECK_VERSION macro will check that the GDAL version with which the driver was compiled and the version against which it is running are compatible.</p>
<p>The registration function will create an instance of a <a class="el" href="classGDALDriver.html" title="Format specific driver.">GDALDriver</a> object when first called, and register it with the <a class="el" href="classGDALDriverManager.html" title="Class for managing the registration of file format drivers.">GDALDriverManager</a>. The following fields can be set in the driver before registering it with the GDALDriverManager().</p>
<ul>
<li>
<p class="startli">The description is the short name for the format. This is a unique name for this format, often used to identity the driver in scripts and commandline programs. Normally 3-5 characters in length, and matching the prefix of the format classes. (mandatory)</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">GDAL_DMD_LONGNAME: A longer descriptive name for the file format, but still no longer than 50-60 characters. (mandatory)</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">GDAL_DMD_HELPTOPIC: The name of a help topic to display for this driver, if any. In this case JDEM format is contained within the various format web page held in gdal/html. (optional)</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">GDAL_DMD_EXTENSION: The extension used for files of this type. If more than one pick the primary extension, or none at all. (optional)</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">GDAL_DMD_MIMETYPE: The standard mime type for this file format, such as "image/png". (optional)</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">GDAL_DMD_CREATIONOPTIONLIST: There is evolving work on mechanisms to describe creation options. See the geotiff driver for an example of this. (optional)</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">GDAL_DMD_CREATIONDATATYPES: A list of space separated data types supported by this create when creating new datasets. If a Create() method exists, these will be will supported. If a CreateCopy() method exists, this will be a list of types that can be losslessly exported but it may include weaker data types than the type eventually written. For instance, a format with a CreateCopy() method, and that always writes Float32 might also list Byte, Int16, and UInt16 since they can losslessly translated to Float32. An example value might be "Byte Int16 UInt16". (required - if creation supported)</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">pfnOpen: The function to call to try opening files of this format. (optional)</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">pfnCreate: The function to call to create new updatable datasets of this format. (optional)</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">pfnCreateCopy: The function to call to create a new dataset of this format copied from another source, but not necessary updatable. (optional)</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">pfnDelete: The function to call to delete a dataset of this format. (optional)</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">pfnUnloadDriver: A function called only when the driver is destroyed. Could be used to cleanup data at the driver level. Rarely used. (optional)</p>
<p class="endli"></p>
</li>
</ul>
<h2><a class="anchor" id="gdal_drivertut_addingdriver"></a>
Adding Driver to GDAL Tree</h2>
<p>Note that the GDALRegister_JDEM() method must be called by the higher level program in order to have access to the JDEM driver. Normal practice when writing new drivers is to:</p>
<ol>
<li>
<p class="startli">Add a driver directory under gdal/frmts, with the directory name the same as the short name.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Add a GNUmakefile and makefile.vc in that directory modelled on those from other similar directories (ie. the jdem directory).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Add the module with the dataset, and rasterband implementation. Generally this is called &lt;short_name&gt;dataset.cpp, with all the GDAL specific code in one file, though that is not required.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Add the registration entry point declaration (ie. GDALRegister_JDEM()) to gdal/gcore/gdal_frmts.h.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Add a call to the registration function to frmts/gdalallregister.cpp, protected by an appropriate ifdef.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Add the format short name to the GDAL_FORMATS macro in GDALmake.opt.in (and to GDALmake.opt).</p>
<p class="endli"></p>
</li>
<li>
Add a format specific item to the EXTRAFLAGS macro in frmts/makefile.vc. </li>
</ol>
<p>Once this is all done, it should be possible to rebuild GDAL, and have the new format available in all the utilities. The gdalinfo utility can be used to test that opening and reporting on the format is working, and the gdal_translate utility can be used to test image reading.</p>
<h2><a class="anchor" id="gdal_drivertut_georef"></a>
Adding Georeferencing</h2>
<p>Now we will take the example a step forward, adding georeferencing support. We add the following two virtual method overrides to JDEMDataset, taking care to exactly match the signature of the method on the GDALRasterDataset base class.</p>
<div class="fragment"><pre class="fragment">    CPLErr      GetGeoTransform( <span class="keywordtype">double</span> * padfTransform );
    <span class="keyword">const</span> <span class="keywordtype">char</span> *GetProjectionRef();
</pre></div><p>The implementation of GetGeoTransform() just copies the usual geotransform matrix into the supplied buffer. Note that GetGeoTransform() may be called a lot, so it isn't generally wise to do a lot of computation in it. In many cases the Open() will collect the geotransform, and this method will just copy it over. Also note that the geotransform return is based on an anchor point at the top left corner of the top left pixel, not the center of pixel approach used in some packages.</p>
<div class="fragment"><pre class="fragment">CPLErr JDEMDataset::GetGeoTransform( <span class="keywordtype">double</span> * padfTransform )

{
    <span class="keywordtype">double</span>      dfLLLat, dfLLLong, dfURLat, dfURLong;

    dfLLLat = JDEMGetAngle( (<span class="keywordtype">char</span> *) abyHeader + 29 );
    dfLLLong = JDEMGetAngle( (<span class="keywordtype">char</span> *) abyHeader + 36 );
    dfURLat = JDEMGetAngle( (<span class="keywordtype">char</span> *) abyHeader + 43 );
    dfURLong = JDEMGetAngle( (<span class="keywordtype">char</span> *) abyHeader + 50 );
    
    padfTransform[0] = dfLLLong;
    padfTransform[3] = dfURLat;
    padfTransform[1] = (dfURLong - dfLLLong) / GetRasterXSize();
    padfTransform[2] = 0.0;
        
    padfTransform[4] = 0.0;
    padfTransform[5] = -1 * (dfURLat - dfLLLat) / GetRasterYSize();


    <span class="keywordflow">return</span> CE_None;
}
</pre></div><p>The GetProjectionRef() method returns a pointer to an internal string containing a coordinate system definition in OGC WKT format. In this case the coordinate system is fixed for all files of this format, but in more complex cases a definition may need to be composed on the fly, in which case it may be helpful to use the OGRSpatialReference class to help build the definition.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">const</span> <span class="keywordtype">char</span> *JDEMDataset::GetProjectionRef()

{
    <span class="keywordflow">return</span>( <span class="stringliteral">&quot;GEOGCS[\&quot;Tokyo\&quot;,DATUM[\&quot;Tokyo\&quot;,SPHEROID[\&quot;Bessel 1841\&quot;,&quot;</span>
        <span class="stringliteral">&quot;6377397.155,299.1528128,AUTHORITY[\&quot;EPSG\&quot;,7004]],TOWGS84[-148,&quot;</span>
        <span class="stringliteral">&quot;507,685,0,0,0,0],AUTHORITY[\&quot;EPSG\&quot;,6301]],PRIMEM[\&quot;Greenwich\&quot;,&quot;</span>
        <span class="stringliteral">&quot;0,AUTHORITY[\&quot;EPSG\&quot;,8901]],UNIT[\&quot;DMSH\&quot;,0.0174532925199433,&quot;</span>
        <span class="stringliteral">&quot;AUTHORITY[\&quot;EPSG\&quot;,9108]],AXIS[\&quot;Lat\&quot;,NORTH],AXIS[\&quot;Long\&quot;,EAST],&quot;</span>
        <span class="stringliteral">&quot;AUTHORITY[\&quot;EPSG\&quot;,4301]]&quot;</span> );
}
</pre></div><p>This completes explanation of the features of the JDEM driver. The full source for <a href="jdemdataset.cpp.html">jdemdataset.cpp</a> can be reviewed as needed.</p>
<h2><a class="anchor" id="gdal_drivertut_overviews"></a>
Overviews</h2>
<p>GDAL allows file formats to make pre-built overviews available to applications via the <a class="el" href="classGDALRasterBand.html#a2ab58ccaef2a64ad938cd69973c6ace1" title="Fetch overview raster band object.">GDALRasterBand::GetOverview()</a> and related methods. However, implementing this is pretty involved, and goes beyond the scope of this document for now. The GeoTIFF driver (gdal/frmts/gtiff/geotiff.cpp) and related source can be reviewed for an example of a file format implementing overview reporting and creation support.</p>
<p>Formats can also report that they have arbitrary overviews, by overriding the HasArbitraryOverviews() method on the <a class="el" href="classGDALRasterBand.html" title="A single raster band (or channel).">GDALRasterBand</a>, returning TRUE. In this case the raster band object is expected to override the RasterIO() method itself, to implement efficient access to imagery with resampling. This is also involved, and there are a lot of requirements for correct implementation of the RasterIO() method. An example of this can be found in the OGDI and ECW formats.</p>
<p>However, by far the most common approach to implementing overviews is to use the default support in GDAL for external overviews stored in TIFF files with the same name as the dataset, but the extension .ovr appended. In order to enable reading and creation of this style of overviews it is necessary for the <a class="el" href="classGDALDataset.html" title="A set of associated raster bands, usually from one file.">GDALDataset</a> to initialize the oOvManager object within itself. This is typically accomplished with a call like the following near the end of the Open() method (after the PAM TryLoadXML()).</p>
<div class="fragment"><pre class="fragment">    poDS-&gt;oOvManager.Initialize( poDS, poOpenInfo-&gt;pszFilename );
</pre></div><p>This will enable default implementations for reading and creating overviews for the format. It is advised that this be enabled for all simple file system based formats unless there is a custom overview mechanism to be tied into.</p>
<h2><a class="anchor" id="gdal_drivertut_creation"></a>
File Creation</h2>
<p>There are two approaches to file creation. The first method is called the CreateCopy() method, and involves implementing a function that can write a file in the output format, pulling all imagery and other information needed from a source <a class="el" href="classGDALDataset.html" title="A set of associated raster bands, usually from one file.">GDALDataset</a>. The second method, the dynamic creation method, involves implementing a Create method to create the shell of the file, and then the application writes various information by calls to set methods.</p>
<p>The benefits of the first method are that that all the information is available at the point the output file is being created. This can be especially important when implementing file formats using external libraries which require information like colormaps, and georeferencing information at the point the file is created. The other advantage of this method is that the CreateCopy() method can read some kinds of information, such as min/max, scaling, description and GCPs for which there are no equivalent set methods.</p>
<p>The benefits of the second method are that applications can create an empty new file, and write results to it as they become available. A complete image of the desired data does not have to be available in advance.</p>
<p>For very important formats both methods may be implemented, otherwise do whichever is simpler, or provides the required capabilities.</p>
<h3><a class="anchor" id="gdal_drivertut_creation_createcopy"></a>
CreateCopy</h3>
<p>The <a class="el" href="classGDALDriver.html#a2c897da2a6e25169cccc49ef48797ce1" title="Create a copy of a dataset.">GDALDriver::CreateCopy()</a> method call is passed through directly, so that method should be consulted for details of arguments. However, some things to keep in mind are:</p>
<ul>
<li>
<p class="startli">If the bStrict flag is FALSE the driver should try to do something reasonable when it cannot exactly represent the source dataset, transforming data types on the fly, dropping georeferencing and so forth.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Implementing progress reporting correctly is somewhat involved. The return result of the progress function needs always to be checked for cancellation, and progress should be reported at reasonable intervals. The JPEGCreateCopy() method demonstrates good handling of the progress function.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Special creation options should be documented in the online help. If the options take the format "NAME=VALUE" the papszOptions list can be manipulated with CPLFetchNameValue() as demonstrated in the handling of the QUALITY and PROGRESSIVE flags for JPEGCreateCopy().</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The returned <a class="el" href="classGDALDataset.html" title="A set of associated raster bands, usually from one file.">GDALDataset</a> handle can be in ReadOnly or Update mode. Return it in Update mode if practical, otherwise in ReadOnly mode is fine.</p>
<p class="endli"></p>
</li>
</ul>
<p>The full implementation of the CreateCopy function for JPEG (which is assigned to pfnCreateCopy in the <a class="el" href="classGDALDriver.html" title="Format specific driver.">GDALDriver</a> object) is here.</p>
<div class="fragment"><pre class="fragment">
static GDALDataset *
JPEGCreateCopy( const char * pszFilename, GDALDataset *poSrcDS, 
                int bStrict, char ** papszOptions, 
                GDALProgressFunc pfnProgress, void * pProgressData )

{
    int  nBands = poSrcDS-&gt;GetRasterCount();
    int  nXSize = poSrcDS-&gt;GetRasterXSize();
    int  nYSize = poSrcDS-&gt;GetRasterYSize();
    int  nQuality = 75;
    int  bProgressive = FALSE;

// -------------------------------------------------------------------- 
//      Some some rudimentary checks                                    
// -------------------------------------------------------------------- 
    if( nBands != 1 &amp;&amp; nBands != 3 )
    {
        CPLError( CE_Failure, CPLE_NotSupported, 
                  "JPEG driver doesn't support %d bands.  Must be 1 (grey) "
                  "or 3 (RGB) bands.\n", nBands );

        return NULL;
    }

    if( poSrcDS-&gt;GetRasterBand(1)-&gt;GetRasterDataType() != GDT_Byte &amp;&amp; bStrict )
    {
        CPLError( CE_Failure, CPLE_NotSupported, 
                  "JPEG driver doesn't support data type %s. "
                  "Only eight bit byte bands supported.\n", 
                  GDALGetDataTypeName( 
                      poSrcDS-&gt;GetRasterBand(1)-&gt;GetRasterDataType()) );

        return NULL;
    }

// -------------------------------------------------------------------- 
//      What options has the user selected?                             
// -------------------------------------------------------------------- 
    if( CSLFetchNameValue(papszOptions,"QUALITY") != NULL )
    {
        nQuality = atoi(CSLFetchNameValue(papszOptions,"QUALITY"));
        if( nQuality &lt; 10 || nQuality &gt; 100 )
        {
            CPLError( CE_Failure, CPLE_IllegalArg,
                      "QUALITY=%s is not a legal value in the range 10-100.",
                      CSLFetchNameValue(papszOptions,"QUALITY") );
            return NULL;
        }
    }

    if( CSLFetchNameValue(papszOptions,"PROGRESSIVE") != NULL )
    {
        bProgressive = TRUE;
    }

// -------------------------------------------------------------------- 
//      Create the dataset.                                             
// -------------------------------------------------------------------- 
    FILE	*fpImage;

    fpImage = VSIFOpen( pszFilename, "wb" );
    if( fpImage == NULL )
    {
        CPLError( CE_Failure, CPLE_OpenFailed, 
                  "Unable to create jpeg file %s.\n", 
                  pszFilename );
        return NULL;
    }

// -------------------------------------------------------------------- 
//      Initialize JPG access to the file.                              
// -------------------------------------------------------------------- 
    struct jpeg_compress_struct sCInfo;
    struct jpeg_error_mgr sJErr;
    
    sCInfo.err = jpeg_std_error( &amp;sJErr );
    jpeg_create_compress( &amp;sCInfo );
    
    jpeg_stdio_dest( &amp;sCInfo, fpImage );
    
    sCInfo.image_width = nXSize;
    sCInfo.image_height = nYSize;
    sCInfo.input_components = nBands;

    if( nBands == 1 )
    {
        sCInfo.in_color_space = JCS_GRAYSCALE;
    }
    else
    {
        sCInfo.in_color_space = JCS_RGB;
    }

    jpeg_set_defaults( &amp;sCInfo );
    
    jpeg_set_quality( &amp;sCInfo, nQuality, TRUE );

    if( bProgressive )
        jpeg_simple_progression( &amp;sCInfo );

    jpeg_start_compress( &amp;sCInfo, TRUE );

// -------------------------------------------------------------------- 
//      Loop over image, copying image data.                            
// -------------------------------------------------------------------- 
    GByte 	*pabyScanline;
    CPLErr      eErr;

    pabyScanline = (GByte *) CPLMalloc( nBands * nXSize );

    for( int iLine = 0; iLine &lt; nYSize; iLine++ )
    {
        JSAMPLE      *ppSamples;

        for( int iBand = 0; iBand &lt; nBands; iBand++ )
        {
            GDALRasterBand * poBand = poSrcDS-&gt;GetRasterBand( iBand+1 );
            eErr = poBand-&gt;RasterIO( GF_Read, 0, iLine, nXSize, 1, 
                                     pabyScanline + iBand, nXSize, 1, GDT_Byte,
                                     nBands, nBands * nXSize );
        }

        ppSamples = pabyScanline;
        jpeg_write_scanlines( &amp;sCInfo, &amp;ppSamples, 1 );
    }

    CPLFree( pabyScanline );

    jpeg_finish_compress( &amp;sCInfo );
    jpeg_destroy_compress( &amp;sCInfo );

    VSIFClose( fpImage );

    return (GDALDataset *) GDALOpen( pszFilename, GA_ReadOnly );
}
</pre></div><h3><a class="anchor" id="gdal_drivertut_creation_create"></a>
Dynamic Creation</h3>
<p>In the case of dynamic creation, there is no source dataset. Instead the size, number of bands, and pixel data type of the desired file is provided but other information (such as georeferencing, and imagery data) would be supplied later via other method calls on the resulting <a class="el" href="classGDALDataset.html" title="A set of associated raster bands, usually from one file.">GDALDataset</a>.</p>
<p>The following sample implement PCI .aux labelled raw raster creation. It follows a common approach of creating a blank, but valid file using non-GDAL calls, and then calling GDALOpen(,GA_Update) at the end to return a writable file handle. This avoids having to duplicate the various setup actions in the Open() function.</p>
<div class="fragment"><pre class="fragment">
GDALDataset *PAuxDataset::Create( const char * pszFilename,
                                  int nXSize, int nYSize, int nBands,
                                  GDALDataType eType,
                                  char ** // papszParmList  )

{
    char	*pszAuxFilename;

// -------------------------------------------------------------------- 
//      Verify input options.                                           
// -------------------------------------------------------------------- 
    if( eType != GDT_Byte &amp;&amp; eType != GDT_Float32 &amp;&amp; eType != GDT_UInt16
        &amp;&amp; eType != GDT_Int16 )
    {
        CPLError( CE_Failure, CPLE_AppDefined,
              "Attempt to create PCI .Aux labelled dataset with an illegal\n"
              "data type (%s).\n",
              GDALGetDataTypeName(eType) );

        return NULL;
    }

// -------------------------------------------------------------------- 
//      Try to create the file.                                         
// -------------------------------------------------------------------- 
    FILE	*fp;

    fp = VSIFOpen( pszFilename, "w" );

    if( fp == NULL )
    {
        CPLError( CE_Failure, CPLE_OpenFailed,
                  "Attempt to create file `%s' failed.\n",
                  pszFilename );
        return NULL;
    }

// -------------------------------------------------------------------- 
//      Just write out a couple of bytes to establish the binary        
//      file, and then close it.                                        
// -------------------------------------------------------------------- 
    VSIFWrite( (void *) "\0\0", 2, 1, fp );
    VSIFClose( fp );

// -------------------------------------------------------------------- 
//      Create the aux filename.                                        
// -------------------------------------------------------------------- 
    pszAuxFilename = (char *) CPLMalloc(strlen(pszFilename)+5);
    strcpy( pszAuxFilename, pszFilename );;

    for( int i = strlen(pszAuxFilename)-1; i &gt; 0; i-- )
    {
        if( pszAuxFilename[i] == '.' )
        {
            pszAuxFilename[i] = '\0';
            break;
        }
    }

    strcat( pszAuxFilename, ".aux" );

// -------------------------------------------------------------------- 
//      Open the file.                                                  
// -------------------------------------------------------------------- 
    fp = VSIFOpen( pszAuxFilename, "wt" );
    if( fp == NULL )
    {
        CPLError( CE_Failure, CPLE_OpenFailed,
                  "Attempt to create file `%s' failed.\n",
                  pszAuxFilename );
        return NULL;
    }
    
// -------------------------------------------------------------------- 
//      We need to write out the original filename but without any      
//      path components in the AuxilaryTarget line.  Do so now.         
// -------------------------------------------------------------------- 
    int		iStart;

    iStart = strlen(pszFilename)-1;
    while( iStart &gt; 0 &amp;&amp; pszFilename[iStart-1] != '/'
           &amp;&amp; pszFilename[iStart-1] != '\\' )
        iStart--;

    VSIFPrintf( fp, "AuxilaryTarget: %s\n", pszFilename + iStart );

// -------------------------------------------------------------------- 
//      Write out the raw definition for the dataset as a whole.        
// -------------------------------------------------------------------- 
    VSIFPrintf( fp, "RawDefinition: %d %d %d\n",
                nXSize, nYSize, nBands );

// -------------------------------------------------------------------- 
//      Write out a definition for each band.  We always write band     
//      sequential files for now as these are pretty efficiently        
//      handled by GDAL.                                                
// -------------------------------------------------------------------- 
    int		nImgOffset = 0;
    
    for( int iBand = 0; iBand &lt; nBands; iBand++ )
    {
        const char * pszTypeName;
        int	     nPixelOffset;
        int	     nLineOffset;

        nPixelOffset = GDALGetDataTypeSize(eType)/8;
        nLineOffset = nXSize * nPixelOffset;

        if( eType == GDT_Float32 )
            pszTypeName = "32R";
        else if( eType == GDT_Int16 )
            pszTypeName = "16S";
        else if( eType == GDT_UInt16 )
            pszTypeName = "16U";
        else
            pszTypeName = "8U";

        VSIFPrintf( fp, "ChanDefinition-%d: %s %d %d %d %s\n",
                    iBand+1, pszTypeName,
                    nImgOffset, nPixelOffset, nLineOffset,
#ifdef CPL_LSB
                    "Swapped"
#else
                    "Unswapped"
#endif
                    );

        nImgOffset += nYSize * nLineOffset;
    }

// -------------------------------------------------------------------- 
//      Cleanup                                                         
// -------------------------------------------------------------------- 
    VSIFClose( fp );

    return (GDALDataset *) GDALOpen( pszFilename, GA_Update );
}
</pre></div><p>File formats supporting dynamic creation, or even just update-in-place access also need to implement an IWriteBlock() method on the raster band class. It has semantics similar to IReadBlock(). As well, for various esoteric reasons, it is critical that a FlushCache() method be implemented in the raster band destructor. This is to ensure that any write cache blocks for the band be flushed out before the destructor is called.</p>
<h2><a class="anchor" id="gdal_drivertut_raw"></a>
RawDataset/RawRasterBand Helper Classes</h2>
<p>Many file formats have the actual imagery data stored in a regular, binary, scanline oriented format. Rather than re-implement the access semantics for this for each formats, there are provided RawDataset and RawRasterBand classes declared in gdal/frmts/raw that can be utilized to implement efficient and convenient access.</p>
<p>In these cases the format specific band class may not be required, or if required it can be derived from RawRasterBand. The dataset class should be derived from RawDataset.</p>
<p>The Open() method for the dataset then instantiates raster bands passing all the layout information to the constructor. For instance, the PNM driver uses the following calls to create it's raster bands.</p>
<div class="fragment"><pre class="fragment">    <span class="keywordflow">if</span>( poOpenInfo-&gt;pabyHeader[1] == <span class="charliteral">&#39;5&#39;</span> )
    {
        poDS-&gt;SetBand( 
            1, <span class="keyword">new</span> RawRasterBand( poDS, 1, poDS-&gt;fpImage,
                                  iIn, 1, nWidth, <a class="code" href="gdal_8h.html#a22e22ce0a55036a96f652765793fb7a4a38a66c26861d368e95ba42106ee3ab92">GDT_Byte</a>, TRUE ));
    }
    <span class="keywordflow">else</span> 
    {
        poDS-&gt;SetBand( 
            1, <span class="keyword">new</span> RawRasterBand( poDS, 1, poDS-&gt;fpImage,
                                  iIn, 3, nWidth*3, <a class="code" href="gdal_8h.html#a22e22ce0a55036a96f652765793fb7a4a38a66c26861d368e95ba42106ee3ab92">GDT_Byte</a>, TRUE ));
        poDS-&gt;SetBand( 
            2, <span class="keyword">new</span> RawRasterBand( poDS, 2, poDS-&gt;fpImage,
                                  iIn+1, 3, nWidth*3, <a class="code" href="gdal_8h.html#a22e22ce0a55036a96f652765793fb7a4a38a66c26861d368e95ba42106ee3ab92">GDT_Byte</a>, TRUE ));
        poDS-&gt;SetBand( 
            3, <span class="keyword">new</span> RawRasterBand( poDS, 3, poDS-&gt;fpImage,
                                  iIn+2, 3, nWidth*3, <a class="code" href="gdal_8h.html#a22e22ce0a55036a96f652765793fb7a4a38a66c26861d368e95ba42106ee3ab92">GDT_Byte</a>, TRUE ));
    }
</pre></div><p>The RawRasterBand takes the following arguments.</p>
<ul>
<li>
<b>poDS</b>: The <a class="el" href="classGDALDataset.html" title="A set of associated raster bands, usually from one file.">GDALDataset</a> this band will be a child of. This dataset must be of a class derived from RawRasterDataset. </li>
<li>
<b>nBand</b>: The band it is on that dataset, 1 based. </li>
<li>
<b>fpRaw</b>: The FILE * handle to the file containing the raster data. </li>
<li>
<b>nImgOffset</b>: The byte offset to the first pixel of raster data for the first scanline. </li>
<li>
<b>nPixelOffset</b>: The byte offset from the start of one pixel to the start of the next within the scanline. </li>
<li>
<b>nLineOffset</b>: The byte offset from the start of one scanline to the start of the next. </li>
<li>
<b>eDataType</b>: The GDALDataType code for the type of the data on disk. </li>
<li>
<b>bNativeOrder</b>: FALSE if the data is not in the same endianness as the machine GDAL is running on. The data will be automatically byte swapped. </li>
</ul>
<p>Simple file formats utilizing the Raw services are normally placed all within one file in the gdal/frmts/raw directory. There are numerous examples there of format implementation.</p>
<h2><a class="anchor" id="gdal_drivertut_metadata"></a>
Metadata, and Other Exotic Extensions</h2>
<p>There are various other items in the GDAL data model, for which virtual methods exist on the <a class="el" href="classGDALDataset.html" title="A set of associated raster bands, usually from one file.">GDALDataset</a> and <a class="el" href="classGDALRasterBand.html" title="A single raster band (or channel).">GDALRasterBand</a>. They include:</p>
<ul>
<li>
<p class="startli"><b>Metadata</b>: Name/value text values about a dataset or band. The <a class="el" href="classGDALMajorObject.html" title="Object with metadata.">GDALMajorObject</a> (base class for <a class="el" href="classGDALRasterBand.html" title="A single raster band (or channel).">GDALRasterBand</a> and <a class="el" href="classGDALDataset.html" title="A set of associated raster bands, usually from one file.">GDALDataset</a>) has built-in support for holding metadata, so for read access it only needs to be set with calls to SetMetadataItem() during the Open(). The SAR_CEOS (frmts/ceos2/sar_ceosdataset.cpp) and GeoTIFF drivers are examples of drivers implementing readable metadata.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>ColorTables</b>: GDT_Byte raster bands can have color tables associated with them. The frmts/png/pngdataset.cpp driver contains an example of a format that supports colortables.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>ColorInterpretation</b>: The PNG driver contains an example of a driver that returns an indication of whether a band should be treated as a Red, Green, Blue, Alpha or Greyscale band.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>GCPs</b>: GDALDatasets can have a set of ground control points associated with them (as opposed to an explicit affine transform returned by GetGeotransform()) relating the raster to georeferenced coordinates. The MFF2 (gdal/frmts/raw/hkvdataset.cpp) format is a simple example of a format supporting GCPs.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>NoDataValue</b>: Bands with known "nodata" values can implement the GetNoDataValue() method. See the PAux (frmts/raw/pauxdataset.cpp) for an example of this.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Category Names</b>: Classified images with names for each class can return them using the GetCategoryNames() method though no formats currently implement this.</p>
<p class="endli"></p>
</li>
</ul>
 
<p>
$Id: gdal_drivertut.dox 25410 2012-12-31 11:56:53Z rouault $
</p>
 </div>
<hr>

Generated for GDAL by 
<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.7.1.
</body>
</html>

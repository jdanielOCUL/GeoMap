<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>GDAL: cpl_vsi.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>cpl_vsi.h File Reference</h1>  </div>
</div>
<div class="contents">

<p>Standard C Covers.  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="cpl__port_8h_source.html">cpl_port.h</a>&quot;</code><br/>
<code>#include &lt;unistd.h&gt;</code><br/>
<code>#include &lt;sys/stat.h&gt;</code><br/>

<p><a href="cpl__vsi_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e5cdfef2e52acfa6c2d723934e0d796"></a><!-- doxytag: member="cpl_vsi.h::VSI_ISLNK" ref="a7e5cdfef2e52acfa6c2d723934e0d796" args="(x)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSI_ISLNK</b>(x)&nbsp;&nbsp;&nbsp;S_ISLNK(x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57c4561cb89d1e6d0273c5be2a374777"></a><!-- doxytag: member="cpl_vsi.h::VSI_ISREG" ref="a57c4561cb89d1e6d0273c5be2a374777" args="(x)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSI_ISREG</b>(x)&nbsp;&nbsp;&nbsp;S_ISREG(x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13e9ada3d2bb3df2eae358b1037f9a1b"></a><!-- doxytag: member="cpl_vsi.h::VSI_ISDIR" ref="a13e9ada3d2bb3df2eae358b1037f9a1b" args="(x)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSI_ISDIR</b>(x)&nbsp;&nbsp;&nbsp;S_ISDIR(x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0307743404aa7fcc7c8b32473ac03031"></a><!-- doxytag: member="cpl_vsi.h::VSI_ISCHR" ref="a0307743404aa7fcc7c8b32473ac03031" args="(x)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSI_ISCHR</b>(x)&nbsp;&nbsp;&nbsp;S_ISCHR(x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77b4be0683f8d97fc37631d06bb21dcf"></a><!-- doxytag: member="cpl_vsi.h::VSI_ISBLK" ref="a77b4be0683f8d97fc37631d06bb21dcf" args="(x)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSI_ISBLK</b>(x)&nbsp;&nbsp;&nbsp;S_ISBLK(x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e3fb3d4a5abff8b360d7b7941397503"></a><!-- doxytag: member="cpl_vsi.h::VSI_STAT_EXISTS_FLAG" ref="a3e3fb3d4a5abff8b360d7b7941397503" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSI_STAT_EXISTS_FLAG</b>&nbsp;&nbsp;&nbsp;0x1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae67c44d6a3cae38b33d4b4b6bfb02131"></a><!-- doxytag: member="cpl_vsi.h::VSI_STAT_NATURE_FLAG" ref="ae67c44d6a3cae38b33d4b4b6bfb02131" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSI_STAT_NATURE_FLAG</b>&nbsp;&nbsp;&nbsp;0x2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4465858df54d216dbade556b08a5d4d"></a><!-- doxytag: member="cpl_vsi.h::VSI_STAT_SIZE_FLAG" ref="ac4465858df54d216dbade556b08a5d4d" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSI_STAT_SIZE_FLAG</b>&nbsp;&nbsp;&nbsp;0x4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afdc1dc07ba4fe31933c9b522de783692"></a><!-- doxytag: member="cpl_vsi.h::CPLReadDir" ref="afdc1dc07ba4fe31933c9b522de783692" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>CPLReadDir</b>&nbsp;&nbsp;&nbsp;VSIReadDir</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec2052160cd515ca99b6f9028c4239ef"></a><!-- doxytag: member="cpl_vsi.h::VSIDebug4" ref="aec2052160cd515ca99b6f9028c4239ef" args="(f, a1, a2, a3, a4)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSIDebug4</b>(f, a1, a2, a3, a4)&nbsp;&nbsp;&nbsp;{}</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33e378283de935576186904014bfceba"></a><!-- doxytag: member="cpl_vsi.h::VSIDebug3" ref="a33e378283de935576186904014bfceba" args="(f, a1, a2, a3)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSIDebug3</b>(f, a1, a2, a3)&nbsp;&nbsp;&nbsp;{}</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31b90a5e6071a220fbd78aa7503dd5c9"></a><!-- doxytag: member="cpl_vsi.h::VSIDebug2" ref="a31b90a5e6071a220fbd78aa7503dd5c9" args="(f, a1, a2)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSIDebug2</b>(f, a1, a2)&nbsp;&nbsp;&nbsp;{}</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23c8f39bc59a0098a030b5e106d6f35e"></a><!-- doxytag: member="cpl_vsi.h::VSIDebug1" ref="a23c8f39bc59a0098a030b5e106d6f35e" args="(f, a1)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSIDebug1</b>(f, a1)&nbsp;&nbsp;&nbsp;{}</td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca94fc722aae44cab35e247919e56258"></a><!-- doxytag: member="cpl_vsi.h::VSIStatBuf" ref="aca94fc722aae44cab35e247919e56258" args="" -->
typedef struct stat&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSIStatBuf</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af56f9ebab1994e4c2ed3f0a50af787b2"></a><!-- doxytag: member="cpl_vsi.h::vsi_l_offset" ref="af56f9ebab1994e4c2ed3f0a50af787b2" args="" -->
typedef GUIntBig&nbsp;</td><td class="memItemRight" valign="bottom"><b>vsi_l_offset</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1b1400e402360b38304de2b13d16c14"></a><!-- doxytag: member="cpl_vsi.h::VSILFILE" ref="af1b1400e402360b38304de2b13d16c14" args="" -->
typedef FILE&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSILFILE</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="accc7d5e1f7745ec91b5e32654870e324"></a><!-- doxytag: member="cpl_vsi.h::VSIStatBufL" ref="accc7d5e1f7745ec91b5e32654870e324" args="" -->
typedef struct VSI_STAT64_T&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSIStatBufL</b></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44804eb23e1ac0a2244bb5107849d52a"></a><!-- doxytag: member="cpl_vsi.h::VSIFOpen" ref="a44804eb23e1ac0a2244bb5107849d52a" args="(const char *, const char *) CPL_WARN_UNUSED_RESULT" -->
FILE *&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSIFOpen</b> (const char *, const char *) CPL_WARN_UNUSED_RESULT</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adda42c2ff8664235ab34deb25ddd9cf2"></a><!-- doxytag: member="cpl_vsi.h::VSIFClose" ref="adda42c2ff8664235ab34deb25ddd9cf2" args="(FILE *)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSIFClose</b> (FILE *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50ea2272b7e9f6436a443819aa593dc0"></a><!-- doxytag: member="cpl_vsi.h::VSIFSeek" ref="a50ea2272b7e9f6436a443819aa593dc0" args="(FILE *, long, int)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSIFSeek</b> (FILE *, long, int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34a0b1228ceab81163c55164d8e5267b"></a><!-- doxytag: member="cpl_vsi.h::VSIFTell" ref="a34a0b1228ceab81163c55164d8e5267b" args="(FILE *)" -->
long&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSIFTell</b> (FILE *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31c62d7b1df249ced9bb5472f2d890ad"></a><!-- doxytag: member="cpl_vsi.h::VSIRewind" ref="a31c62d7b1df249ced9bb5472f2d890ad" args="(FILE *)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSIRewind</b> (FILE *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c3feeb40152558777808781b07dd55e"></a><!-- doxytag: member="cpl_vsi.h::VSIFFlush" ref="a0c3feeb40152558777808781b07dd55e" args="(FILE *)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSIFFlush</b> (FILE *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb4d40efd89436df4b9cb83f34dc5939"></a><!-- doxytag: member="cpl_vsi.h::VSIFRead" ref="abb4d40efd89436df4b9cb83f34dc5939" args="(void *, size_t, size_t, FILE *)" -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSIFRead</b> (void *, size_t, size_t, FILE *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9230d5cfc5580e0345299c26723fdfe2"></a><!-- doxytag: member="cpl_vsi.h::VSIFWrite" ref="a9230d5cfc5580e0345299c26723fdfe2" args="(const void *, size_t, size_t, FILE *)" -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSIFWrite</b> (const void *, size_t, size_t, FILE *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acec808c6993d721c7e236377d4c1d690"></a><!-- doxytag: member="cpl_vsi.h::VSIFGets" ref="acec808c6993d721c7e236377d4c1d690" args="(char *, int, FILE *)" -->
char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSIFGets</b> (char *, int, FILE *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6fb50a842a973dfe7ab97b5ecb4d4e6"></a><!-- doxytag: member="cpl_vsi.h::VSIFPuts" ref="ac6fb50a842a973dfe7ab97b5ecb4d4e6" args="(const char *, FILE *)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSIFPuts</b> (const char *, FILE *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7576c3e0851da567c26300271bb6a94"></a><!-- doxytag: member="cpl_vsi.h::VSIFPrintf" ref="ae7576c3e0851da567c26300271bb6a94" args="(FILE *, const char *,...)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSIFPrintf</b> (FILE *, const char *,...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a749b239bd1d74d080ca0ab873e2c8120"></a><!-- doxytag: member="cpl_vsi.h::VSIFGetc" ref="a749b239bd1d74d080ca0ab873e2c8120" args="(FILE *)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSIFGetc</b> (FILE *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16aebafb9ef21a8ed882fe6f4f24c353"></a><!-- doxytag: member="cpl_vsi.h::VSIFPutc" ref="a16aebafb9ef21a8ed882fe6f4f24c353" args="(int, FILE *)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSIFPutc</b> (int, FILE *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e371a5f54a8db766ccb5d2c4c3839df"></a><!-- doxytag: member="cpl_vsi.h::VSIUngetc" ref="a6e371a5f54a8db766ccb5d2c4c3839df" args="(int, FILE *)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSIUngetc</b> (int, FILE *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a321c704abecced941035b455d357fd"></a><!-- doxytag: member="cpl_vsi.h::VSIFEof" ref="a7a321c704abecced941035b455d357fd" args="(FILE *)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSIFEof</b> (FILE *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a197e1b9b8477f6f5dce84c0f5c48f20f"></a><!-- doxytag: member="cpl_vsi.h::VSIStat" ref="a197e1b9b8477f6f5dce84c0f5c48f20f" args="(const char *, VSIStatBuf *)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSIStat</b> (const char *, VSIStatBuf *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VSILFILE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5">VSIFOpenL</a> (const char *, const char *) CPL_WARN_UNUSED_RESULT</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open file.  <a href="#ae3cfa1605ce32e78fddb534bba7742f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a82fe6612261c1948eee388e75b7d6db7">VSIFCloseL</a> (VSILFILE *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close file.  <a href="#a82fe6612261c1948eee388e75b7d6db7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#aeac1c2bc2d4dac71e504f62be5c564f3">VSIFSeekL</a> (VSILFILE *, vsi_l_offset, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Seek to requested offset.  <a href="#aeac1c2bc2d4dac71e504f62be5c564f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vsi_l_offset&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a25fe184bb565bbda49965102dbe0ca15">VSIFTellL</a> (VSILFILE *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tell current file offset.  <a href="#a25fe184bb565bbda49965102dbe0ca15"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abbbc227f7c966e95ece4691c3cc1c562"></a><!-- doxytag: member="cpl_vsi.h::VSIRewindL" ref="abbbc227f7c966e95ece4691c3cc1c562" args="(VSILFILE *)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSIRewindL</b> (VSILFILE *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#aaddb197f5fb0d431a565b89281d42d93">VSIFReadL</a> (void *, size_t, size_t, VSILFILE *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read bytes from file.  <a href="#aaddb197f5fb0d431a565b89281d42d93"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#aaeb325d9dcb43c16a3fa1592ed7c1d2b">VSIFReadMultiRangeL</a> (int nRanges, void **ppData, const vsi_l_offset *panOffsets, const size_t *panSizes, VSILFILE *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read several ranges of bytes from file.  <a href="#aaeb325d9dcb43c16a3fa1592ed7c1d2b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a2a382b55d461f4979f523e8c6e257ada">VSIFWriteL</a> (const void *, size_t, size_t, VSILFILE *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write bytes to file.  <a href="#a2a382b55d461f4979f523e8c6e257ada"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ab72b69150d9dd7adb6e756196867a9b2">VSIFEofL</a> (VSILFILE *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test for end of file.  <a href="#ab72b69150d9dd7adb6e756196867a9b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a3363cbf28c47b5dcadaf0812dd50e6b9">VSIFTruncateL</a> (VSILFILE *, vsi_l_offset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Truncate/expand the file to the specified size.  <a href="#a3363cbf28c47b5dcadaf0812dd50e6b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a224b7e3c50275ae1924e89185df5494d">VSIFFlushL</a> (VSILFILE *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flush pending writes to disk.  <a href="#a224b7e3c50275ae1924e89185df5494d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ad19d593846fa567ada334b12a7bf8a3b">VSIFPrintfL</a> (VSILFILE *, const char *,...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Formatted write to file.  <a href="#ad19d593846fa567ada334b12a7bf8a3b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6765447625c67466595e410519586fb7"></a><!-- doxytag: member="cpl_vsi.h::VSIFPutcL" ref="a6765447625c67466595e410519586fb7" args="(int, VSILFILE *)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSIFPutcL</b> (int, VSILFILE *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a6c5ab5def482f0efc439162b2896b4ea">VSIIngestFile</a> (VSILFILE *fp, const char *pszFilename, GByte **ppabyRet, vsi_l_offset *pnSize, GIntBig nMaxSize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ingest a file into memory.  <a href="#a6c5ab5def482f0efc439162b2896b4ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ac92fbd5e6fc143b026001b32c4c19ed1">VSIStatL</a> (const char *, VSIStatBufL *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get filesystem object info.  <a href="#ac92fbd5e6fc143b026001b32c4c19ed1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ad1a691db1ba2f43add25a5c0d6498da6">VSIStatExL</a> (const char *pszFilename, VSIStatBufL *psStatBuf, int nFlags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get filesystem object info.  <a href="#ad1a691db1ba2f43add25a5c0d6498da6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a36737f0cb2949ba2f7bbf23cc6592a04">VSIIsCaseSensitiveFS</a> (const char *pszFilename)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns if the filenames of the filesystem are case sensitive.  <a href="#a36737f0cb2949ba2f7bbf23cc6592a04"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a41fd7388a7491b3430d0abe961dada82">VSIFGetNativeFileDescriptorL</a> (VSILFILE *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the "native" file descriptor for the virtual handle.  <a href="#a41fd7388a7491b3430d0abe961dada82"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84892f1a5065294b3e3c400534e6a86c"></a><!-- doxytag: member="cpl_vsi.h::VSICalloc" ref="a84892f1a5065294b3e3c400534e6a86c" args="(size_t, size_t) CPL_WARN_UNUSED_RESULT" -->
void *&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSICalloc</b> (size_t, size_t) CPL_WARN_UNUSED_RESULT</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e403f4f7e059d12da468d20d604e13c"></a><!-- doxytag: member="cpl_vsi.h::VSIMalloc" ref="a3e403f4f7e059d12da468d20d604e13c" args="(size_t) CPL_WARN_UNUSED_RESULT" -->
void *&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSIMalloc</b> (size_t) CPL_WARN_UNUSED_RESULT</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af26e15498e19c2a8169db924415ff7ab"></a><!-- doxytag: member="cpl_vsi.h::VSIFree" ref="af26e15498e19c2a8169db924415ff7ab" args="(void *)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSIFree</b> (void *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac022eb90a80c108cc43c619ccd17792c"></a><!-- doxytag: member="cpl_vsi.h::VSIRealloc" ref="ac022eb90a80c108cc43c619ccd17792c" args="(void *, size_t) CPL_WARN_UNUSED_RESULT" -->
void *&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSIRealloc</b> (void *, size_t) CPL_WARN_UNUSED_RESULT</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0500f0dbd6c8c854931c6aa17d6566e"></a><!-- doxytag: member="cpl_vsi.h::VSIStrdup" ref="ac0500f0dbd6c8c854931c6aa17d6566e" args="(const char *) CPL_WARN_UNUSED_RESULT" -->
char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSIStrdup</b> (const char *) CPL_WARN_UNUSED_RESULT</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a2286902bc6bf22d866e72df2e474d68c">VSIMalloc2</a> (size_t nSize1, size_t nSize2) CPL_WARN_UNUSED_RESULT</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">VSIMalloc2 allocates (nSize1 * nSize2) bytes.  <a href="#a2286902bc6bf22d866e72df2e474d68c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a5114ce8d68c4f351309805314f3b5063">VSIMalloc3</a> (size_t nSize1, size_t nSize2, size_t nSize3) CPL_WARN_UNUSED_RESULT</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">VSIMalloc3 allocates (nSize1 * nSize2 * nSize3) bytes.  <a href="#a5114ce8d68c4f351309805314f3b5063"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a6158d73485d6cf92c75b38e7f26d00c3">VSIReadDir</a> (const char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read names in a directory.  <a href="#a6158d73485d6cf92c75b38e7f26d00c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a03c473cd78f2dffabf709245a928e6c7">VSIReadDirRecursive</a> (const char *pszPath)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read names in a directory recursively.  <a href="#a03c473cd78f2dffabf709245a928e6c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#aef0a5243bbc47cf9645a135d0c7d26df">VSIMkdir</a> (const char *pathname, long mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a directory.  <a href="#aef0a5243bbc47cf9645a135d0c7d26df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a763cceaa0966f37b71a0185c92bb3ad8">VSIRmdir</a> (const char *pathname)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a directory.  <a href="#a763cceaa0966f37b71a0185c92bb3ad8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a69dad1bd6f1af9935c1523db0c6c212f">VSIUnlink</a> (const char *pathname)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a file.  <a href="#a69dad1bd6f1af9935c1523db0c6c212f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a26cae93b5a32e11bef9ec7c118f8cca4">VSIRename</a> (const char *oldpath, const char *newpath)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rename a file.  <a href="#a26cae93b5a32e11bef9ec7c118f8cca4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a312ee85ec9884dc16feda2b81de1cc36"></a><!-- doxytag: member="cpl_vsi.h::VSIStrerror" ref="a312ee85ec9884dc16feda2b81de1cc36" args="(int)" -->
char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSIStrerror</b> (int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a66e2e6f093fd42f8a941b962d4c8a19e">VSIInstallMemFileHandler</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Install "memory" file system handler.  <a href="#a66e2e6f093fd42f8a941b962d4c8a19e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa8dab0deeeee583ec820a9847a6af4c"></a><!-- doxytag: member="cpl_vsi.h::VSIInstallLargeFileHandler" ref="afa8dab0deeeee583ec820a9847a6af4c" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSIInstallLargeFileHandler</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#abaee4232440e012b4b9920934fc571cc">VSIInstallSubFileHandler</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Install /vsisubfile/ virtual file handler.  <a href="#abaee4232440e012b4b9920934fc571cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a4f791960f2d86713d16e99e9c0c36258">VSIInstallCurlFileHandler</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Install /vsicurl/ HTTP/FTP file system handler (requires libcurl).  <a href="#a4f791960f2d86713d16e99e9c0c36258"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ab187e6713f07be9756c22c58b782642d">VSIInstallCurlStreamingFileHandler</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Install /vsicurl_streaming/ HTTP/FTP file system handler (requires libcurl).  <a href="#ab187e6713f07be9756c22c58b782642d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a3cde09f204df6f417653b7af4761178e">VSIInstallGZipFileHandler</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Install GZip file system handler.  <a href="#a3cde09f204df6f417653b7af4761178e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a884fac3cd6be2c09deb807e959d78b3a">VSIInstallZipFileHandler</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Install ZIP file system handler.  <a href="#a884fac3cd6be2c09deb807e959d78b3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a2c6b408477f59b40f0aec51d5980eb8e">VSIInstallStdinHandler</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Install /vsistdin/ file system handler.  <a href="#a2c6b408477f59b40f0aec51d5980eb8e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a61d2250ab2b22ca79b051a8479ee5383">VSIInstallStdoutHandler</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Install /vsistdout/ file system handler.  <a href="#a61d2250ab2b22ca79b051a8479ee5383"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ab79aed725b28eb22471a8b6733405843">VSIInstallSparseFileHandler</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Install /vsisparse/ virtual file handler.  <a href="#ab79aed725b28eb22471a8b6733405843"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ad6dd983338849e7da4eaa88f6458ab64">VSIInstallTarFileHandler</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Install /vsitar/ file system handler.  <a href="#ad6dd983338849e7da4eaa88f6458ab64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a77a8859e833ced8ef145fe1962e2a0"></a><!-- doxytag: member="cpl_vsi.h::VSICleanupFileManager" ref="a3a77a8859e833ced8ef145fe1962e2a0" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSICleanupFileManager</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VSILFILE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#af9c1b931449d423e7a80bacb75ff0717">VSIFileFromMemBuffer</a> (const char *pszFilename, GByte *pabyData, vsi_l_offset nDataLength, int bTakeOwnership)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create memory "file" from a buffer.  <a href="#af9c1b931449d423e7a80bacb75ff0717"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GByte *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#aeaf26bcc4a5314371f426bb2a5e6ce7a">VSIGetMemFileBuffer</a> (const char *pszFilename, vsi_l_offset *pnDataLength, int bUnlinkAndSeize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch buffer underlying memory file.  <a href="#aeaf26bcc4a5314371f426bb2a5e6ce7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac71125a8b8f3a275b6c615dc4747f68e"></a><!-- doxytag: member="cpl_vsi.h::VSITime" ref="ac71125a8b8f3a275b6c615dc4747f68e" args="(unsigned long *)" -->
unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSITime</b> (unsigned long *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae39ac018668664d43a43ad5f927d1c72"></a><!-- doxytag: member="cpl_vsi.h::VSICTime" ref="ae39ac018668664d43a43ad5f927d1c72" args="(unsigned long)" -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSICTime</b> (unsigned long)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb339c77fda30384c21a674003de8dc4"></a><!-- doxytag: member="cpl_vsi.h::VSIGMTime" ref="aeb339c77fda30384c21a674003de8dc4" args="(const time_t *pnTime, struct tm *poBrokenTime)" -->
struct tm *&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSIGMTime</b> (const time_t *pnTime, struct tm *poBrokenTime)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a337c0b5df848dc361a32f90b2e917cf2"></a><!-- doxytag: member="cpl_vsi.h::VSILocalTime" ref="a337c0b5df848dc361a32f90b2e917cf2" args="(const time_t *pnTime, struct tm *poBrokenTime)" -->
struct tm *&nbsp;</td><td class="memItemRight" valign="bottom"><b>VSILocalTime</b> (const time_t *pnTime, struct tm *poBrokenTime)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Standard C Covers. </p>
<p>The VSI functions are intended to be hookable aliases for Standard C I/O, memory allocation and other system functions. They are intended to allow virtualization of disk I/O so that non file data sources can be made to appear as files, and so that additional error trapping and reporting can be interested. The memory access API is aliased so that special application memory management services can be used.</p>
<p>Is is intended that each of these functions retains exactly the same calling pattern as the original Standard C functions they relate to. This means we don't have to provide custom documentation, and also means that the default implementation is very simple. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a82fe6612261c1948eee388e75b7d6db7"></a><!-- doxytag: member="cpl_vsi.h::VSIFCloseL" ref="a82fe6612261c1948eee388e75b7d6db7" args="(VSILFILE *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIFCloseL </td>
          <td>(</td>
          <td class="paramtype">VSILFILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close file. </p>
<p>This function closes the indicated file.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX fclose() function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fp</em>&nbsp;</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file.">VSIFOpenL()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ab72b69150d9dd7adb6e756196867a9b2"></a><!-- doxytag: member="cpl_vsi.h::VSIFEofL" ref="ab72b69150d9dd7adb6e756196867a9b2" args="(VSILFILE *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIFEofL </td>
          <td>(</td>
          <td class="paramtype">VSILFILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test for end of file. </p>
<p>Returns TRUE (non-zero) if an end-of-file condition occured during the previous read operation. The end-of-file flag is cleared by a successfull <a class="el" href="cpl__vsi_8h.html#aeac1c2bc2d4dac71e504f62be5c564f3" title="Seek to requested offset.">VSIFSeekL()</a> call.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX feof() call.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fp</em>&nbsp;</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file.">VSIFOpenL()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if at EOF else FALSE. </dd></dl>

</div>
</div>
<a class="anchor" id="a224b7e3c50275ae1924e89185df5494d"></a><!-- doxytag: member="cpl_vsi.h::VSIFFlushL" ref="a224b7e3c50275ae1924e89185df5494d" args="(VSILFILE *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIFFlushL </td>
          <td>(</td>
          <td class="paramtype">VSILFILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flush pending writes to disk. </p>
<p>For files in write or update mode and on filesystem types where it is applicable, all pending output on the file is flushed to the physical disk.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX fflush() call.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fp</em>&nbsp;</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file.">VSIFOpenL()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success or -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a41fd7388a7491b3430d0abe961dada82"></a><!-- doxytag: member="cpl_vsi.h::VSIFGetNativeFileDescriptorL" ref="a41fd7388a7491b3430d0abe961dada82" args="(VSILFILE *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* VSIFGetNativeFileDescriptorL </td>
          <td>(</td>
          <td class="paramtype">VSILFILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the "native" file descriptor for the virtual handle. </p>
<p>This will only return a non-NULL value for "real" files handled by the operating system (to be opposed to GDAL virtual file systems).</p>
<p>On POSIX systems, this will be a integer value ("fd") cast as a void*. On Windows systems, this will be the HANDLE.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fp</em>&nbsp;</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file.">VSIFOpenL()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the native file descriptor, or NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="af9c1b931449d423e7a80bacb75ff0717"></a><!-- doxytag: member="cpl_vsi.h::VSIFileFromMemBuffer" ref="af9c1b931449d423e7a80bacb75ff0717" args="(const char *pszFilename, GByte *pabyData, vsi_l_offset nDataLength, int bTakeOwnership)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VSILFILE* VSIFileFromMemBuffer </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GByte *&nbsp;</td>
          <td class="paramname"> <em>pabyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vsi_l_offset&nbsp;</td>
          <td class="paramname"> <em>nDataLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bTakeOwnership</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create memory "file" from a buffer. </p>
<p>A virtual memory file is created from the passed buffer with the indicated filename. Under normal conditions the filename would need to be absolute and within the /vsimem/ portion of the filesystem.</p>
<p>If bTakeOwnership is TRUE, then the memory file system handler will take ownership of the buffer, freeing it when the file is deleted. Otherwise it remains the responsibility of the caller, but should not be freed as long as it might be accessed as a file. In no circumstances does this function take a copy of the pabyData contents.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszFilename</em>&nbsp;</td><td>the filename to be created. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pabyData</em>&nbsp;</td><td>the data buffer for the file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nDataLength</em>&nbsp;</td><td>the length of buffer in bytes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bTakeOwnership</em>&nbsp;</td><td>TRUE to transfer "ownership" of buffer or FALSE.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>open file handle on created file (see <a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file.">VSIFOpenL()</a>). </dd></dl>

</div>
</div>
<a class="anchor" id="ae3cfa1605ce32e78fddb534bba7742f5"></a><!-- doxytag: member="cpl_vsi.h::VSIFOpenL" ref="ae3cfa1605ce32e78fddb534bba7742f5" args="(const char *, const char *) CPL_WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VSILFILE* VSIFOpenL </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszAccess</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open file. </p>
<p>This function opens a file with the desired access. Large files (larger than 2GB) should be supported. Binary access is always implied and the "b" does not need to be included in the pszAccess string.</p>
<p>Note that the "VSILFILE *" returned since GDAL 1.8.0 by this function is *NOT* a standard C library FILE *, and cannot be used with any functions other than the "VSI*L" family of functions. They aren't "real" FILE objects.</p>
<p>On windows it is possible to define the configuration option GDAL_FILE_IS_UTF8 to have pszFilename treated as being in the local encoding instead of UTF-8, retoring the pre-1.8.0 behavior of <a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file.">VSIFOpenL()</a>.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX fopen() function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszFilename</em>&nbsp;</td><td>the file to open. UTF-8 encoded. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszAccess</em>&nbsp;</td><td>access requested (ie. "r", "r+", "w".</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NULL on failure, or the file handle. </dd></dl>

</div>
</div>
<a class="anchor" id="ad19d593846fa567ada334b12a7bf8a3b"></a><!-- doxytag: member="cpl_vsi.h::VSIFPrintfL" ref="ad19d593846fa567ada334b12a7bf8a3b" args="(VSILFILE *, const char *,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIFPrintfL </td>
          <td>(</td>
          <td class="paramtype">VSILFILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Formatted write to file. </p>
<p>Provides fprintf() style formatted output to a VSI*L file. This formats an internal buffer which is written using <a class="el" href="cpl__vsi_8h.html#a2a382b55d461f4979f523e8c6e257ada" title="Write bytes to file.">VSIFWriteL()</a>.</p>
<p>Analog of the POSIX fprintf() call.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fp</em>&nbsp;</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file.">VSIFOpenL()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszFormat</em>&nbsp;</td><td>the printf style format string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of bytes written or -1 on an error. </dd></dl>

</div>
</div>
<a class="anchor" id="aaddb197f5fb0d431a565b89281d42d93"></a><!-- doxytag: member="cpl_vsi.h::VSIFReadL" ref="aaddb197f5fb0d431a565b89281d42d93" args="(void *, size_t, size_t, VSILFILE *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t VSIFReadL </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VSILFILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read bytes from file. </p>
<p>Reads nCount objects of nSize bytes from the indicated file at the current offset into the indicated buffer.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX fread() call.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pBuffer</em>&nbsp;</td><td>the buffer into which the data should be read (at least nCount * nSize bytes in size. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nSize</em>&nbsp;</td><td>size of objects to read in bytes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nCount</em>&nbsp;</td><td>number of objects to read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fp</em>&nbsp;</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file.">VSIFOpenL()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of objects successfully read. </dd></dl>

</div>
</div>
<a class="anchor" id="aaeb325d9dcb43c16a3fa1592ed7c1d2b"></a><!-- doxytag: member="cpl_vsi.h::VSIFReadMultiRangeL" ref="aaeb325d9dcb43c16a3fa1592ed7c1d2b" args="(int nRanges, void **ppData, const vsi_l_offset *panOffsets, const size_t *panSizes, VSILFILE *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIFReadMultiRangeL </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nRanges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>ppData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vsi_l_offset *&nbsp;</td>
          <td class="paramname"> <em>panOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&nbsp;</td>
          <td class="paramname"> <em>panSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VSILFILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read several ranges of bytes from file. </p>
<p>Reads nRanges objects of panSizes[i] bytes from the indicated file at the offset panOffsets[i] into the buffer ppData[i].</p>
<p>Ranges must be sorted in ascending start offset, and must not overlap each other.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory or /vsicurl/.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nRanges</em>&nbsp;</td><td>number of ranges to read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ppData</em>&nbsp;</td><td>array of nRanges buffer into which the data should be read (ppData[i] must be at list panSizes[i] bytes). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>panOffsets</em>&nbsp;</td><td>array of nRanges offsets at which the data should be read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>panSizes</em>&nbsp;</td><td>array of nRanges sizes of objects to read (in bytes). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fp</em>&nbsp;</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file.">VSIFOpenL()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 in case of success, -1 otherwise. </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.9.0 </dd></dl>

</div>
</div>
<a class="anchor" id="aeac1c2bc2d4dac71e504f62be5c564f3"></a><!-- doxytag: member="cpl_vsi.h::VSIFSeekL" ref="aeac1c2bc2d4dac71e504f62be5c564f3" args="(VSILFILE *, vsi_l_offset, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIFSeekL </td>
          <td>(</td>
          <td class="paramtype">VSILFILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vsi_l_offset&nbsp;</td>
          <td class="paramname"> <em>nOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nWhence</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Seek to requested offset. </p>
<p>Seek to the desired offset (nOffset) in the indicated file.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX fseek() call.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fp</em>&nbsp;</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file.">VSIFOpenL()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nOffset</em>&nbsp;</td><td>offset in bytes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nWhence</em>&nbsp;</td><td>one of SEEK_SET, SEEK_CUR or SEEK_END.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success or -1 one failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a25fe184bb565bbda49965102dbe0ca15"></a><!-- doxytag: member="cpl_vsi.h::VSIFTellL" ref="a25fe184bb565bbda49965102dbe0ca15" args="(VSILFILE *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vsi_l_offset VSIFTellL </td>
          <td>(</td>
          <td class="paramtype">VSILFILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tell current file offset. </p>
<p>Returns the current file read/write offset in bytes from the beginning of the file.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX ftell() call.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fp</em>&nbsp;</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file.">VSIFOpenL()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>file offset in bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="a3363cbf28c47b5dcadaf0812dd50e6b9"></a><!-- doxytag: member="cpl_vsi.h::VSIFTruncateL" ref="a3363cbf28c47b5dcadaf0812dd50e6b9" args="(VSILFILE *, vsi_l_offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIFTruncateL </td>
          <td>(</td>
          <td class="paramtype">VSILFILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vsi_l_offset&nbsp;</td>
          <td class="paramname"> <em>nNewSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Truncate/expand the file to the specified size. </p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX ftruncate() call.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fp</em>&nbsp;</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file.">VSIFOpenL()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nNewSize</em>&nbsp;</td><td>new size in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.9.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a2a382b55d461f4979f523e8c6e257ada"></a><!-- doxytag: member="cpl_vsi.h::VSIFWriteL" ref="a2a382b55d461f4979f523e8c6e257ada" args="(const void *, size_t, size_t, VSILFILE *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t VSIFWriteL </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VSILFILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write bytes to file. </p>
<p>Writess nCount objects of nSize bytes to the indicated file at the current offset into the indicated buffer.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX fwrite() call.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pBuffer</em>&nbsp;</td><td>the buffer from which the data should be written (at least nCount * nSize bytes in size. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nSize</em>&nbsp;</td><td>size of objects to read in bytes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nCount</em>&nbsp;</td><td>number of objects to read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fp</em>&nbsp;</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file.">VSIFOpenL()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of objects successfully written. </dd></dl>

</div>
</div>
<a class="anchor" id="aeaf26bcc4a5314371f426bb2a5e6ce7a"></a><!-- doxytag: member="cpl_vsi.h::VSIGetMemFileBuffer" ref="aeaf26bcc4a5314371f426bb2a5e6ce7a" args="(const char *pszFilename, vsi_l_offset *pnDataLength, int bUnlinkAndSeize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GByte* VSIGetMemFileBuffer </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vsi_l_offset *&nbsp;</td>
          <td class="paramname"> <em>pnDataLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bUnlinkAndSeize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch buffer underlying memory file. </p>
<p>This function returns a pointer to the memory buffer underlying a virtual "in memory" file. If bUnlinkAndSeize is TRUE the filesystem object will be deleted, and ownership of the buffer will pass to the caller otherwise the underlying file will remain in existance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszFilename</em>&nbsp;</td><td>the name of the file to grab the buffer of. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnDataLength</em>&nbsp;</td><td>(file) length returned in this variable. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bUnlinkAndSeize</em>&nbsp;</td><td>TRUE to remove the file, or FALSE to leave unaltered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to memory buffer or NULL on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a6c5ab5def482f0efc439162b2896b4ea"></a><!-- doxytag: member="cpl_vsi.h::VSIIngestFile" ref="a6c5ab5def482f0efc439162b2896b4ea" args="(VSILFILE *fp, const char *pszFilename, GByte **ppabyRet, vsi_l_offset *pnSize, GIntBig nMaxSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIIngestFile </td>
          <td>(</td>
          <td class="paramtype">VSILFILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GByte **&nbsp;</td>
          <td class="paramname"> <em>ppabyRet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vsi_l_offset *&nbsp;</td>
          <td class="paramname"> <em>pnSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GIntBig&nbsp;</td>
          <td class="paramname"> <em>nMaxSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ingest a file into memory. </p>
<p>Read the whole content of a file into a memory buffer.</p>
<p>Either fp or pszFilename can be NULL, but not both at the same time.</p>
<p>If fp is passed non-NULL, it is the responsibility of the caller to close it.</p>
<p>If non-NULL, the returned buffer is guaranteed to be NUL-terminated.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fp</em>&nbsp;</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file.">VSIFOpenL()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszFilename</em>&nbsp;</td><td>filename. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ppabyRet</em>&nbsp;</td><td>pointer to the target buffer. *ppabyRet must be freed with VSIFree() </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnSize</em>&nbsp;</td><td>pointer to variable to store the file size. May be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nMaxSize</em>&nbsp;</td><td>maximum size of file allowed. If no limit, set to a negative value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE in case of success.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a class="anchor" id="a4f791960f2d86713d16e99e9c0c36258"></a><!-- doxytag: member="cpl_vsi.h::VSIInstallCurlFileHandler" ref="a4f791960f2d86713d16e99e9c0c36258" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallCurlFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Install /vsicurl/ HTTP/FTP file system handler (requires libcurl). </p>
<p>A special file handler is installed that allows reading on-the-fly of files available through HTTP/FTP web protocols, without downloading the entire file.</p>
<p>Recognized filenames are of the form /vsicurl/http://path/to/remote/ressource or /vsicurl/ftp://path/to/remote/ressource where path/to/remote/ressource is the URL of a remote ressource.</p>
<p>Partial downloads (requires the HTTP server to support random reading) are done with a 16 KB granularity by default. If the driver detects sequential reading it will progressively increase the chunk size up to 2 MB to improve download performance.</p>
<p>The GDAL_HTTP_PROXY, GDAL_HTTP_PROXYUSERPWD and GDAL_PROXY_AUTH configuration options can be used to define a proxy server. The syntax to use is the one of Curl CURLOPT_PROXY, CURLOPT_PROXYUSERPWD and CURLOPT_PROXYAUTH options.</p>
<p>Starting with GDAL 1.10, the file can be cached in RAM by setting the configuration option VSI_CACHE to TRUE. The cache size defaults to 25 MB, but can be modified by setting the configuration option VSI_CACHE_SIZE (in bytes).</p>
<p><a class="el" href="cpl__vsi_8h.html#ac92fbd5e6fc143b026001b32c4c19ed1" title="Get filesystem object info.">VSIStatL()</a> will return the size in st_size member and file nature- file or directory - in st_mode member (the later only reliable with FTP resources for now).</p>
<p><a class="el" href="cpl__vsi_8h.html#a6158d73485d6cf92c75b38e7f26d00c3" title="Read names in a directory.">VSIReadDir()</a> should be able to parse the HTML directory listing returned by the most popular web servers, such as Apache or Microsoft IIS.</p>
<p>This special file handler can be combined with other virtual filesystems handlers, such as /vsizip. For example, /vsizip//vsicurl/path/to/remote/file.zip/path/inside/zip</p>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.8.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ab187e6713f07be9756c22c58b782642d"></a><!-- doxytag: member="cpl_vsi.h::VSIInstallCurlStreamingFileHandler" ref="ab187e6713f07be9756c22c58b782642d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallCurlStreamingFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Install /vsicurl_streaming/ HTTP/FTP file system handler (requires libcurl). </p>
<p>A special file handler is installed that allows on-the-fly reading of files streamed through HTTP/FTP web protocols (typically dynamically generated files), without downloading the entire file.</p>
<p>Although this file handler is able seek to random offsets in the file, this will not be efficient. If you need efficient random access and that the server supports range dowloading, you should use the /vsicurl/ file system handler instead.</p>
<p>Recognized filenames are of the form /vsicurl_streaming/http://path/to/remote/ressource or /vsicurl_streaming/ftp://path/to/remote/ressource where path/to/remote/ressource is the URL of a remote ressource.</p>
<p>The GDAL_HTTP_PROXY, GDAL_HTTP_PROXYUSERPWD and GDAL_PROXY_AUTH configuration options can be used to define a proxy server. The syntax to use is the one of Curl CURLOPT_PROXY, CURLOPT_PROXYUSERPWD and CURLOPT_PROXYAUTH options.</p>
<p>The file can be cached in RAM by setting the configuration option VSI_CACHE to TRUE. The cache size defaults to 25 MB, but can be modified by setting the configuration option VSI_CACHE_SIZE (in bytes).</p>
<p><a class="el" href="cpl__vsi_8h.html#ac92fbd5e6fc143b026001b32c4c19ed1" title="Get filesystem object info.">VSIStatL()</a> will return the size in st_size member and file nature- file or directory - in st_mode member (the later only reliable with FTP resources for now).</p>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.10 </dd></dl>

</div>
</div>
<a class="anchor" id="a3cde09f204df6f417653b7af4761178e"></a><!-- doxytag: member="cpl_vsi.h::VSIInstallGZipFileHandler" ref="a3cde09f204df6f417653b7af4761178e" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallGZipFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Install GZip file system handler. </p>
<p>A special file handler is installed that allows reading on-the-fly and writing in GZip (.gz) files.</p>
<p>All portions of the file system underneath the base path "/vsigzip/" will be handled by this driver.</p>
<p>Additional documentation is to be found at <a href="http://trac.osgeo.org/gdal/wiki/UserDocs/ReadInZip">http://trac.osgeo.org/gdal/wiki/UserDocs/ReadInZip</a></p>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.6.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a66e2e6f093fd42f8a941b962d4c8a19e"></a><!-- doxytag: member="cpl_vsi.h::VSIInstallMemFileHandler" ref="a66e2e6f093fd42f8a941b962d4c8a19e" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallMemFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Install "memory" file system handler. </p>
<p>A special file handler is installed that allows block of memory to be treated as files. All portions of the file system underneath the base path "/vsimem/" will be handled by this driver.</p>
<p>Normal VSI*L functions can be used freely to create and destroy memory arrays treating them as if they were real file system objects. Some additional methods exist to efficient create memory file system objects without duplicating original copies of the data or to "steal" the block of memory associated with a memory file.</p>
<p>At this time the memory handler does not properly handle directory semantics for the memory portion of the filesystem. The <a class="el" href="cpl__vsi_8h.html#a6158d73485d6cf92c75b38e7f26d00c3" title="Read names in a directory.">VSIReadDir()</a> function is not supported though this will be corrected in the future.</p>
<p>Calling this function repeatedly should do no harm, though it is not necessary. It is already called the first time a virtualizable file access function (ie. <a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file.">VSIFOpenL()</a>, VSIMkDir(), etc) is called.</p>
<p>This code example demonstrates using GDAL to translate from one memory buffer to another.</p>
<div class="fragment"><pre class="fragment"> GByte *ConvertBufferFormat( GByte *pabyInData, vsi_l_offset nInDataLength, 
                             vsi_l_offset *pnOutDataLength )
 {
     <span class="comment">// create memory file system object from buffer.</span>
     <a class="code" href="cpl__vsi_8h.html#a82fe6612261c1948eee388e75b7d6db7" title="Close file.">VSIFCloseL</a>( <a class="code" href="cpl__vsi_8h.html#af9c1b931449d423e7a80bacb75ff0717" title="Create memory &amp;quot;file&amp;quot; from a buffer.">VSIFileFromMemBuffer</a>( <span class="stringliteral">&quot;/vsimem/work.dat&quot;</span>, pabyInData,
                                       nInDataLength, FALSE ) );

     <span class="comment">// Open memory buffer for read.</span>
     <a class="code" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d" title="Opaque type used for the C bindings of the C++ GDALDataset class.">GDALDatasetH</a> hDS = <a class="code" href="gdal_8h.html#a6836f0f810396c5e45622c8ef94624d4" title="Open a raster file as a GDALDataset.">GDALOpen</a>( <span class="stringliteral">&quot;/vsimem/work.dat&quot;</span>, <a class="code" href="gdal_8h.html#a045e3967c208993f70257bfd40c9f1d7a5a021a550b9d5640307d3c0e7e35b732">GA_ReadOnly</a> );
 
     <span class="comment">// Get output format driver. </span>
     <a class="code" href="gdal_8h.html#adfd09c07260442427a225e2a536ead72" title="Opaque type used for the C bindings of the C++ GDALDriver class.">GDALDriverH</a> hDriver = <a class="code" href="gdal_8h.html#ae8ae868eef1e4773283d137b0a1adfc4" title="Fetch a driver based on the short name.">GDALGetDriverByName</a>( <span class="stringliteral">&quot;GTiff&quot;</span> );
     <a class="code" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d" title="Opaque type used for the C bindings of the C++ GDALDataset class.">GDALDatasetH</a> hOutDS;

     hOutDS = <a class="code" href="gdal_8h.html#a249cb5d462af0784d44754b3668059be" title="Create a copy of a dataset.">GDALCreateCopy</a>( hDriver, <span class="stringliteral">&quot;/vsimem/out.tif&quot;</span>, hDS, TRUE, NULL, 
                              NULL, NULL );
 
     <span class="comment">// close source file, and &quot;unlink&quot; it.  </span>
     <a class="code" href="gdal_8h.html#a0984222d45a72028fcbbf1f44831ffbc" title="Close GDAL dataset.">GDALClose</a>( hDS );
     <a class="code" href="cpl__vsi_8h.html#a69dad1bd6f1af9935c1523db0c6c212f" title="Delete a file.">VSIUnlink</a>( <span class="stringliteral">&quot;/vsimem/work.dat&quot;</span> );

     <span class="comment">// seize the buffer associated with the output file.</span>

     <span class="keywordflow">return</span> <a class="code" href="cpl__vsi_8h.html#aeaf26bcc4a5314371f426bb2a5e6ce7a" title="Fetch buffer underlying memory file.">VSIGetMemFileBuffer</a>( <span class="stringliteral">&quot;/vsimem/out.tif&quot;</span>, pnOutDataLength, TRUE );
 }
</pre></div> 
</div>
</div>
<a class="anchor" id="ab79aed725b28eb22471a8b6733405843"></a><!-- doxytag: member="cpl_vsi.h::VSIInstallSparseFileHandler" ref="ab79aed725b28eb22471a8b6733405843" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallSparseFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Install /vsisparse/ virtual file handler. </p>
<p>The sparse virtual file handler allows a virtual file to be composed from chunks of data in other files, potentially with large spaces in the virtual file set to a constant value. This can make it possible to test some sorts of operations on what seems to be a large file with image data set to a constant value. It is also helpful when wanting to add test files to the test suite that are too large, but for which most of the data can be ignored. It could, in theory, also be used to treat several files on different file systems as one large virtual file.</p>
<p>The file referenced by /vsisparse/ should be an XML control file formatted something like:</p>
<div class="fragment"><pre class="fragment">
&lt;VSISparseFile&gt;
  &lt;Length&gt;87629264&lt;/Length&gt;
  &lt;SubfileRegion&gt;  Stuff at start of file.
    &lt;Filename relative="1"&gt;251_head.dat&lt;/Filename&gt;
    &lt;DestinationOffset&gt;0&lt;/DestinationOffset&gt;
    &lt;SourceOffset&gt;0&lt;/SourceOffset&gt;
    &lt;RegionLength&gt;2768&lt;/RegionLength&gt;
  &lt;/SubfileRegion&gt;

  &lt;SubfileRegion&gt;  RasterDMS node.
    &lt;Filename relative="1"&gt;251_rasterdms.dat&lt;/Filename&gt;
    &lt;DestinationOffset&gt;87313104&lt;/DestinationOffset&gt;
    &lt;SourceOffset&gt;0&lt;/SourceOffset&gt;
    &lt;RegionLength&gt;160&lt;/RegionLength&gt;
  &lt;/SubfileRegion&gt;

  &lt;SubfileRegion&gt;  Stuff at end of file.
    &lt;Filename relative="1"&gt;251_tail.dat&lt;/Filename&gt;
    &lt;DestinationOffset&gt;87611924&lt;/DestinationOffset&gt;
    &lt;SourceOffset&gt;0&lt;/SourceOffset&gt;
    &lt;RegionLength&gt;17340&lt;/RegionLength&gt;
  &lt;/SubfileRegion&gt;

  &lt;ConstantRegion&gt;  Default for the rest of the file.
    &lt;DestinationOffset&gt;0&lt;/DestinationOffset&gt;
    &lt;RegionLength&gt;87629264&lt;/RegionLength&gt;
    &lt;Value&gt;0&lt;/Value&gt;
  &lt;/ConstantRegion&gt;
&lt;/VSISparseFile&gt;
</pre></div><p>Hopefully the values and semantics are fairly obvious.</p>
<p>This driver is installed by default. </p>

</div>
</div>
<a class="anchor" id="a2c6b408477f59b40f0aec51d5980eb8e"></a><!-- doxytag: member="cpl_vsi.h::VSIInstallStdinHandler" ref="a2c6b408477f59b40f0aec51d5980eb8e" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallStdinHandler </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Install /vsistdin/ file system handler. </p>
<p>A special file handler is installed that allows reading from the standard input steam.</p>
<p>The file operations available are of course limited to Read() and forward Seek() (full seek in the first MB of a file).</p>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.8.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a61d2250ab2b22ca79b051a8479ee5383"></a><!-- doxytag: member="cpl_vsi.h::VSIInstallStdoutHandler" ref="a61d2250ab2b22ca79b051a8479ee5383" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallStdoutHandler </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Install /vsistdout/ file system handler. </p>
<p>A special file handler is installed that allows writing to the standard output stream.</p>
<p>The file operations available are of course limited to Write().</p>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.8.0 </dd></dl>

</div>
</div>
<a class="anchor" id="abaee4232440e012b4b9920934fc571cc"></a><!-- doxytag: member="cpl_vsi.h::VSIInstallSubFileHandler" ref="abaee4232440e012b4b9920934fc571cc" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallSubFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Install /vsisubfile/ virtual file handler. </p>
<p>This virtual file system handler allows access to subregions of files, treating them as a file on their own to the virtual file system functions (<a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file.">VSIFOpenL()</a>, etc).</p>
<p>A special form of the filename is used to indicate a subportion of another <a href="file:">file:</a></p>
<p>/vsisubfile/&lt;offset&gt;[_&lt;size&gt;],&lt;filename&gt;</p>
<p>The size parameter is optional. Without it the remainder of the file from the start offset as treated as part of the subfile. Otherwise only &lt;size&gt; bytes from &lt;offset&gt; are treated as part of the subfile. The &lt;filename&gt; portion may be a relative or absolute path using normal rules. The &lt;offset&gt; and &lt;size&gt; values are in bytes.</p>
<p>eg. /vsisubfile/1000_3000,/data/abc.ntf /vsisubfile/5000,../xyz/raw.dat</p>
<p>Unlike the /vsimem/ or conventional file system handlers, there is no meaningful support for filesystem operations for creating new files, traversing directories, and deleting files within the /vsisubfile/ area. Only the <a class="el" href="cpl__vsi_8h.html#ac92fbd5e6fc143b026001b32c4c19ed1" title="Get filesystem object info.">VSIStatL()</a>, <a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file.">VSIFOpenL()</a> and operations based on the file handle returned by <a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file.">VSIFOpenL()</a> operate properly. </p>

</div>
</div>
<a class="anchor" id="ad6dd983338849e7da4eaa88f6458ab64"></a><!-- doxytag: member="cpl_vsi.h::VSIInstallTarFileHandler" ref="ad6dd983338849e7da4eaa88f6458ab64" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallTarFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Install /vsitar/ file system handler. </p>
<p>A special file handler is installed that allows reading on-the-fly in TAR (regular .tar, or compressed .tar.gz/.tgz) archives.</p>
<p>All portions of the file system underneath the base path "/vsitar/" will be handled by this driver.</p>
<p>The syntax to open a file inside a zip file is /vsitar/path/to/the/file.tar/path/inside/the/tar/file were path/to/the/file.tar is relative or absolute and path/inside/the/tar/file is the relative path to the file inside the archive.</p>
<p>If the path is absolute, it should begin with a / on a Unix-like OS (or C:\ on Windows), so the line looks like /vsitar//home/gdal/... For example gdalinfo /vsitar/myarchive.tar/subdir1/file1.tif</p>
<p>Syntaxic sugar : if the tar archive contains only one file located at its root, just mentionning "/vsitar/path/to/the/file.tar" will work</p>
<p><a class="el" href="cpl__vsi_8h.html#ac92fbd5e6fc143b026001b32c4c19ed1" title="Get filesystem object info.">VSIStatL()</a> will return the uncompressed size in st_size member and file nature- file or directory - in st_mode member.</p>
<p>Directory listing is available through <a class="el" href="cpl__vsi_8h.html#a6158d73485d6cf92c75b38e7f26d00c3" title="Read names in a directory.">VSIReadDir()</a>.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.8.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a884fac3cd6be2c09deb807e959d78b3a"></a><!-- doxytag: member="cpl_vsi.h::VSIInstallZipFileHandler" ref="a884fac3cd6be2c09deb807e959d78b3a" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallZipFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Install ZIP file system handler. </p>
<p>A special file handler is installed that allows reading on-the-fly in ZIP (.zip) archives.</p>
<p>All portions of the file system underneath the base path "/vsizip/" will be handled by this driver.</p>
<p>The syntax to open a file inside a zip file is /vsizip/path/to/the/file.zip/path/inside/the/zip/file were path/to/the/file.zip is relative or absolute and path/inside/the/zip/file is the relative path to the file inside the archive.</p>
<p>If the path is absolute, it should begin with a / on a Unix-like OS (or C:\ on Windows), so the line looks like /vsizip//home/gdal/... For example gdalinfo /vsizip/myarchive.zip/subdir1/file1.tif</p>
<p>Syntaxic sugar : if the .zip file contains only one file located at its root, just mentionning "/vsizip/path/to/the/file.zip" will work</p>
<p><a class="el" href="cpl__vsi_8h.html#ac92fbd5e6fc143b026001b32c4c19ed1" title="Get filesystem object info.">VSIStatL()</a> will return the uncompressed size in st_size member and file nature- file or directory - in st_mode member.</p>
<p>Directory listing is available through <a class="el" href="cpl__vsi_8h.html#a6158d73485d6cf92c75b38e7f26d00c3" title="Read names in a directory.">VSIReadDir()</a>.</p>
<p>Since GDAL 1.8.0, write capabilities are available. They allow creating a new zip file and adding new files to an already existing (or just created) zip file. Read and write operations cannot be interleaved : the new zip must be closed before being re-opened for read.</p>
<p>Additional documentation is to be found at <a href="http://trac.osgeo.org/gdal/wiki/UserDocs/ReadInZip">http://trac.osgeo.org/gdal/wiki/UserDocs/ReadInZip</a></p>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.6.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a36737f0cb2949ba2f7bbf23cc6592a04"></a><!-- doxytag: member="cpl_vsi.h::VSIIsCaseSensitiveFS" ref="a36737f0cb2949ba2f7bbf23cc6592a04" args="(const char *pszFilename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIIsCaseSensitiveFS </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszFilename</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns if the filenames of the filesystem are case sensitive. </p>
<p>This method retrieves to which filesystem belongs the passed filename and return TRUE if the filenames of that filesystem are case sensitive.</p>
<p>Currently, this will return FALSE only for Windows real filenames. Other VSI virtual filesystems are case sensitive.</p>
<p>This methods avoid ugly ifndef WIN32 / endif code, that is wrong when dealing with virtual filenames.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszFilename</em>&nbsp;</td><td>the path of the filesystem object to be tested. UTF-8 encoded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the filenames of the filesystem are case sensitive.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.8.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a2286902bc6bf22d866e72df2e474d68c"></a><!-- doxytag: member="cpl_vsi.h::VSIMalloc2" ref="a2286902bc6bf22d866e72df2e474d68c" args="(size_t nSize1, size_t nSize2) CPL_WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* VSIMalloc2 </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nSize1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nSize2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>VSIMalloc2 allocates (nSize1 * nSize2) bytes. </p>
<p>In case of overflow of the multiplication, or if memory allocation fails, a NULL pointer is returned and a CE_Failure error is raised with <a class="el" href="cpl__error_8h.html#aad2b98dd58e4de706a245faddac90403" title="Report an error.">CPLError()</a>. If nSize1 == 0 || nSize2 == 0, a NULL pointer will also be returned. CPLFree() or VSIFree() can be used to free memory allocated by this function. </p>

</div>
</div>
<a class="anchor" id="a5114ce8d68c4f351309805314f3b5063"></a><!-- doxytag: member="cpl_vsi.h::VSIMalloc3" ref="a5114ce8d68c4f351309805314f3b5063" args="(size_t nSize1, size_t nSize2, size_t nSize3) CPL_WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* VSIMalloc3 </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nSize1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nSize2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nSize3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>VSIMalloc3 allocates (nSize1 * nSize2 * nSize3) bytes. </p>
<p>In case of overflow of the multiplication, or if memory allocation fails, a NULL pointer is returned and a CE_Failure error is raised with <a class="el" href="cpl__error_8h.html#aad2b98dd58e4de706a245faddac90403" title="Report an error.">CPLError()</a>. If nSize1 == 0 || nSize2 == 0 || nSize3 == 0, a NULL pointer will also be returned. CPLFree() or VSIFree() can be used to free memory allocated by this function. </p>

</div>
</div>
<a class="anchor" id="aef0a5243bbc47cf9645a135d0c7d26df"></a><!-- doxytag: member="cpl_vsi.h::VSIMkdir" ref="aef0a5243bbc47cf9645a135d0c7d26df" args="(const char *pathname, long mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIMkdir </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszPathname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a directory. </p>
<p>Create a new directory with the indicated mode. The mode is ignored on some platforms. A reasonable default mode value would be 0666. This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX mkdir() function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszPathname</em>&nbsp;</td><td>the path to the directory to create. UTF-8 encoded. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>the permissions mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success or -1 on an error. </dd></dl>

</div>
</div>
<a class="anchor" id="a6158d73485d6cf92c75b38e7f26d00c3"></a><!-- doxytag: member="cpl_vsi.h::VSIReadDir" ref="a6158d73485d6cf92c75b38e7f26d00c3" args="(const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char** VSIReadDir </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszPath</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read names in a directory. </p>
<p>This function abstracts access to directory contains. It returns a list of strings containing the names of files, and directories in this directory. The resulting string list becomes the responsibility of the application and should be freed with <a class="el" href="cpl__string_8h.html#a5a39b9c5896a273cc6f06c1d5be93238" title="Free string list.">CSLDestroy()</a> when no longer needed.</p>
<p>Note that no error is issued via <a class="el" href="cpl__error_8h.html#aad2b98dd58e4de706a245faddac90403" title="Report an error.">CPLError()</a> if the directory path is invalid, though NULL is returned.</p>
<p>This function used to be known as CPLReadDir(), but the old name is now deprecated.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszPath</em>&nbsp;</td><td>the relative, or absolute path of a directory to read. UTF-8 encoded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The list of entries in the directory, or NULL if the directory doesn't exist. Filenames are returned in UTF-8 encoding. </dd></dl>

</div>
</div>
<a class="anchor" id="a03c473cd78f2dffabf709245a928e6c7"></a><!-- doxytag: member="cpl_vsi.h::VSIReadDirRecursive" ref="a03c473cd78f2dffabf709245a928e6c7" args="(const char *pszPath)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char** VSIReadDirRecursive </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszPathIn</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read names in a directory recursively. </p>
<p>This function abstracts access to directory contents and subdirectories. It returns a list of strings containing the names of files and directories in this directory and all subdirectories. The resulting string list becomes the responsibility of the application and should be freed with <a class="el" href="cpl__string_8h.html#a5a39b9c5896a273cc6f06c1d5be93238" title="Free string list.">CSLDestroy()</a> when no longer needed.</p>
<p>Note that no error is issued via <a class="el" href="cpl__error_8h.html#aad2b98dd58e4de706a245faddac90403" title="Report an error.">CPLError()</a> if the directory path is invalid, though NULL is returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszPathIn</em>&nbsp;</td><td>the relative, or absolute path of a directory to read. UTF-8 encoded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The list of entries in the directory and subdirectories or NULL if the directory doesn't exist. Filenames are returned in UTF-8 encoding. </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.10.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a26cae93b5a32e11bef9ec7c118f8cca4"></a><!-- doxytag: member="cpl_vsi.h::VSIRename" ref="a26cae93b5a32e11bef9ec7c118f8cca4" args="(const char *oldpath, const char *newpath)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIRename </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>oldpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>newpath</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rename a file. </p>
<p>Renames a file object in the file system. It should be possible to rename a file onto a new filesystem, but it is safest if this function is only used to rename files that remain in the same directory.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX rename() function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>oldpath</em>&nbsp;</td><td>the name of the file to be renamed. UTF-8 encoded. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newpath</em>&nbsp;</td><td>the name the file should be given. UTF-8 encoded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success or -1 on an error. </dd></dl>

</div>
</div>
<a class="anchor" id="a763cceaa0966f37b71a0185c92bb3ad8"></a><!-- doxytag: member="cpl_vsi.h::VSIRmdir" ref="a763cceaa0966f37b71a0185c92bb3ad8" args="(const char *pathname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIRmdir </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszDirname</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete a directory. </p>
<p>Deletes a directory object from the file system. On some systems the directory must be empty before it can be deleted.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX rmdir() function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszDirname</em>&nbsp;</td><td>the path of the directory to be deleted. UTF-8 encoded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success or -1 on an error. </dd></dl>

</div>
</div>
<a class="anchor" id="ad1a691db1ba2f43add25a5c0d6498da6"></a><!-- doxytag: member="cpl_vsi.h::VSIStatExL" ref="ad1a691db1ba2f43add25a5c0d6498da6" args="(const char *pszFilename, VSIStatBufL *psStatBuf, int nFlags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIStatExL </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VSIStatBufL *&nbsp;</td>
          <td class="paramname"> <em>psStatBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nFlags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get filesystem object info. </p>
<p>Fetches status information about a filesystem object (file, directory, etc). The returned information is placed in the VSIStatBufL structure. For portability only the st_size (size in bytes), and st_mode (file type). This method is similar to VSIStat(), but will work on large files on systems where this requires special calls.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX stat() function, with an extra parameter to specify which information is needed, which offers a potential for speed optimizations on specialized and potentially slow virtual filesystem objects (/vsigzip/, /vsicurl/)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszFilename</em>&nbsp;</td><td>the path of the filesystem object to be queried. UTF-8 encoded. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>psStatBuf</em>&nbsp;</td><td>the structure to load with information. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nFlags</em>&nbsp;</td><td>0 to get all information, or VSI_STAT_EXISTS_FLAG, VSI_STAT_NATURE_FLAG or VSI_STAT_SIZE_FLAG, or a combination of those to get partial info.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success or -1 on an error.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.8.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ac92fbd5e6fc143b026001b32c4c19ed1"></a><!-- doxytag: member="cpl_vsi.h::VSIStatL" ref="ac92fbd5e6fc143b026001b32c4c19ed1" args="(const char *, VSIStatBufL *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIStatL </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VSIStatBufL *&nbsp;</td>
          <td class="paramname"> <em>psStatBuf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get filesystem object info. </p>
<p>Fetches status information about a filesystem object (file, directory, etc). The returned information is placed in the VSIStatBufL structure. For portability only the st_size (size in bytes), and st_mode (file type). This method is similar to VSIStat(), but will work on large files on systems where this requires special calls.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX stat() function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszFilename</em>&nbsp;</td><td>the path of the filesystem object to be queried. UTF-8 encoded. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>psStatBuf</em>&nbsp;</td><td>the structure to load with information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success or -1 on an error. </dd></dl>

</div>
</div>
<a class="anchor" id="a69dad1bd6f1af9935c1523db0c6c212f"></a><!-- doxytag: member="cpl_vsi.h::VSIUnlink" ref="a69dad1bd6f1af9935c1523db0c6c212f" args="(const char *pathname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIUnlink </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszFilename</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete a file. </p>
<p>Deletes a file object from the file system.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX unlink() function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszFilename</em>&nbsp;</td><td>the path of the file to be deleted. UTF-8 encoded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success or -1 on an error. </dd></dl>

</div>
</div>
</div>
<hr>

Generated for GDAL by 
<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.7.1.
</body>
</html>

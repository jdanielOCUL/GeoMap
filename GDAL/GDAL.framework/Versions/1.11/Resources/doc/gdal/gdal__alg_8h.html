<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>GDAL: gdal_alg.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>gdal_alg.h File Reference</h1>  </div>
</div>
<div class="contents">

<p>Public (C callable) GDAL algorithm entry points, and definitions.  
<a href="#_details">More...</a></p>

<p><a href="gdal__alg_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGDALTransformerInfo.html">GDALTransformerInfo</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOGRContourWriterInfo.html">OGRContourWriterInfo</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGDALGridInverseDistanceToAPowerOptions.html">GDALGridInverseDistanceToAPowerOptions</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inverse distance to a power method control options.  <a href="structGDALGridInverseDistanceToAPowerOptions.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGDALGridMovingAverageOptions.html">GDALGridMovingAverageOptions</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moving average method control options.  <a href="structGDALGridMovingAverageOptions.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGDALGridNearestNeighborOptions.html">GDALGridNearestNeighborOptions</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Nearest neighbor method control options.  <a href="structGDALGridNearestNeighborOptions.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGDALGridDataMetricsOptions.html">GDALGridDataMetricsOptions</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data metrics method control options.  <a href="structGDALGridDataMetricsOptions.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a7df61123fec15deb3da3acabce19e647">GDALTransformerFunc</a> )(void *pTransformerArg, int bDstToSrc, int nPointCount, double *x, double *y, double *z, int *panSuccess)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0004e8e7719e426e1e0ddf3922d76d4f"></a><!-- doxytag: member="gdal_alg.h::GDALContourWriter" ref="a0004e8e7719e426e1e0ddf3922d76d4f" args=")(double dfLevel, int nPoints, double *padfX, double *padfY, void *)" -->
typedef CPLErr(*&nbsp;</td><td class="memItemRight" valign="bottom"><b>GDALContourWriter</b> )(double dfLevel, int nPoints, double *padfX, double *padfY, void *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac929ac526110faa3f666d18f7a680958"></a><!-- doxytag: member="gdal_alg.h::GDALContourGeneratorH" ref="ac929ac526110faa3f666d18f7a680958" args="" -->
typedef void *&nbsp;</td><td class="memItemRight" valign="bottom"><b>GDALContourGeneratorH</b></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a590d1a2d0bac1d34b95034c1f616de21">GDALGridAlgorithm</a> { <br/>
&nbsp;&nbsp;<a class="el" href="gdal__alg_8h.html#a590d1a2d0bac1d34b95034c1f616de21a5955211b72d8b07518815d544e5fa192">GGA_InverseDistanceToAPower</a> =  1, 
<a class="el" href="gdal__alg_8h.html#a590d1a2d0bac1d34b95034c1f616de21aaafac5453ea6a64e9c84c5143cfbdcaf">GGA_MovingAverage</a> =  2, 
<a class="el" href="gdal__alg_8h.html#a590d1a2d0bac1d34b95034c1f616de21a70c30cb508518172fbce051a7927eb68">GGA_NearestNeighbor</a> =  3, 
<a class="el" href="gdal__alg_8h.html#a590d1a2d0bac1d34b95034c1f616de21a114443c69d10fafd0e4a6195cb178e75">GGA_MetricMinimum</a> =  4, 
<br/>
&nbsp;&nbsp;<a class="el" href="gdal__alg_8h.html#a590d1a2d0bac1d34b95034c1f616de21a62e4fcf09890e32a287364ca165f78e2">GGA_MetricMaximum</a> =  5, 
<a class="el" href="gdal__alg_8h.html#a590d1a2d0bac1d34b95034c1f616de21aed976fb5778362e9c51e5859d19ac917">GGA_MetricRange</a> =  6, 
<a class="el" href="gdal__alg_8h.html#a590d1a2d0bac1d34b95034c1f616de21ac41203ffb292f6fadf155a5d3ff80219">GGA_MetricCount</a> =  7, 
<a class="el" href="gdal__alg_8h.html#a590d1a2d0bac1d34b95034c1f616de21a90cfa34b606733fcbc4c7b15e36fefcf">GGA_MetricAverageDistance</a> =  8, 
<br/>
&nbsp;&nbsp;<a class="el" href="gdal__alg_8h.html#a590d1a2d0bac1d34b95034c1f616de21a5c0dc83a00305d4a1beda88406aefbb6">GGA_MetricAverageDistancePts</a> =  9
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Gridding Algorithms. </p>
 <a href="gdal__alg_8h.html#a590d1a2d0bac1d34b95034c1f616de21">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a61e48f88c3b4b3cf7957c61dc7bd1ead">GDALComputeMedianCutPCT</a> (<a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hRed, <a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hGreen, <a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hBlue, int(*pfnIncludePixel)(int, int, void *), int nColors, <a class="el" href="gdal_8h.html#af1baae80dd0ec873ad7ad5b28dda44f3">GDALColorTableH</a> hColorTable, GDALProgressFunc pfnProgress, void *pProgressArg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute optimal PCT for RGB image.  <a href="#a61e48f88c3b4b3cf7957c61dc7bd1ead"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a284dbcc27295b7e678b1f7d4fa1506cb">GDALDitherRGB2PCT</a> (<a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hRed, <a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hGreen, <a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hBlue, <a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hTarget, <a class="el" href="gdal_8h.html#af1baae80dd0ec873ad7ad5b28dda44f3">GDALColorTableH</a> hColorTable, GDALProgressFunc pfnProgress, void *pProgressArg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">24bit to 8bit conversion with dithering.  <a href="#a284dbcc27295b7e678b1f7d4fa1506cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#abe2846ac3a350c24f07dc9ceac8f4d14">GDALChecksumImage</a> (<a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hBand, int nXOff, int nYOff, int nXSize, int nYSize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute checksum for image region.  <a href="#abe2846ac3a350c24f07dc9ceac8f4d14"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPLErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a851815400a579aae9de01199b416fa42">GDALComputeProximity</a> (<a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hSrcBand, <a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hProximityBand, char **papszOptions, GDALProgressFunc pfnProgress, void *pProgressArg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the proximity of all pixels in the image to a set of pixels in the source image.  <a href="#a851815400a579aae9de01199b416fa42"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPLErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a0a079afef61968f224b159d48423d1c6">GDALFillNodata</a> (<a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hTargetBand, <a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hMaskBand, double dfMaxSearchDist, int bDeprecatedOption, int nSmoothingIterations, char **papszOptions, GDALProgressFunc pfnProgress, void *pProgressArg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill selected raster regions by interpolation from the edges.  <a href="#a0a079afef61968f224b159d48423d1c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPLErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a3f522a9035d3512b5d414fb4752671b1">GDALPolygonize</a> (<a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hSrcBand, <a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hMaskBand, OGRLayerH hOutLayer, int iPixValField, char **papszOptions, GDALProgressFunc pfnProgress, void *pProgressArg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create polygon coverage from raster data.  <a href="#a3f522a9035d3512b5d414fb4752671b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPLErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a7a789015334d677afcbef67e5a6b4a7c">GDALFPolygonize</a> (<a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hSrcBand, <a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hMaskBand, OGRLayerH hOutLayer, int iPixValField, char **papszOptions, GDALProgressFunc pfnProgress, void *pProgressArg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create polygon coverage from raster data.  <a href="#a7a789015334d677afcbef67e5a6b4a7c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPLErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a33309c0a316b223bd33ae5753cc7f616">GDALSieveFilter</a> (<a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hSrcBand, <a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hMaskBand, <a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hDstBand, int nSizeThreshold, int nConnectedness, char **papszOptions, GDALProgressFunc pfnProgress, void *pProgressArg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes small raster polygons.  <a href="#a33309c0a316b223bd33ae5753cc7f616"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61ba1efbda19c458fa769d97e592c113"></a><!-- doxytag: member="gdal_alg.h::GDALDestroyTransformer" ref="a61ba1efbda19c458fa769d97e592c113" args="(void *pTransformerArg)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>GDALDestroyTransformer</b> (void *pTransformerArg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84cf4936a69530ca5fc220df97ae2adf"></a><!-- doxytag: member="gdal_alg.h::GDALUseTransformer" ref="a84cf4936a69530ca5fc220df97ae2adf" args="(void *pTranformerArg, int bDstToSrc, int nPointCount, double *x, double *y, double *z, int *panSuccess)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>GDALUseTransformer</b> (void *pTranformerArg, int bDstToSrc, int nPointCount, double *x, double *y, double *z, int *panSuccess)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a7671696d085085a0bfba3c3df9ffcc0a">GDALCreateGenImgProjTransformer</a> (<a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a> hSrcDS, const char *pszSrcWKT, <a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a> hDstDS, const char *pszDstWKT, int bGCPUseOK, double dfGCPErrorThreshold, int nOrder)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create image to image transformer.  <a href="#a7671696d085085a0bfba3c3df9ffcc0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a94cd172f78dbc41d6f407d662914f2e3">GDALCreateGenImgProjTransformer2</a> (<a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a> hSrcDS, <a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a> hDstDS, char **papszOptions)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create image to image transformer.  <a href="#a94cd172f78dbc41d6f407d662914f2e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a05f5de51947234a0481088bed2d7ce53">GDALCreateGenImgProjTransformer3</a> (const char *pszSrcWKT, const double *padfSrcGeoTransform, const char *pszDstWKT, const double *padfDstGeoTransform)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create image to image transformer.  <a href="#a05f5de51947234a0481088bed2d7ce53"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a18e841864cf6d93596626981d26c3000">GDALSetGenImgProjTransformerDstGeoTransform</a> (void *, const double *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set GenImgProj output geotransform.  <a href="#a18e841864cf6d93596626981d26c3000"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a5fb383c4e5197e8e37ae1265cca8124d">GDALDestroyGenImgProjTransformer</a> (void *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GenImgProjTransformer deallocator.  <a href="#a5fb383c4e5197e8e37ae1265cca8124d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a109c26234c2f934164e29649353532b6">GDALGenImgProjTransform</a> (void *pTransformArg, int bDstToSrc, int nPointCount, double *x, double *y, double *z, int *panSuccess)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform general image reprojection transformation.  <a href="#a109c26234c2f934164e29649353532b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#adce63548b884096e55d1685d4bbd7e63">GDALCreateReprojectionTransformer</a> (const char *pszSrcWKT, const char *pszDstWKT)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create reprojection transformer.  <a href="#adce63548b884096e55d1685d4bbd7e63"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#ae6cffb245df6fba275423f1333d89f08">GDALDestroyReprojectionTransformer</a> (void *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy reprojection transformation.  <a href="#ae6cffb245df6fba275423f1333d89f08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#af00f74e03c57842b359130ca73857521">GDALReprojectionTransform</a> (void *pTransformArg, int bDstToSrc, int nPointCount, double *x, double *y, double *z, int *panSuccess)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform reprojection transformation.  <a href="#af00f74e03c57842b359130ca73857521"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#ac57c80f7bf6752fac1dff8c2a21a15a3">GDALCreateGCPTransformer</a> (int nGCPCount, const <a class="el" href="structGDAL__GCP.html">GDAL_GCP</a> *pasGCPList, int nReqOrder, int bReversed)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create GCP based polynomial transformer.  <a href="#ac57c80f7bf6752fac1dff8c2a21a15a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac936c02335b159a70d940b725a0d3160"></a><!-- doxytag: member="gdal_alg.h::GDALCreateGCPRefineTransformer" ref="ac936c02335b159a70d940b725a0d3160" args="(int nGCPCount, const GDAL_GCP *pasGCPList, int nReqOrder, int bReversed, double tolerance, int minimumGcps)" -->
void *&nbsp;</td><td class="memItemRight" valign="bottom"><b>GDALCreateGCPRefineTransformer</b> (int nGCPCount, const <a class="el" href="structGDAL__GCP.html">GDAL_GCP</a> *pasGCPList, int nReqOrder, int bReversed, double tolerance, int minimumGcps)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a4b1acbe5387ac769f7fee1de93b81011">GDALDestroyGCPTransformer</a> (void *pTransformArg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy GCP transformer.  <a href="#a4b1acbe5387ac769f7fee1de93b81011"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a9acdfd7db1541c1df5e29a031994d61b">GDALGCPTransform</a> (void *pTransformArg, int bDstToSrc, int nPointCount, double *x, double *y, double *z, int *panSuccess)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transforms point based on GCP derived polynomial model.  <a href="#a9acdfd7db1541c1df5e29a031994d61b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a245802b88a8126c138d24febe6c9822a">GDALCreateTPSTransformer</a> (int nGCPCount, const <a class="el" href="structGDAL__GCP.html">GDAL_GCP</a> *pasGCPList, int bReversed)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create Thin Plate Spline transformer from GCPs.  <a href="#a245802b88a8126c138d24febe6c9822a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#afe5fccffbcc853230bc631441dc38469">GDALDestroyTPSTransformer</a> (void *pTransformArg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy TPS transformer.  <a href="#afe5fccffbcc853230bc631441dc38469"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#ab8ba2028a33f1f4eede6fc05ded7cbd6">GDALTPSTransform</a> (void *pTransformArg, int bDstToSrc, int nPointCount, double *x, double *y, double *z, int *panSuccess)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transforms point based on GCP derived polynomial model.  <a href="#ab8ba2028a33f1f4eede6fc05ded7cbd6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5b84a0de45c12402b8629947091d9ca"></a><!-- doxytag: member="gdal_alg.h::RPCInfoToMD" ref="ac5b84a0de45c12402b8629947091d9ca" args="(GDALRPCInfo *psRPCInfo)" -->
char **&nbsp;</td><td class="memItemRight" valign="bottom"><b>RPCInfoToMD</b> (<a class="el" href="structGDALRPCInfo.html">GDALRPCInfo</a> *psRPCInfo)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#af4c3c0d4c79218995b3a1f0bac3700a0">GDALCreateRPCTransformer</a> (<a class="el" href="structGDALRPCInfo.html">GDALRPCInfo</a> *psRPC, int bReversed, double dfPixErrThreshold, char **papszOptions)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an RPC based transformer.  <a href="#af4c3c0d4c79218995b3a1f0bac3700a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad63aa70d17c44424eb17ee550e5f4c8e"></a><!-- doxytag: member="gdal_alg.h::GDALDestroyRPCTransformer" ref="ad63aa70d17c44424eb17ee550e5f4c8e" args="(void *pTransformArg)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>GDALDestroyRPCTransformer</b> (void *pTransformArg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60b22697860cbdf1fe6f93e57c22bc7c"></a><!-- doxytag: member="gdal_alg.h::GDALRPCTransform" ref="a60b22697860cbdf1fe6f93e57c22bc7c" args="(void *pTransformArg, int bDstToSrc, int nPointCount, double *x, double *y, double *z, int *panSuccess)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>GDALRPCTransform</b> (void *pTransformArg, int bDstToSrc, int nPointCount, double *x, double *y, double *z, int *panSuccess)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1418a2caa399b1278516d0a3d99543b"></a><!-- doxytag: member="gdal_alg.h::GDALCreateGeoLocTransformer" ref="ab1418a2caa399b1278516d0a3d99543b" args="(GDALDatasetH hBaseDS, char **papszGeolocationInfo, int bReversed)" -->
void *&nbsp;</td><td class="memItemRight" valign="bottom"><b>GDALCreateGeoLocTransformer</b> (<a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a> hBaseDS, char **papszGeolocationInfo, int bReversed)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d06a68980e94b6ccb6397046a97e6bf"></a><!-- doxytag: member="gdal_alg.h::GDALDestroyGeoLocTransformer" ref="a1d06a68980e94b6ccb6397046a97e6bf" args="(void *pTransformArg)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>GDALDestroyGeoLocTransformer</b> (void *pTransformArg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2a535116fb06e20871fe52c0efb6a77"></a><!-- doxytag: member="gdal_alg.h::GDALGeoLocTransform" ref="af2a535116fb06e20871fe52c0efb6a77" args="(void *pTransformArg, int bDstToSrc, int nPointCount, double *x, double *y, double *z, int *panSuccess)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>GDALGeoLocTransform</b> (void *pTransformArg, int bDstToSrc, int nPointCount, double *x, double *y, double *z, int *panSuccess)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a4ec403b75384f0a71130eb009078426f">GDALCreateApproxTransformer</a> (<a class="el" href="gdal__alg_8h.html#a7df61123fec15deb3da3acabce19e647">GDALTransformerFunc</a> pfnRawTransformer, void *pRawTransformerArg, double dfMaxError)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an approximating transformer.  <a href="#a4ec403b75384f0a71130eb009078426f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d60f9a27bad206047e6ef1a75bc7fc0"></a><!-- doxytag: member="gdal_alg.h::GDALApproxTransformerOwnsSubtransformer" ref="a6d60f9a27bad206047e6ef1a75bc7fc0" args="(void *pCBData, int bOwnFlag)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>GDALApproxTransformerOwnsSubtransformer</b> (void *pCBData, int bOwnFlag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#aa8a1fd0719f5405e856e2103b23f1d9c">GDALDestroyApproxTransformer</a> (void *pApproxArg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cleanup approximate transformer.  <a href="#aa8a1fd0719f5405e856e2103b23f1d9c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a766ccb23b021d30d86908c08ad8d1668">GDALApproxTransform</a> (void *pTransformArg, int bDstToSrc, int nPointCount, double *x, double *y, double *z, int *panSuccess)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform approximate transformation.  <a href="#a766ccb23b021d30d86908c08ad8d1668"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#ae15910acb317cef94f3fd49dca6e4bab">GDALSimpleImageWarp</a> (<a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a> hSrcDS, <a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a> hDstDS, int nBandCount, int *panBandList, <a class="el" href="gdal__alg_8h.html#a7df61123fec15deb3da3acabce19e647">GDALTransformerFunc</a> pfnTransform, void *pTransformArg, GDALProgressFunc pfnProgress, void *pProgressArg, char **papszWarpOptions)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform simple image warp.  <a href="#ae15910acb317cef94f3fd49dca6e4bab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPLErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a816819e7495bfce06dbd110f7c57af65">GDALSuggestedWarpOutput</a> (<a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a> hSrcDS, <a class="el" href="gdal__alg_8h.html#a7df61123fec15deb3da3acabce19e647">GDALTransformerFunc</a> pfnTransformer, void *pTransformArg, double *padfGeoTransformOut, int *pnPixels, int *pnLines)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Suggest output file size.  <a href="#a816819e7495bfce06dbd110f7c57af65"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPLErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a8ae26881b86e42ff958a8e81c4976fb3">GDALSuggestedWarpOutput2</a> (<a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a> hSrcDS, <a class="el" href="gdal__alg_8h.html#a7df61123fec15deb3da3acabce19e647">GDALTransformerFunc</a> pfnTransformer, void *pTransformArg, double *padfGeoTransformOut, int *pnPixels, int *pnLines, double *padfExtents, int nOptions)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Suggest output file size.  <a href="#a8ae26881b86e42ff958a8e81c4976fb3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acddcc09ee5ddfb28e2064a4dcaf105b4"></a><!-- doxytag: member="gdal_alg.h::GDALSerializeTransformer" ref="acddcc09ee5ddfb28e2064a4dcaf105b4" args="(GDALTransformerFunc pfnFunc, void *pTransformArg)" -->
<a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>GDALSerializeTransformer</b> (<a class="el" href="gdal__alg_8h.html#a7df61123fec15deb3da3acabce19e647">GDALTransformerFunc</a> pfnFunc, void *pTransformArg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89f165b4329862d8f2f7ca4ff0c382f4"></a><!-- doxytag: member="gdal_alg.h::GDALDeserializeTransformer" ref="a89f165b4329862d8f2f7ca4ff0c382f4" args="(CPLXMLNode *psTree, GDALTransformerFunc *ppfnFunc, void **ppTransformArg)" -->
CPLErr&nbsp;</td><td class="memItemRight" valign="bottom"><b>GDALDeserializeTransformer</b> (<a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *psTree, <a class="el" href="gdal__alg_8h.html#a7df61123fec15deb3da3acabce19e647">GDALTransformerFunc</a> *ppfnFunc, void **ppTransformArg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPLErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a89ce288fe21fe395fc93c0026419f494">GDALTransformGeolocations</a> (<a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hXBand, <a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hYBand, <a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hZBand, <a class="el" href="gdal__alg_8h.html#a7df61123fec15deb3da3acabce19e647">GDALTransformerFunc</a> pfnTransformer, void *pTransformArg, GDALProgressFunc pfnProgress, void *pProgressArg, char **papszOptions)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transform locations held in bands.  <a href="#a89ce288fe21fe395fc93c0026419f494"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11f8f668cbacea097c06cece3ef522ef"></a><!-- doxytag: member="gdal_alg.h::GDAL_CG_Create" ref="a11f8f668cbacea097c06cece3ef522ef" args="(int nWidth, int nHeight, int bNoDataSet, double dfNoDataValue, double dfContourInterval, double dfContourBase, GDALContourWriter pfnWriter, void *pCBData)" -->
GDALContourGeneratorH&nbsp;</td><td class="memItemRight" valign="bottom"><b>GDAL_CG_Create</b> (int nWidth, int nHeight, int bNoDataSet, double dfNoDataValue, double dfContourInterval, double dfContourBase, GDALContourWriter pfnWriter, void *pCBData)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a979fe84abd948839e911202daf0136e3"></a><!-- doxytag: member="gdal_alg.h::GDAL_CG_FeedLine" ref="a979fe84abd948839e911202daf0136e3" args="(GDALContourGeneratorH hCG, double *padfScanline)" -->
CPLErr&nbsp;</td><td class="memItemRight" valign="bottom"><b>GDAL_CG_FeedLine</b> (GDALContourGeneratorH hCG, double *padfScanline)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a662f0efbbd5fbe4cc01338272ab84c9e"></a><!-- doxytag: member="gdal_alg.h::GDAL_CG_Destroy" ref="a662f0efbbd5fbe4cc01338272ab84c9e" args="(GDALContourGeneratorH hCG)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>GDAL_CG_Destroy</b> (GDALContourGeneratorH hCG)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04887970ec1d36cae8bfa821d5eabcc6"></a><!-- doxytag: member="gdal_alg.h::OGRContourWriter" ref="a04887970ec1d36cae8bfa821d5eabcc6" args="(double, int, double *, double *, void *pInfo)" -->
CPLErr&nbsp;</td><td class="memItemRight" valign="bottom"><b>OGRContourWriter</b> (double, int, double *, double *, void *pInfo)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPLErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#aceaf98ad40f159cbfb626988c054c085">GDALContourGenerate</a> (<a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a> hBand, double dfContourInterval, double dfContourBase, int nFixedLevelCount, double *padfFixedLevels, int bUseNoData, double dfNoDataValue, void *hLayer, int iIDField, int iElevField, GDALProgressFunc pfnProgress, void *pProgressArg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create vector contours from raster DEM.  <a href="#aceaf98ad40f159cbfb626988c054c085"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPLErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a50caf4bc34703f0bcf515ecbe5061a0a">GDALRasterizeGeometries</a> (<a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a> hDS, int nBandCount, int *panBandList, int nGeomCount, OGRGeometryH *pahGeometries, <a class="el" href="gdal__alg_8h.html#a7df61123fec15deb3da3acabce19e647">GDALTransformerFunc</a> pfnTransformer, void *pTransformArg, double *padfGeomBurnValue, char **papszOptions, GDALProgressFunc pfnProgress, void *pProgressArg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Burn geometries into raster.  <a href="#a50caf4bc34703f0bcf515ecbe5061a0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPLErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#adfe5e5d287d6c184aab03acbfa567cb1">GDALRasterizeLayers</a> (<a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a> hDS, int nBandCount, int *panBandList, int nLayerCount, OGRLayerH *pahLayers, <a class="el" href="gdal__alg_8h.html#a7df61123fec15deb3da3acabce19e647">GDALTransformerFunc</a> pfnTransformer, void *pTransformArg, double *padfLayerBurnValues, char **papszOptions, GDALProgressFunc pfnProgress, void *pProgressArg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Burn geometries from the specified list of layers into raster.  <a href="#adfe5e5d287d6c184aab03acbfa567cb1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPLErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#ab791949af233e16c119e4f49ee573cae">GDALRasterizeLayersBuf</a> (void *pData, int nBufXSize, int nBufYSize, <a class="el" href="gdal_8h.html#a22e22ce0a55036a96f652765793fb7a4">GDALDataType</a> eBufType, int nPixelSpace, int nLineSpace, int nLayerCount, OGRLayerH *pahLayers, const char *pszDstProjection, double *padfDstGeoTransform, <a class="el" href="gdal__alg_8h.html#a7df61123fec15deb3da3acabce19e647">GDALTransformerFunc</a> pfnTransformer, void *pTransformArg, double dfBurnValue, char **papszOptions, GDALProgressFunc pfnProgress, void *pProgressArg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Burn geometries from the specified list of layer into raster.  <a href="#ab791949af233e16c119e4f49ee573cae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPLErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="gdal__alg_8h.html#a1fdef40bcdbc98eff2328b0d093d3a22">GDALGridCreate</a> (<a class="el" href="gdal__alg_8h.html#a590d1a2d0bac1d34b95034c1f616de21">GDALGridAlgorithm</a>, const void *, GUInt32, const double *, const double *, const double *, double, double, double, double, GUInt32, GUInt32, <a class="el" href="gdal_8h.html#a22e22ce0a55036a96f652765793fb7a4">GDALDataType</a>, void *, GDALProgressFunc, void *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create regular grid from the scattered data.  <a href="#a1fdef40bcdbc98eff2328b0d093d3a22"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee648e2898ddca419ce0f682fcf99389"></a><!-- doxytag: member="gdal_alg.h::GDALComputeMatchingPoints" ref="aee648e2898ddca419ce0f682fcf99389" args="(GDALDatasetH hFirstImage, GDALDatasetH hSecondImage, char **papszOptions, int *pnGCPCount)" -->
<a class="el" href="structGDAL__GCP.html">GDAL_GCP</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>GDALComputeMatchingPoints</b> (<a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a> hFirstImage, <a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a> hSecondImage, char **papszOptions, int *pnGCPCount)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Public (C callable) GDAL algorithm entry points, and definitions. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a7df61123fec15deb3da3acabce19e647"></a><!-- doxytag: member="gdal_alg.h::GDALTransformerFunc" ref="a7df61123fec15deb3da3acabce19e647" args=")(void *pTransformerArg, int bDstToSrc, int nPointCount, double *x, double *y, double *z, int *panSuccess)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="gdal__alg_8h.html#a7df61123fec15deb3da3acabce19e647">GDALTransformerFunc</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Generic signature for spatial point transformers.</p>
<p>This function signature is used for a variety of functions that accept passed in functions used to transform point locations between two coordinate spaces.</p>
<p>The <a class="el" href="gdal__alg_8h.html#a7671696d085085a0bfba3c3df9ffcc0a" title="Create image to image transformer.">GDALCreateGenImgProjTransformer()</a>, <a class="el" href="gdal__alg_8h.html#adce63548b884096e55d1685d4bbd7e63" title="Create reprojection transformer.">GDALCreateReprojectionTransformer()</a>, <a class="el" href="gdal__alg_8h.html#ac57c80f7bf6752fac1dff8c2a21a15a3" title="Create GCP based polynomial transformer.">GDALCreateGCPTransformer()</a> and <a class="el" href="gdal__alg_8h.html#a4ec403b75384f0a71130eb009078426f" title="Create an approximating transformer.">GDALCreateApproxTransformer()</a> functions can be used to prepare argument data for some built-in transformers. As well, applications can implement their own transformers to the following signature.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> int 
(*<a class="code" href="gdal__alg_8h.html#a7df61123fec15deb3da3acabce19e647">GDALTransformerFunc</a>)( <span class="keywordtype">void</span> *pTransformerArg, 
                        <span class="keywordtype">int</span> bDstToSrc, <span class="keywordtype">int</span> nPointCount, 
                        <span class="keywordtype">double</span> *x, <span class="keywordtype">double</span> *y, <span class="keywordtype">double</span> *z, <span class="keywordtype">int</span> *panSuccess );
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pTransformerArg</em>&nbsp;</td><td>application supplied callback data used by the transformer.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bDstToSrc</em>&nbsp;</td><td>if TRUE the transformation will be from the destination coordinate space to the source coordinate system, otherwise the transformation will be from the source coordinate system to the destination coordinate system.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nPointCount</em>&nbsp;</td><td>number of points in the x, y and z arrays.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>input X coordinates. Results returned in same array.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>input Y coordinates. Results returned in same array.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>z</em>&nbsp;</td><td>input Z coordinates. Results returned in same array.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>panSuccess</em>&nbsp;</td><td>array of ints in which success (TRUE) or failure (FALSE) flags are returned for the translation of each point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the overall transformation succeeds (though some individual points may have failed) or FALSE if the overall transformation fails. </dd></dl>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a590d1a2d0bac1d34b95034c1f616de21"></a><!-- doxytag: member="gdal_alg.h::GDALGridAlgorithm" ref="a590d1a2d0bac1d34b95034c1f616de21" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="gdal__alg_8h.html#a590d1a2d0bac1d34b95034c1f616de21">GDALGridAlgorithm</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gridding Algorithms. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a590d1a2d0bac1d34b95034c1f616de21a5955211b72d8b07518815d544e5fa192"></a><!-- doxytag: member="GGA_InverseDistanceToAPower" ref="a590d1a2d0bac1d34b95034c1f616de21a5955211b72d8b07518815d544e5fa192" args="" -->GGA_InverseDistanceToAPower</em>&nbsp;</td><td>
<p>Inverse distance to a power </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a590d1a2d0bac1d34b95034c1f616de21aaafac5453ea6a64e9c84c5143cfbdcaf"></a><!-- doxytag: member="GGA_MovingAverage" ref="a590d1a2d0bac1d34b95034c1f616de21aaafac5453ea6a64e9c84c5143cfbdcaf" args="" -->GGA_MovingAverage</em>&nbsp;</td><td>
<p>Moving Average </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a590d1a2d0bac1d34b95034c1f616de21a70c30cb508518172fbce051a7927eb68"></a><!-- doxytag: member="GGA_NearestNeighbor" ref="a590d1a2d0bac1d34b95034c1f616de21a70c30cb508518172fbce051a7927eb68" args="" -->GGA_NearestNeighbor</em>&nbsp;</td><td>
<p>Nearest Neighbor </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a590d1a2d0bac1d34b95034c1f616de21a114443c69d10fafd0e4a6195cb178e75"></a><!-- doxytag: member="GGA_MetricMinimum" ref="a590d1a2d0bac1d34b95034c1f616de21a114443c69d10fafd0e4a6195cb178e75" args="" -->GGA_MetricMinimum</em>&nbsp;</td><td>
<p>Minimum Value (Data Metric) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a590d1a2d0bac1d34b95034c1f616de21a62e4fcf09890e32a287364ca165f78e2"></a><!-- doxytag: member="GGA_MetricMaximum" ref="a590d1a2d0bac1d34b95034c1f616de21a62e4fcf09890e32a287364ca165f78e2" args="" -->GGA_MetricMaximum</em>&nbsp;</td><td>
<p>Maximum Value (Data Metric) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a590d1a2d0bac1d34b95034c1f616de21aed976fb5778362e9c51e5859d19ac917"></a><!-- doxytag: member="GGA_MetricRange" ref="a590d1a2d0bac1d34b95034c1f616de21aed976fb5778362e9c51e5859d19ac917" args="" -->GGA_MetricRange</em>&nbsp;</td><td>
<p>Data Range (Data Metric) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a590d1a2d0bac1d34b95034c1f616de21ac41203ffb292f6fadf155a5d3ff80219"></a><!-- doxytag: member="GGA_MetricCount" ref="a590d1a2d0bac1d34b95034c1f616de21ac41203ffb292f6fadf155a5d3ff80219" args="" -->GGA_MetricCount</em>&nbsp;</td><td>
<p>Number of Points (Data Metric) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a590d1a2d0bac1d34b95034c1f616de21a90cfa34b606733fcbc4c7b15e36fefcf"></a><!-- doxytag: member="GGA_MetricAverageDistance" ref="a590d1a2d0bac1d34b95034c1f616de21a90cfa34b606733fcbc4c7b15e36fefcf" args="" -->GGA_MetricAverageDistance</em>&nbsp;</td><td>
<p>Average Distance (Data Metric) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a590d1a2d0bac1d34b95034c1f616de21a5c0dc83a00305d4a1beda88406aefbb6"></a><!-- doxytag: member="GGA_MetricAverageDistancePts" ref="a590d1a2d0bac1d34b95034c1f616de21a5c0dc83a00305d4a1beda88406aefbb6" args="" -->GGA_MetricAverageDistancePts</em>&nbsp;</td><td>
<p>Average Distance Between Data Points (Data Metric) </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a766ccb23b021d30d86908c08ad8d1668"></a><!-- doxytag: member="gdal_alg.h::GDALApproxTransform" ref="a766ccb23b021d30d86908c08ad8d1668" args="(void *pTransformArg, int bDstToSrc, int nPointCount, double *x, double *y, double *z, int *panSuccess)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDALApproxTransform </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pCBData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bDstToSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>panSuccess</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform approximate transformation. </p>
<p>Actually performs the approximate transformation described in <a class="el" href="gdal__alg_8h.html#a4ec403b75384f0a71130eb009078426f" title="Create an approximating transformer.">GDALCreateApproxTransformer()</a>. This function matches the <a class="el" href="gdal__alg_8h.html#a7df61123fec15deb3da3acabce19e647">GDALTransformerFunc()</a> signature. Details of the arguments are described there. </p>

</div>
</div>
<a class="anchor" id="abe2846ac3a350c24f07dc9ceac8f4d14"></a><!-- doxytag: member="gdal_alg.h::GDALChecksumImage" ref="abe2846ac3a350c24f07dc9ceac8f4d14" args="(GDALRasterBandH hBand, int nXOff, int nYOff, int nXSize, int nYSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDALChecksumImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&nbsp;</td>
          <td class="paramname"> <em>hBand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nXOff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nYOff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nXSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nYSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute checksum for image region. </p>
<p>Computes a 16bit (0-65535) checksum from a region of raster data on a GDAL supported band. Floating point data is converted to 32bit integer so decimal portions of such raster data will not affect the checksum. Real and Imaginary components of complex bands influence the result.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hBand</em>&nbsp;</td><td>the raster band to read from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nXOff</em>&nbsp;</td><td>pixel offset of window to read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nYOff</em>&nbsp;</td><td>line offset of window to read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nXSize</em>&nbsp;</td><td>pixel size of window to read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nYSize</em>&nbsp;</td><td>line size of window to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Checksum value. </dd></dl>

</div>
</div>
<a class="anchor" id="a61e48f88c3b4b3cf7957c61dc7bd1ead"></a><!-- doxytag: member="gdal_alg.h::GDALComputeMedianCutPCT" ref="a61e48f88c3b4b3cf7957c61dc7bd1ead" args="(GDALRasterBandH hRed, GDALRasterBandH hGreen, GDALRasterBandH hBlue, int(*pfnIncludePixel)(int, int, void *), int nColors, GDALColorTableH hColorTable, GDALProgressFunc pfnProgress, void *pProgressArg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDALComputeMedianCutPCT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&nbsp;</td>
          <td class="paramname"> <em>hRed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&nbsp;</td>
          <td class="paramname"> <em>hGreen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&nbsp;</td>
          <td class="paramname"> <em>hBlue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(int, int, void *)&nbsp;</td>
          <td class="paramname"> <em>pfnIncludePixel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nColors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#af1baae80dd0ec873ad7ad5b28dda44f3">GDALColorTableH</a>&nbsp;</td>
          <td class="paramname"> <em>hColorTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&nbsp;</td>
          <td class="paramname"> <em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pProgressArg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute optimal PCT for RGB image. </p>
<p>This function implements a median cut algorithm to compute an "optimal" pseudocolor table for representing an input RGB image. This PCT could then be used with <a class="el" href="gdal__alg_8h.html#a284dbcc27295b7e678b1f7d4fa1506cb" title="24bit to 8bit conversion with dithering.">GDALDitherRGB2PCT()</a> to convert a 24bit RGB image into an eightbit pseudo-colored image.</p>
<p>This code was based on the tiffmedian.c code from libtiff (www.libtiff.org) which was based on a paper by Paul Heckbert:</p>
<div class="fragment"><pre class="fragment">
 *   "Color  Image Quantization for Frame Buffer Display", Paul
 *   Heckbert, SIGGRAPH proceedings, 1982, pp. 297-307.
 * </pre></div><p>The red, green and blue input bands do not necessarily need to come from the same file, but they must be the same width and height. They will be clipped to 8bit during reading, so non-eight bit bands are generally inappropriate.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hRed</em>&nbsp;</td><td>Red input band. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hGreen</em>&nbsp;</td><td>Green input band. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hBlue</em>&nbsp;</td><td>Blue input band. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnIncludePixel</em>&nbsp;</td><td>function used to test which pixels should be included in the analysis. At this time this argument is ignored and all pixels are utilized. This should normally be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nColors</em>&nbsp;</td><td>the desired number of colors to be returned (2-256). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hColorTable</em>&nbsp;</td><td>the colors will be returned in this color table object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnProgress</em>&nbsp;</td><td>callback for reporting algorithm progress matching the GDALProgressFunc() semantics. May be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pProgressArg</em>&nbsp;</td><td>callback argument passed to pfnProgress.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>returns CE_None on success or CE_Failure if an error occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="a851815400a579aae9de01199b416fa42"></a><!-- doxytag: member="gdal_alg.h::GDALComputeProximity" ref="a851815400a579aae9de01199b416fa42" args="(GDALRasterBandH hSrcBand, GDALRasterBandH hProximityBand, char **papszOptions, GDALProgressFunc pfnProgress, void *pProgressArg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPLErr GDALComputeProximity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&nbsp;</td>
          <td class="paramname"> <em>hSrcBand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&nbsp;</td>
          <td class="paramname"> <em>hProximityBand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&nbsp;</td>
          <td class="paramname"> <em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pProgressArg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the proximity of all pixels in the image to a set of pixels in the source image. </p>
<p>This function attempts to compute the proximity of all pixels in the image to a set of pixels in the source image. The following options are used to define the behavior of the function. By default all non-zero pixels in hSrcBand will be considered the "target", and all proximities will be computed in pixels. Note that target pixels are set to the value corresponding to a distance of zero.</p>
<p>The progress function args may be NULL or a valid progress reporting function such as GDALTermProgress/NULL.</p>
<p>Options:</p>
<p>VALUES=n[,n]*</p>
<p>A list of target pixel values to measure the distance from. If this option is not provided proximity will be computed from non-zero pixel values. Currently pixel values are internally processed as integers.</p>
<p>DISTUNITS=[PIXEL]/GEO</p>
<p>Indicates whether distances will be computed in pixel units or in georeferenced units. The default is pixel units. This also determines the interpretation of MAXDIST.</p>
<p>MAXDIST=n</p>
<p>The maximum distance to search. Proximity distances greater than this value will not be computed. Instead output pixels will be set to a nodata value.</p>
<p>NODATA=n</p>
<p>The NODATA value to use on the output band for pixels that are beyond MAXDIST. If not provided, the hProximityBand will be queried for a nodata value. If one is not found, 65535 will be used.</p>
<p>FIXED_BUF_VAL=n</p>
<p>If this option is set, all pixels within the MAXDIST threadhold are set to this fixed value instead of to a proximity distance. </p>

</div>
</div>
<a class="anchor" id="aceaf98ad40f159cbfb626988c054c085"></a><!-- doxytag: member="gdal_alg.h::GDALContourGenerate" ref="aceaf98ad40f159cbfb626988c054c085" args="(GDALRasterBandH hBand, double dfContourInterval, double dfContourBase, int nFixedLevelCount, double *padfFixedLevels, int bUseNoData, double dfNoDataValue, void *hLayer, int iIDField, int iElevField, GDALProgressFunc pfnProgress, void *pProgressArg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPLErr GDALContourGenerate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&nbsp;</td>
          <td class="paramname"> <em>hBand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfContourInterval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfContourBase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nFixedLevelCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>padfFixedLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bUseNoData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfNoDataValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iIDField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iElevField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&nbsp;</td>
          <td class="paramname"> <em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pProgressArg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create vector contours from raster DEM. </p>
<p>This algorithm will generate contour vectors for the input raster band on the requested set of contour levels. The vector contours are written to the passed in OGR vector layer. Also, a NODATA value may be specified to identify pixels that should not be considered in contour line generation.</p>
<p>The gdal/apps/gdal_contour.cpp mainline can be used as an example of how to use this function.</p>
<p>ALGORITHM RULES</p>
<p>For contouring purposes raster pixel values are assumed to represent a point value at the center of the corresponding pixel region. For the purpose of contour generation we virtually connect each pixel center to the values to the left, right, top and bottom. We assume that the pixel value is linearly interpolated between the pixel centers along each line, and determine where (if any) contour lines will appear along these line segements. Then the contour crossings are connected.</p>
<p>This means that contour lines' nodes won't actually be on pixel edges, but rather along vertical and horizontal lines connecting the pixel centers.</p>
<div class="fragment"><pre class="fragment">
General Case:

      5 |                  | 3
     -- + ---------------- + -- 
        |                  |
        |                  |
        |                  |
        |                  |
     10 +                  |
        |\                 |
        | \                |
     -- + -+-------------- + -- 
     12 |  10              | 1


Saddle Point:

      5 |                  | 12
     -- + -------------+-- + -- 
        |               \  |
        |                 \|
        |                  + 
        |                  |
        +                  |
        |\                 |
        | \                |
     -- + -+-------------- + -- 
     12 |                  | 1

or:

      5 |                  | 12
     -- + -------------+-- + -- 
        |          __/     |
        |      ___/        |
        |  ___/          __+ 
        | /           __/  |
        +'         __/     |
        |       __/        |
        |   ,__/           |
     -- + -+-------------- + -- 
     12 |                  | 1
</pre></div><p>Nodata:</p>
<p>In the "nodata" case we treat the whole nodata pixel as a no-mans land. We extend the corner pixels near the nodata out to half way and then construct extra lines from those points to the center which is assigned an averaged value from the two nearby points (in this case (12+3+5)/3).</p>
<div class="fragment"><pre class="fragment">
      5 |                  | 3
     -- + ---------------- + -- 
        |                  |
        |                  |
        |      6.7         |
        |        +---------+ 3
     10 +___     |          
        |   \____+ 10       
        |        |          
     -- + -------+        +    
     12 |       12           (nodata)

</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hBand</em>&nbsp;</td><td>The band to read raster data from. The whole band will be processed.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfContourInterval</em>&nbsp;</td><td>The elevation interval between contours generated.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfContourBase</em>&nbsp;</td><td>The "base" relative to which contour intervals are applied. This is normally zero, but could be different. To generate 10m contours at 5, 15, 25, ... the ContourBase would be 5.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nFixedLevelCount</em>&nbsp;</td><td>The number of fixed levels. If this is greater than zero, then fixed levels will be used, and ContourInterval and ContourBase are ignored.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfFixedLevels</em>&nbsp;</td><td>The list of fixed contour levels at which contours should be generated. It will contain FixedLevelCount entries, and may be NULL if fixed levels are disabled (FixedLevelCount = 0).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bUseNoData</em>&nbsp;</td><td>If TRUE the dfNoDataValue will be used.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfNoDataValue</em>&nbsp;</td><td>The value to use as a "nodata" value. That is, a pixel value which should be ignored in generating contours as if the value of the pixel were not known.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hLayer</em>&nbsp;</td><td>The layer to which new contour vectors will be written. Each contour will have a LINESTRING geometry attached to it. This is really of type OGRLayerH, but void * is used to avoid pulling the ogr_api.h file in here.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iIDField</em>&nbsp;</td><td>If not -1 this will be used as a field index to indicate where a unique id should be written for each feature (contour) written.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iElevField</em>&nbsp;</td><td>If not -1 this will be used as a field index to indicate where the elevation value of the contour should be written.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnProgress</em>&nbsp;</td><td>A GDALProgressFunc that may be used to report progress to the user, or to interrupt the algorithm. May be NULL if not required.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pProgressArg</em>&nbsp;</td><td>The callback data for the pfnProgress function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CE_None on success or CE_Failure if an error occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="a4ec403b75384f0a71130eb009078426f"></a><!-- doxytag: member="gdal_alg.h::GDALCreateApproxTransformer" ref="a4ec403b75384f0a71130eb009078426f" args="(GDALTransformerFunc pfnRawTransformer, void *pRawTransformerArg, double dfMaxError)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* GDALCreateApproxTransformer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal__alg_8h.html#a7df61123fec15deb3da3acabce19e647">GDALTransformerFunc</a>&nbsp;</td>
          <td class="paramname"> <em>pfnBaseTransformer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pBaseTransformArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfMaxError</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an approximating transformer. </p>
<p>This function creates a context for an approximated transformer. Basically a high precision transformer is supplied as input and internally linear approximations are computed to generate results to within a defined precision.</p>
<p>The approximation is actually done at the point where <a class="el" href="gdal__alg_8h.html#a766ccb23b021d30d86908c08ad8d1668" title="Perform approximate transformation.">GDALApproxTransform()</a> calls are made, and depend on the assumption that the roughly linear. The first and last point passed in must be the extreme values and the intermediate values should describe a curve between the end points. The approximator transforms and center using the approximate transformer, and then compares the true middle transformed value to a linear approximation based on the end points. If the error is within the supplied threshold then the end points are used to linearly approximate all the values otherwise the inputs points are split into two smaller sets, and the function recursively called till a sufficiently small set of points if found that the linear approximation is OK, or that all the points are exactly computed.</p>
<p>This function is very suitable for approximating transformation results from output pixel/line space to input coordinates for warpers that operate on one input scanline at a time. Care should be taken using it in other circumstances as little internal validation is done, in order to keep things fast.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pfnBaseTransformer</em>&nbsp;</td><td>the high precision transformer which should be approximated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pBaseTransformArg</em>&nbsp;</td><td>the callback argument for the high precision transformer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfMaxError</em>&nbsp;</td><td>the maximum cartesian error in the "output" space that is to be accepted in the linear approximation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>callback pointer suitable for use with <a class="el" href="gdal__alg_8h.html#a766ccb23b021d30d86908c08ad8d1668" title="Perform approximate transformation.">GDALApproxTransform()</a>. It should be deallocated with <a class="el" href="gdal__alg_8h.html#aa8a1fd0719f5405e856e2103b23f1d9c" title="Cleanup approximate transformer.">GDALDestroyApproxTransformer()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ac57c80f7bf6752fac1dff8c2a21a15a3"></a><!-- doxytag: member="gdal_alg.h::GDALCreateGCPTransformer" ref="ac57c80f7bf6752fac1dff8c2a21a15a3" args="(int nGCPCount, const GDAL_GCP *pasGCPList, int nReqOrder, int bReversed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* GDALCreateGCPTransformer </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nGCPCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structGDAL__GCP.html">GDAL_GCP</a> *&nbsp;</td>
          <td class="paramname"> <em>pasGCPList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nReqOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bReversed</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create GCP based polynomial transformer. </p>
<p>Computes least squares fit polynomials from a provided set of GCPs, and stores the coefficients for later transformation of points between pixel/line and georeferenced coordinates.</p>
<p>The return value should be used as a TransformArg in combination with the transformation function GDALGCPTransform which fits the GDALTransformerFunc signature. The returned transform argument should be deallocated with GDALDestroyGCPTransformer when no longer needed.</p>
<p>This function may fail (returning NULL) if the provided set of GCPs are inadequate for the requested order, the determinate is zero or they are otherwise "ill conditioned".</p>
<p>Note that 2nd order requires at least 6 GCPs, and 3rd order requires at least 10 gcps. If nReqOrder is 0 the highest order possible with the provided gcp count will be used.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nGCPCount</em>&nbsp;</td><td>the number of GCPs in pasGCPList. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pasGCPList</em>&nbsp;</td><td>an array of GCPs to be used as input. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nReqOrder</em>&nbsp;</td><td>the requested polynomial order. It should be 1, 2 or 3. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bReversed</em>&nbsp;</td><td>set it to TRUE to compute the reversed transformation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the transform argument or NULL if creation fails. </dd></dl>

</div>
</div>
<a class="anchor" id="a7671696d085085a0bfba3c3df9ffcc0a"></a><!-- doxytag: member="gdal_alg.h::GDALCreateGenImgProjTransformer" ref="a7671696d085085a0bfba3c3df9ffcc0a" args="(GDALDatasetH hSrcDS, const char *pszSrcWKT, GDALDatasetH hDstDS, const char *pszDstWKT, int bGCPUseOK, double dfGCPErrorThreshold, int nOrder)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* GDALCreateGenImgProjTransformer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a>&nbsp;</td>
          <td class="paramname"> <em>hSrcDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszSrcWKT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a>&nbsp;</td>
          <td class="paramname"> <em>hDstDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszDstWKT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bGCPUseOK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfGCPErrorThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nOrder</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create image to image transformer. </p>
<p>This function creates a transformation object that maps from pixel/line coordinates on one image to pixel/line coordinates on another image. The images may potentially be georeferenced in different coordinate systems, and may used GCPs to map between their pixel/line coordinates and georeferenced coordinates (as opposed to the default assumption that their geotransform should be used).</p>
<p>This transformer potentially performs three concatenated transformations.</p>
<p>The first stage is from source image pixel/line coordinates to source image georeferenced coordinates, and may be done using the geotransform, or if not defined using a polynomial model derived from GCPs. If GCPs are used this stage is accomplished using <a class="el" href="gdal__alg_8h.html#a9acdfd7db1541c1df5e29a031994d61b" title="Transforms point based on GCP derived polynomial model.">GDALGCPTransform()</a>.</p>
<p>The second stage is to change projections from the source coordinate system to the destination coordinate system, assuming they differ. This is accomplished internally using <a class="el" href="gdal__alg_8h.html#af00f74e03c57842b359130ca73857521" title="Perform reprojection transformation.">GDALReprojectionTransform()</a>.</p>
<p>The third stage is converting from destination image georeferenced coordinates to destination image coordinates. This is done using the destination image geotransform, or if not available, using a polynomial model derived from GCPs. If GCPs are used this stage is accomplished using <a class="el" href="gdal__alg_8h.html#a9acdfd7db1541c1df5e29a031994d61b" title="Transforms point based on GCP derived polynomial model.">GDALGCPTransform()</a>. This stage is skipped if hDstDS is NULL when the transformation is created.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hSrcDS</em>&nbsp;</td><td>source dataset, or NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszSrcWKT</em>&nbsp;</td><td>the coordinate system for the source dataset. If NULL, it will be read from the dataset itself. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hDstDS</em>&nbsp;</td><td>destination dataset (or NULL). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszDstWKT</em>&nbsp;</td><td>the coordinate system for the destination dataset. If NULL, and hDstDS not NULL, it will be read from the destination dataset. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bGCPUseOK</em>&nbsp;</td><td>TRUE if GCPs should be used if the geotransform is not available on the source dataset (not destination). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfGCPErrorThreshold</em>&nbsp;</td><td>ignored/deprecated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nOrder</em>&nbsp;</td><td>the maximum order to use for GCP derived polynomials if possible. Use 0 to autoselect, or -1 for thin plate splines.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>handle suitable for use <a class="el" href="gdal__alg_8h.html#a109c26234c2f934164e29649353532b6" title="Perform general image reprojection transformation.">GDALGenImgProjTransform()</a>, and to be deallocated with <a class="el" href="gdal__alg_8h.html#a5fb383c4e5197e8e37ae1265cca8124d" title="GenImgProjTransformer deallocator.">GDALDestroyGenImgProjTransformer()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a94cd172f78dbc41d6f407d662914f2e3"></a><!-- doxytag: member="gdal_alg.h::GDALCreateGenImgProjTransformer2" ref="a94cd172f78dbc41d6f407d662914f2e3" args="(GDALDatasetH hSrcDS, GDALDatasetH hDstDS, char **papszOptions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* GDALCreateGenImgProjTransformer2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a>&nbsp;</td>
          <td class="paramname"> <em>hSrcDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a>&nbsp;</td>
          <td class="paramname"> <em>hDstDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszOptions</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create image to image transformer. </p>
<p>This function creates a transformation object that maps from pixel/line coordinates on one image to pixel/line coordinates on another image. The images may potentially be georeferenced in different coordinate systems, and may used GCPs to map between their pixel/line coordinates and georeferenced coordinates (as opposed to the default assumption that their geotransform should be used).</p>
<p>This transformer potentially performs three concatenated transformations.</p>
<p>The first stage is from source image pixel/line coordinates to source image georeferenced coordinates, and may be done using the geotransform, or if not defined using a polynomial model derived from GCPs. If GCPs are used this stage is accomplished using <a class="el" href="gdal__alg_8h.html#a9acdfd7db1541c1df5e29a031994d61b" title="Transforms point based on GCP derived polynomial model.">GDALGCPTransform()</a>.</p>
<p>The second stage is to change projections from the source coordinate system to the destination coordinate system, assuming they differ. This is accomplished internally using <a class="el" href="gdal__alg_8h.html#af00f74e03c57842b359130ca73857521" title="Perform reprojection transformation.">GDALReprojectionTransform()</a>.</p>
<p>The third stage is converting from destination image georeferenced coordinates to destination image coordinates. This is done using the destination image geotransform, or if not available, using a polynomial model derived from GCPs. If GCPs are used this stage is accomplished using <a class="el" href="gdal__alg_8h.html#a9acdfd7db1541c1df5e29a031994d61b" title="Transforms point based on GCP derived polynomial model.">GDALGCPTransform()</a>. This stage is skipped if hDstDS is NULL when the transformation is created.</p>
<p>Supported Options: </p>
<ul>
<li>
SRC_SRS: WKT SRS to be used as an override for hSrcDS. </li>
<li>
DST_SRS: WKT SRS to be used as an override for hDstDS. </li>
<li>
GCPS_OK: If false, GCPs will not be used, default is TRUE. </li>
<li>
REFINE_MINIMUM_GCPS: The minimum amount of GCPs that should be available after the refinement. </li>
<li>
REFINE_TOLERANCE: The tolernace that specifies when a GCP will be eliminated. </li>
<li>
MAX_GCP_ORDER: the maximum order to use for GCP derived polynomials if possible. The default is to autoselect based on the number of GCPs. A value of -1 triggers use of Thin Plate Spline instead of polynomials. </li>
<li>
SRC_METHOD: may have a value which is one of GEOTRANSFORM, GCP_POLYNOMIAL, GCP_TPS, GEOLOC_ARRAY, RPC to force only one geolocation method to be considered on the source dataset. Will be used for pixel/line to georef transformation on the source dataset. </li>
<li>
DST_METHOD: may have a value which is one of GEOTRANSFORM, GCP_POLYNOMIAL, GCP_TPS, GEOLOC_ARRAY, RPC to force only one geolocation method to be considered on the source dataset. Will be used for pixel/line to georef transformation on the destination dataset. </li>
<li>
RPC_HEIGHT: A fixed height to be used with RPC calculations. </li>
<li>
RPC_DEM: The name of a DEM file to be used with RPC calculations. </li>
<li>
INSERT_CENTER_LONG: May be set to FALSE to disable setting up a CENTER_LONG value on the coordinate system to rewrap things around the center of the image. </li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hSrcDS</em>&nbsp;</td><td>source dataset, or NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hDstDS</em>&nbsp;</td><td>destination dataset (or NULL). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>papszOptions</em>&nbsp;</td><td>NULL-terminated list of string options (or NULL).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>handle suitable for use <a class="el" href="gdal__alg_8h.html#a109c26234c2f934164e29649353532b6" title="Perform general image reprojection transformation.">GDALGenImgProjTransform()</a>, and to be deallocated with <a class="el" href="gdal__alg_8h.html#a5fb383c4e5197e8e37ae1265cca8124d" title="GenImgProjTransformer deallocator.">GDALDestroyGenImgProjTransformer()</a> or NULL on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a05f5de51947234a0481088bed2d7ce53"></a><!-- doxytag: member="gdal_alg.h::GDALCreateGenImgProjTransformer3" ref="a05f5de51947234a0481088bed2d7ce53" args="(const char *pszSrcWKT, const double *padfSrcGeoTransform, const char *pszDstWKT, const double *padfDstGeoTransform)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* GDALCreateGenImgProjTransformer3 </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszSrcWKT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>padfSrcGeoTransform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszDstWKT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>padfDstGeoTransform</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create image to image transformer. </p>
<p>This function creates a transformation object that maps from pixel/line coordinates on one image to pixel/line coordinates on another image. The images may potentially be georeferenced in different coordinate systems, and may used GCPs to map between their pixel/line coordinates and georeferenced coordinates (as opposed to the default assumption that their geotransform should be used).</p>
<p>This transformer potentially performs three concatenated transformations.</p>
<p>The first stage is from source image pixel/line coordinates to source image georeferenced coordinates, and may be done using the geotransform, or if not defined using a polynomial model derived from GCPs. If GCPs are used this stage is accomplished using <a class="el" href="gdal__alg_8h.html#a9acdfd7db1541c1df5e29a031994d61b" title="Transforms point based on GCP derived polynomial model.">GDALGCPTransform()</a>.</p>
<p>The second stage is to change projections from the source coordinate system to the destination coordinate system, assuming they differ. This is accomplished internally using <a class="el" href="gdal__alg_8h.html#af00f74e03c57842b359130ca73857521" title="Perform reprojection transformation.">GDALReprojectionTransform()</a>.</p>
<p>The third stage is converting from destination image georeferenced coordinates to destination image coordinates. This is done using the destination image geotransform, or if not available, using a polynomial model derived from GCPs. If GCPs are used this stage is accomplished using <a class="el" href="gdal__alg_8h.html#a9acdfd7db1541c1df5e29a031994d61b" title="Transforms point based on GCP derived polynomial model.">GDALGCPTransform()</a>. This stage is skipped if hDstDS is NULL when the transformation is created.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszSrcWKT</em>&nbsp;</td><td>source WKT (or NULL). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfSrcGeoTransform</em>&nbsp;</td><td>source geotransform (or NULL). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszDstWKT</em>&nbsp;</td><td>destination WKT (or NULL). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfDstGeoTransform</em>&nbsp;</td><td>destination geotransform (or NULL).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>handle suitable for use <a class="el" href="gdal__alg_8h.html#a109c26234c2f934164e29649353532b6" title="Perform general image reprojection transformation.">GDALGenImgProjTransform()</a>, and to be deallocated with <a class="el" href="gdal__alg_8h.html#a5fb383c4e5197e8e37ae1265cca8124d" title="GenImgProjTransformer deallocator.">GDALDestroyGenImgProjTransformer()</a> or NULL on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="adce63548b884096e55d1685d4bbd7e63"></a><!-- doxytag: member="gdal_alg.h::GDALCreateReprojectionTransformer" ref="adce63548b884096e55d1685d4bbd7e63" args="(const char *pszSrcWKT, const char *pszDstWKT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* GDALCreateReprojectionTransformer </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszSrcWKT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszDstWKT</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create reprojection transformer. </p>
<p>Creates a callback data structure suitable for use with GDALReprojectionTransformation() to represent a transformation from one geographic or projected coordinate system to another. On input the coordinate systems are described in OpenGIS WKT format.</p>
<p>Internally the OGRCoordinateTransformation object is used to implement the reprojection.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszSrcWKT</em>&nbsp;</td><td>the coordinate system for the source coordinate system. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszDstWKT</em>&nbsp;</td><td>the coordinate system for the destination coordinate system.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Handle for use with <a class="el" href="gdal__alg_8h.html#af00f74e03c57842b359130ca73857521" title="Perform reprojection transformation.">GDALReprojectionTransform()</a>, or NULL if the system fails to initialize the reprojection. </dd></dl>

</div>
</div>
<a class="anchor" id="af4c3c0d4c79218995b3a1f0bac3700a0"></a><!-- doxytag: member="gdal_alg.h::GDALCreateRPCTransformer" ref="af4c3c0d4c79218995b3a1f0bac3700a0" args="(GDALRPCInfo *psRPC, int bReversed, double dfPixErrThreshold, char **papszOptions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* GDALCreateRPCTransformer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGDALRPCInfo.html">GDALRPCInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>psRPCInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bReversed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfPixErrThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszOptions</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an RPC based transformer. </p>
<p>The geometric sensor model describing the physical relationship between image coordinates and ground coordinate is known as a Rigorous Projection Model. A Rigorous Projection Model expresses the mapping of the image space coordinates of rows and columns (r,c) onto the object space reference surface geodetic coordinates (long, lat, height).</p>
<p>RPC supports a generic description of the Rigorous Projection Models. The approximation used by GDAL (RPC00) is a set of rational polynomials exp ressing the normalized row and column values, (rn , cn), as a function of normalized geodetic latitude, longitude, and height, (P, L, H), given a set of normalized polynomial coefficients (LINE_NUM_COEF_n, LINE_DEN_COEF_n, SAMP_NUM_COEF_n, SAMP_DEN_COEF_n). Normalized values, rather than actual values are used in order to minimize introduction of errors during the calculations. The transformation between row and column values (r,c), and normalized row and column values (rn, cn), and between the geodetic latitude, longitude, and height and normalized geodetic latitude, longitude, and height (P, L, H), is defined by a set of normalizing translations (offsets) and scales that ensure all values are contained i the range -1 to +1.</p>
<p>This function creates a GDALTransformFunc compatible transformer for going between image pixel/line and long/lat/height coordinates using RPCs. The RPCs are provided in a <a class="el" href="structGDALRPCInfo.html">GDALRPCInfo</a> structure which is normally read from metadata using GDALExtractRPCInfo().</p>
<p>GDAL RPC Metadata has the following entries (also described in GDAL RFC 22 and the GeoTIFF RPC document <a href="http://geotiff.maptools.org/rpc_prop.html.">http://geotiff.maptools.org/rpc_prop.html.</a></p>
<ul>
<li>
ERR_BIAS: Error - Bias. The RMS bias error in meters per horizontal axis of all points in the image (-1.0 if unknown) </li>
<li>
ERR_RAND: Error - Random. RMS random error in meters per horizontal axis of each point in the image (-1.0 if unknown) </li>
<li>
LINE_OFF: Line Offset </li>
<li>
SAMP_OFF: Sample Offset </li>
<li>
LAT_OFF: Geodetic Latitude Offset </li>
<li>
LONG_OFF: Geodetic Longitude Offset </li>
<li>
HEIGHT_OFF: Geodetic Height Offset </li>
<li>
LINE_SCALE: Line Scale </li>
<li>
SAMP_SCALE: Sample Scale </li>
<li>
LAT_SCALE: Geodetic Latitude Scale </li>
<li>
LONG_SCALE: Geodetic Longitude Scale </li>
<li>
HEIGHT_SCALE: Geodetic Height Scale </li>
<li>
LINE_NUM_COEFF (1-20): Line Numerator Coefficients. Twenty coefficients for the polynomial in the Numerator of the rn equation. (space separated) </li>
<li>
LINE_DEN_COEFF (1-20): Line Denominator Coefficients. Twenty coefficients for the polynomial in the Denominator of the rn equation. (space separated) </li>
<li>
SAMP_NUM_COEFF (1-20): Sample Numerator Coefficients. Twenty coefficients for the polynomial in the Numerator of the cn equation. (space separated) </li>
<li>
SAMP_DEN_COEFF (1-20): Sample Denominator Coefficients. Twenty coefficients for the polynomial in the Denominator of the cn equation. (space separated) </li>
</ul>
<p>The transformer normally maps from pixel/line/height to long/lat/height space as a forward transformation though in RPC terms that would be considered an inverse transformation (and is solved by iterative approximation using long/lat/height to pixel/line transformations). The default direction can be reversed by passing bReversed=TRUE.</p>
<p>The iterative solution of pixel/line to lat/long/height is currently run for up to 10 iterations or until the apparent error is less than dfPixErrThreshold pixels. Passing zero will not avoid all error, but will cause the operation to run for the maximum number of iterations.</p>
<p>Additional options to the transformer can be supplied in papszOptions.</p>
<p>Options:</p>
<ul>
<li>
<p class="startli">RPC_HEIGHT: a fixed height offset to be applied to all points passed in. In this situation the Z passed into the transformation function is assumed to be height above ground, and the RPC_HEIGHT is assumed to be an average height above sea level for ground in the target scene.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">RPC_HEIGHT_SCALE: a factor used to multiply heights above ground. Usefull when elevation offsets of the DEM are not expressed in meters. (GDAL &gt;= 1.8.0)</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">RPC_DEM: the name of a GDAL dataset (a DEM file typically) used to extract elevation offsets from. In this situation the Z passed into the transformation function is assumed to be height above ground. This option should be used in replacement of RPC_HEIGHT to provide a way of defining a non uniform ground for the target scene (GDAL &gt;= 1.8.0)</p>
<p class="endli"></p>
</li>
<li>
RPC_DEMINTERPOLATION: the DEM interpolation (near, bilinear or cubic) </li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psRPCInfo</em>&nbsp;</td><td>Definition of the RPC parameters.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bReversed</em>&nbsp;</td><td>If true "forward" transformation will be lat/long to pixel/line instead of the normal pixel/line to lat/long.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfPixErrThreshold</em>&nbsp;</td><td>the error (measured in pixels) allowed in the iterative solution of pixel/line to lat/long computations (the other way is always exact given the equations).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>papszOptions</em>&nbsp;</td><td>Other transformer options (ie. RPC_HEIGHT=&lt;z&gt;).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>transformer callback data (deallocate with GDALDestroyTransformer()). </dd></dl>

</div>
</div>
<a class="anchor" id="a245802b88a8126c138d24febe6c9822a"></a><!-- doxytag: member="gdal_alg.h::GDALCreateTPSTransformer" ref="a245802b88a8126c138d24febe6c9822a" args="(int nGCPCount, const GDAL_GCP *pasGCPList, int bReversed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* GDALCreateTPSTransformer </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nGCPCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structGDAL__GCP.html">GDAL_GCP</a> *&nbsp;</td>
          <td class="paramname"> <em>pasGCPList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bReversed</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create Thin Plate Spline transformer from GCPs. </p>
<p>The thin plate spline transformer produces exact transformation at all control points and smoothly varying transformations between control points with greatest influence from local control points. It is suitable for for many applications not well modelled by polynomial transformations.</p>
<p>Creating the TPS transformer involves solving systems of linear equations related to the number of control points involved. This solution is computed within this function call. It can be quite an expensive operation for large numbers of GCPs. For instance, for reference, it takes on the order of 10s for 400 GCPs on a 2GHz Athlon processor.</p>
<p>TPS Transformers are serializable.</p>
<p>The GDAL Thin Plate Spline transformer is based on code provided by Gilad Ronnen on behalf of VIZRT Inc (<a href="http://www.visrt.com">http://www.visrt.com</a>). Incorporation of the algorithm into GDAL was supported by the Centro di Ecologia Alpina (<a href="http://www.cealp.it">http://www.cealp.it</a>).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nGCPCount</em>&nbsp;</td><td>the number of GCPs in pasGCPList. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pasGCPList</em>&nbsp;</td><td>an array of GCPs to be used as input. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bReversed</em>&nbsp;</td><td>set it to TRUE to compute the reversed transformation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the transform argument or NULL if creation fails. </dd></dl>

</div>
</div>
<a class="anchor" id="aa8a1fd0719f5405e856e2103b23f1d9c"></a><!-- doxytag: member="gdal_alg.h::GDALDestroyApproxTransformer" ref="aa8a1fd0719f5405e856e2103b23f1d9c" args="(void *pApproxArg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GDALDestroyApproxTransformer </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pCBData</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cleanup approximate transformer. </p>
<p>Deallocates the resources allocated by <a class="el" href="gdal__alg_8h.html#a4ec403b75384f0a71130eb009078426f" title="Create an approximating transformer.">GDALCreateApproxTransformer()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pCBData</em>&nbsp;</td><td>callback data originally returned by <a class="el" href="gdal__alg_8h.html#a4ec403b75384f0a71130eb009078426f" title="Create an approximating transformer.">GDALCreateApproxTransformer()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4b1acbe5387ac769f7fee1de93b81011"></a><!-- doxytag: member="gdal_alg.h::GDALDestroyGCPTransformer" ref="a4b1acbe5387ac769f7fee1de93b81011" args="(void *pTransformArg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GDALDestroyGCPTransformer </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pTransformArg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy GCP transformer. </p>
<p>This function is used to destroy information about a GCP based polynomial transformation created with <a class="el" href="gdal__alg_8h.html#ac57c80f7bf6752fac1dff8c2a21a15a3" title="Create GCP based polynomial transformer.">GDALCreateGCPTransformer()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pTransformArg</em>&nbsp;</td><td>the transform arg previously returned by <a class="el" href="gdal__alg_8h.html#ac57c80f7bf6752fac1dff8c2a21a15a3" title="Create GCP based polynomial transformer.">GDALCreateGCPTransformer()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5fb383c4e5197e8e37ae1265cca8124d"></a><!-- doxytag: member="gdal_alg.h::GDALDestroyGenImgProjTransformer" ref="a5fb383c4e5197e8e37ae1265cca8124d" args="(void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GDALDestroyGenImgProjTransformer </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>hTransformArg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>GenImgProjTransformer deallocator. </p>
<p>This function is used to deallocate the handle created with <a class="el" href="gdal__alg_8h.html#a7671696d085085a0bfba3c3df9ffcc0a" title="Create image to image transformer.">GDALCreateGenImgProjTransformer()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hTransformArg</em>&nbsp;</td><td>the handle to deallocate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae6cffb245df6fba275423f1333d89f08"></a><!-- doxytag: member="gdal_alg.h::GDALDestroyReprojectionTransformer" ref="ae6cffb245df6fba275423f1333d89f08" args="(void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GDALDestroyReprojectionTransformer </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pTransformArg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy reprojection transformation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pTransformArg</em>&nbsp;</td><td>the transformation handle returned by <a class="el" href="gdal__alg_8h.html#adce63548b884096e55d1685d4bbd7e63" title="Create reprojection transformer.">GDALCreateReprojectionTransformer()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afe5fccffbcc853230bc631441dc38469"></a><!-- doxytag: member="gdal_alg.h::GDALDestroyTPSTransformer" ref="afe5fccffbcc853230bc631441dc38469" args="(void *pTransformArg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GDALDestroyTPSTransformer </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pTransformArg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy TPS transformer. </p>
<p>This function is used to destroy information about a GCP based polynomial transformation created with <a class="el" href="gdal__alg_8h.html#a245802b88a8126c138d24febe6c9822a" title="Create Thin Plate Spline transformer from GCPs.">GDALCreateTPSTransformer()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pTransformArg</em>&nbsp;</td><td>the transform arg previously returned by <a class="el" href="gdal__alg_8h.html#a245802b88a8126c138d24febe6c9822a" title="Create Thin Plate Spline transformer from GCPs.">GDALCreateTPSTransformer()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a284dbcc27295b7e678b1f7d4fa1506cb"></a><!-- doxytag: member="gdal_alg.h::GDALDitherRGB2PCT" ref="a284dbcc27295b7e678b1f7d4fa1506cb" args="(GDALRasterBandH hRed, GDALRasterBandH hGreen, GDALRasterBandH hBlue, GDALRasterBandH hTarget, GDALColorTableH hColorTable, GDALProgressFunc pfnProgress, void *pProgressArg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDALDitherRGB2PCT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&nbsp;</td>
          <td class="paramname"> <em>hRed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&nbsp;</td>
          <td class="paramname"> <em>hGreen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&nbsp;</td>
          <td class="paramname"> <em>hBlue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&nbsp;</td>
          <td class="paramname"> <em>hTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#af1baae80dd0ec873ad7ad5b28dda44f3">GDALColorTableH</a>&nbsp;</td>
          <td class="paramname"> <em>hColorTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&nbsp;</td>
          <td class="paramname"> <em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pProgressArg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>24bit to 8bit conversion with dithering. </p>
<p>This functions utilizes Floyd-Steinberg dithering in the process of converting a 24bit RGB image into a pseudocolored 8bit image using a provided color table.</p>
<p>The red, green and blue input bands do not necessarily need to come from the same file, but they must be the same width and height. They will be clipped to 8bit during reading, so non-eight bit bands are generally inappropriate. Likewise the hTarget band will be written with 8bit values and must match the width and height of the source bands.</p>
<p>The color table cannot have more than 256 entries.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hRed</em>&nbsp;</td><td>Red input band. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hGreen</em>&nbsp;</td><td>Green input band. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hBlue</em>&nbsp;</td><td>Blue input band. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hTarget</em>&nbsp;</td><td>Output band. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hColorTable</em>&nbsp;</td><td>the color table to use with the output band. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnProgress</em>&nbsp;</td><td>callback for reporting algorithm progress matching the GDALProgressFunc() semantics. May be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pProgressArg</em>&nbsp;</td><td>callback argument passed to pfnProgress.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CE_None on success or CE_Failure if an error occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="a0a079afef61968f224b159d48423d1c6"></a><!-- doxytag: member="gdal_alg.h::GDALFillNodata" ref="a0a079afef61968f224b159d48423d1c6" args="(GDALRasterBandH hTargetBand, GDALRasterBandH hMaskBand, double dfMaxSearchDist, int bDeprecatedOption, int nSmoothingIterations, char **papszOptions, GDALProgressFunc pfnProgress, void *pProgressArg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPLErr GDALFillNodata </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&nbsp;</td>
          <td class="paramname"> <em>hTargetBand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&nbsp;</td>
          <td class="paramname"> <em>hMaskBand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfMaxSearchDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bDeprecatedOption</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nSmoothingIterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&nbsp;</td>
          <td class="paramname"> <em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pProgressArg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fill selected raster regions by interpolation from the edges. </p>
<p>This algorithm will interpolate values for all designated nodata pixels (marked by zeros in hMaskBand). For each pixel a four direction conic search is done to find values to interpolate from (using inverse distance weighting). Once all values are interpolated, zero or more smoothing iterations (3x3 average filters on interpolated pixels) are applied to smooth out artifacts.</p>
<p>This algorithm is generally suitable for interpolating missing regions of fairly continuously varying rasters (such as elevation models for instance). It is also suitable for filling small holes and cracks in more irregularly varying images (like airphotos). It is generally not so great for interpolating a raster from sparse point data - see the algorithms defined in gdal_grid.h for that case.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hTargetBand</em>&nbsp;</td><td>the raster band to be modified in place. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hMaskBand</em>&nbsp;</td><td>a mask band indicating pixels to be interpolated (zero valued </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfMaxSearchDist</em>&nbsp;</td><td>the maximum number of pixels to search in all directions to find values to interpolate from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bDeprecatedOption</em>&nbsp;</td><td>unused argument, should be zero. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nSmoothingIterations</em>&nbsp;</td><td>the number of 3x3 smoothing filter passes to run (0 or more). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>papszOptions</em>&nbsp;</td><td>additional name=value options in a string list (none supported at this time - just pass NULL). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnProgress</em>&nbsp;</td><td>the progress function to report completion. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pProgressArg</em>&nbsp;</td><td>callback data for progress function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CE_None on success or CE_Failure if something goes wrong. </dd></dl>

</div>
</div>
<a class="anchor" id="a7a789015334d677afcbef67e5a6b4a7c"></a><!-- doxytag: member="gdal_alg.h::GDALFPolygonize" ref="a7a789015334d677afcbef67e5a6b4a7c" args="(GDALRasterBandH hSrcBand, GDALRasterBandH hMaskBand, OGRLayerH hOutLayer, int iPixValField, char **papszOptions, GDALProgressFunc pfnProgress, void *pProgressArg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPLErr GDALFPolygonize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&nbsp;</td>
          <td class="paramname"> <em>hSrcBand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&nbsp;</td>
          <td class="paramname"> <em>hMaskBand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>hOutLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iPixValField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&nbsp;</td>
          <td class="paramname"> <em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pProgressArg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create polygon coverage from raster data. </p>
<p>This function creates vector polygons for all connected regions of pixels in the raster sharing a common pixel value. Optionally each polygon may be labelled with the pixel value in an attribute. Optionally a mask band can be provided to determine which pixels are eligible for processing.</p>
<p>The source pixel band values are read into a 32bit float buffer. If you want to use a (probably faster) version using signed 32bit integer buffer, see <a class="el" href="gdal__alg_8h.html#a3f522a9035d3512b5d414fb4752671b1" title="Create polygon coverage from raster data.">GDALPolygonize()</a> at polygonize.cpp.</p>
<p>Polygon features will be created on the output layer, with polygon geometries representing the polygons. The polygon geometries will be in the georeferenced coordinate system of the image (based on the geotransform of the source dataset). It is acceptable for the output layer to already have features. Note that <a class="el" href="gdal__alg_8h.html#a7a789015334d677afcbef67e5a6b4a7c" title="Create polygon coverage from raster data.">GDALFPolygonize()</a> does not set the coordinate system on the output layer. Application code should do this when the layer is created, presumably matching the raster coordinate system.</p>
<p>The algorithm used attempts to minimize memory use so that very large rasters can be processed. However, if the raster has many polygons or very large/complex polygons, the memory use for holding polygon enumerations and active polygon geometries may grow to be quite large.</p>
<p>The algorithm will generally produce very dense polygon geometries, with edges that follow exactly on pixel boundaries for all non-interior pixels. For non-thematic raster data (such as satellite images) the result will essentially be one small polygon per pixel, and memory and output layer sizes will be substantial. The algorithm is primarily intended for relatively simple thematic imagery, masks, and classification results.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hSrcBand</em>&nbsp;</td><td>the source raster band to be processed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hMaskBand</em>&nbsp;</td><td>an optional mask band. All pixels in the mask band with a value other than zero will be considered suitable for collection as polygons. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hOutLayer</em>&nbsp;</td><td>the vector feature layer to which the polygons should be written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iPixValField</em>&nbsp;</td><td>the attribute field index indicating the feature attribute into which the pixel value of the polygon should be written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>papszOptions</em>&nbsp;</td><td>a name/value list of additional options </p>
<dl>
<dt>"8CONNECTED": May be set to "8" to use 8 connectedness. Otherwise 4 connectedness will be applied to the algorithm </dt>
<dd></dd>
</dl>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnProgress</em>&nbsp;</td><td>callback for reporting algorithm progress matching the GDALProgressFunc() semantics. May be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pProgressArg</em>&nbsp;</td><td>callback argument passed to pfnProgress.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CE_None on success or CE_Failure on a failure.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.9.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a9acdfd7db1541c1df5e29a031994d61b"></a><!-- doxytag: member="gdal_alg.h::GDALGCPTransform" ref="a9acdfd7db1541c1df5e29a031994d61b" args="(void *pTransformArg, int bDstToSrc, int nPointCount, double *x, double *y, double *z, int *panSuccess)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDALGCPTransform </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pTransformArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bDstToSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nPointCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>panSuccess</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transforms point based on GCP derived polynomial model. </p>
<p>This function matches the GDALTransformerFunc signature, and can be used to transform one or more points from pixel/line coordinates to georeferenced coordinates (SrcToDst) or vice versa (DstToSrc).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pTransformArg</em>&nbsp;</td><td>return value from <a class="el" href="gdal__alg_8h.html#ac57c80f7bf6752fac1dff8c2a21a15a3" title="Create GCP based polynomial transformer.">GDALCreateGCPTransformer()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bDstToSrc</em>&nbsp;</td><td>TRUE if transformation is from the destination (georeferenced) coordinates to pixel/line or FALSE when transforming from pixel/line to georeferenced coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nPointCount</em>&nbsp;</td><td>the number of values in the x, y and z arrays. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>array containing the X values to be transformed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>array containing the Y values to be transformed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>z</em>&nbsp;</td><td>array containing the Z values to be transformed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>panSuccess</em>&nbsp;</td><td>array in which a flag indicating success (TRUE) or failure (FALSE) of the transformation are placed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE. </dd></dl>

</div>
</div>
<a class="anchor" id="a109c26234c2f934164e29649353532b6"></a><!-- doxytag: member="gdal_alg.h::GDALGenImgProjTransform" ref="a109c26234c2f934164e29649353532b6" args="(void *pTransformArg, int bDstToSrc, int nPointCount, double *x, double *y, double *z, int *panSuccess)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDALGenImgProjTransform </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pTransformArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bDstToSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nPointCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>padfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>padfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>padfZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>panSuccess</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform general image reprojection transformation. </p>
<p>Actually performs the transformation setup in <a class="el" href="gdal__alg_8h.html#a7671696d085085a0bfba3c3df9ffcc0a" title="Create image to image transformer.">GDALCreateGenImgProjTransformer()</a>. This function matches the signature required by the <a class="el" href="gdal__alg_8h.html#a7df61123fec15deb3da3acabce19e647">GDALTransformerFunc()</a>, and more details on the arguments can be found in that topic. </p>

</div>
</div>
<a class="anchor" id="a1fdef40bcdbc98eff2328b0d093d3a22"></a><!-- doxytag: member="gdal_alg.h::GDALGridCreate" ref="a1fdef40bcdbc98eff2328b0d093d3a22" args="(GDALGridAlgorithm, const void *, GUInt32, const double *, const double *, const double *, double, double, double, double, GUInt32, GUInt32, GDALDataType, void *, GDALProgressFunc, void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPLErr GDALGridCreate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal__alg_8h.html#a590d1a2d0bac1d34b95034c1f616de21">GDALGridAlgorithm</a>&nbsp;</td>
          <td class="paramname"> <em>eAlgorithm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>poOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GUInt32&nbsp;</td>
          <td class="paramname"> <em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>padfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>padfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>padfZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfXMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfXMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfYMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfYMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GUInt32&nbsp;</td>
          <td class="paramname"> <em>nXSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GUInt32&nbsp;</td>
          <td class="paramname"> <em>nYSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#a22e22ce0a55036a96f652765793fb7a4">GDALDataType</a>&nbsp;</td>
          <td class="paramname"> <em>eType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&nbsp;</td>
          <td class="paramname"> <em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pProgressArg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create regular grid from the scattered data. </p>
<p>This function takes the arrays of X and Y coordinates and corresponding Z values as input and computes regular grid (or call it a raster) from these scattered data. You should supply geometry and extent of the output grid and allocate array sufficient to hold such a grid.</p>
<p>Starting with GDAL 1.10, it is possible to set the GDAL_NUM_THREADS configuration option to parallelize the processing. The value to set is the number of worker threads, or ALL_CPUS to use all the cores/CPUs of the computer (default value).</p>
<p>Starting with GDAL 1.10, on Intel/AMD i386/x86_64 architectures, some gridding methods will be optimized with SSE instructions (provided GDAL has been compiled with such support, and it is availabable at runtime). Currently, only 'invdist' algorithm with default parameters has an optimized implementation. This can provide substantial speed-up, but sometimes at the expense of reduced floating point precision. This can be disabled by setting the GDAL_USE_SSE configuration option to NO. Starting with GDAL 1.11, a further optimized version can use the AVX instruction set. This can be disabled by setting the GDAL_USE_AVX configuration option to NO.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>eAlgorithm</em>&nbsp;</td><td>Gridding method. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>poOptions</em>&nbsp;</td><td>Options to control choosen gridding method. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nPoints</em>&nbsp;</td><td>Number of elements in input arrays. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfX</em>&nbsp;</td><td>Input array of X coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfY</em>&nbsp;</td><td>Input array of Y coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfZ</em>&nbsp;</td><td>Input array of Z values. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfXMin</em>&nbsp;</td><td>Lowest X border of output grid. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfXMax</em>&nbsp;</td><td>Highest X border of output grid. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfYMin</em>&nbsp;</td><td>Lowest Y border of output grid. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfYMax</em>&nbsp;</td><td>Highest Y border of output grid. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nXSize</em>&nbsp;</td><td>Number of columns in output grid. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nYSize</em>&nbsp;</td><td>Number of rows in output grid. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eType</em>&nbsp;</td><td>Data type of output array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pData</em>&nbsp;</td><td>Pointer to array where the computed grid will be stored. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnProgress</em>&nbsp;</td><td>a GDALProgressFunc() compatible callback function for reporting progress or NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pProgressArg</em>&nbsp;</td><td>argument to be passed to pfnProgress. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CE_None on success or CE_Failure if something goes wrong. </dd></dl>

</div>
</div>
<a class="anchor" id="a3f522a9035d3512b5d414fb4752671b1"></a><!-- doxytag: member="gdal_alg.h::GDALPolygonize" ref="a3f522a9035d3512b5d414fb4752671b1" args="(GDALRasterBandH hSrcBand, GDALRasterBandH hMaskBand, OGRLayerH hOutLayer, int iPixValField, char **papszOptions, GDALProgressFunc pfnProgress, void *pProgressArg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPLErr GDALPolygonize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&nbsp;</td>
          <td class="paramname"> <em>hSrcBand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&nbsp;</td>
          <td class="paramname"> <em>hMaskBand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>hOutLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iPixValField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&nbsp;</td>
          <td class="paramname"> <em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pProgressArg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create polygon coverage from raster data. </p>
<p>This function creates vector polygons for all connected regions of pixels in the raster sharing a common pixel value. Optionally each polygon may be labelled with the pixel value in an attribute. Optionally a mask band can be provided to determine which pixels are eligible for processing.</p>
<p>Note that currently the source pixel band values are read into a signed 32bit integer buffer (Int32), so floating point or complex bands will be implicitly truncated before processing. If you want to use a version using 32bit float buffers, see <a class="el" href="gdal__alg_8h.html#a7a789015334d677afcbef67e5a6b4a7c" title="Create polygon coverage from raster data.">GDALFPolygonize()</a> at fpolygonize.cpp.</p>
<p>Polygon features will be created on the output layer, with polygon geometries representing the polygons. The polygon geometries will be in the georeferenced coordinate system of the image (based on the geotransform of the source dataset). It is acceptable for the output layer to already have features. Note that <a class="el" href="gdal__alg_8h.html#a3f522a9035d3512b5d414fb4752671b1" title="Create polygon coverage from raster data.">GDALPolygonize()</a> does not set the coordinate system on the output layer. Application code should do this when the layer is created, presumably matching the raster coordinate system.</p>
<p>The algorithm used attempts to minimize memory use so that very large rasters can be processed. However, if the raster has many polygons or very large/complex polygons, the memory use for holding polygon enumerations and active polygon geometries may grow to be quite large.</p>
<p>The algorithm will generally produce very dense polygon geometries, with edges that follow exactly on pixel boundaries for all non-interior pixels. For non-thematic raster data (such as satellite images) the result will essentially be one small polygon per pixel, and memory and output layer sizes will be substantial. The algorithm is primarily intended for relatively simple thematic imagery, masks, and classification results.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hSrcBand</em>&nbsp;</td><td>the source raster band to be processed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hMaskBand</em>&nbsp;</td><td>an optional mask band. All pixels in the mask band with a value other than zero will be considered suitable for collection as polygons. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hOutLayer</em>&nbsp;</td><td>the vector feature layer to which the polygons should be written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iPixValField</em>&nbsp;</td><td>the attribute field index indicating the feature attribute into which the pixel value of the polygon should be written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>papszOptions</em>&nbsp;</td><td>a name/value list of additional options </p>
<dl>
<dt>"8CONNECTED": May be set to "8" to use 8 connectedness. Otherwise 4 connectedness will be applied to the algorithm </dt>
<dd></dd>
</dl>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnProgress</em>&nbsp;</td><td>callback for reporting algorithm progress matching the GDALProgressFunc() semantics. May be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pProgressArg</em>&nbsp;</td><td>callback argument passed to pfnProgress.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CE_None on success or CE_Failure on a failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a50caf4bc34703f0bcf515ecbe5061a0a"></a><!-- doxytag: member="gdal_alg.h::GDALRasterizeGeometries" ref="a50caf4bc34703f0bcf515ecbe5061a0a" args="(GDALDatasetH hDS, int nBandCount, int *panBandList, int nGeomCount, OGRGeometryH *pahGeometries, GDALTransformerFunc pfnTransformer, void *pTransformArg, double *padfGeomBurnValue, char **papszOptions, GDALProgressFunc pfnProgress, void *pProgressArg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPLErr GDALRasterizeGeometries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a>&nbsp;</td>
          <td class="paramname"> <em>hDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nBandCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>panBandList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nGeomCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRGeometryH *&nbsp;</td>
          <td class="paramname"> <em>pahGeometries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal__alg_8h.html#a7df61123fec15deb3da3acabce19e647">GDALTransformerFunc</a>&nbsp;</td>
          <td class="paramname"> <em>pfnTransformer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pTransformArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>padfGeomBurnValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&nbsp;</td>
          <td class="paramname"> <em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pProgressArg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Burn geometries into raster. </p>
<p>Rasterize a list of geometric objects into a raster dataset. The geometries are passed as an array of OGRGeometryH handlers.</p>
<p>If the geometries are in the georferenced coordinates of the raster dataset, then the pfnTransform may be passed in NULL and one will be derived internally from the geotransform of the dataset. The transform needs to transform the geometry locations into pixel/line coordinates on the raster dataset.</p>
<p>The output raster may be of any GDAL supported datatype, though currently internally the burning is done either as GDT_Byte or GDT_Float32. This may be improved in the future. An explicit list of burn values for each geometry for each band must be passed in.</p>
<p>The papszOption list of options currently only supports one option. The "ALL_TOUCHED" option may be enabled by setting it to "TRUE".</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDS</em>&nbsp;</td><td>output data, must be opened in update mode. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nBandCount</em>&nbsp;</td><td>the number of bands to be updated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>panBandList</em>&nbsp;</td><td>the list of bands to be updated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nGeomCount</em>&nbsp;</td><td>the number of geometries being passed in pahGeometries. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pahGeometries</em>&nbsp;</td><td>the array of geometries to burn in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnTransformer</em>&nbsp;</td><td>transformation to apply to geometries to put into pixel/line coordinates on raster. If NULL a geotransform based one will be created internally. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pTransformArg</em>&nbsp;</td><td>callback data for transformer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfGeomBurnValue</em>&nbsp;</td><td>the array of values to burn into the raster. There should be nBandCount values for each geometry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>papszOptions</em>&nbsp;</td><td>special options controlling rasterization </p>
<dl>
<dt>"ALL_TOUCHED": </dt>
<dd>May be set to TRUE to set all pixels touched by the line or polygons, not just those whose center is within the polygon or that are selected by brezenhams line algorithm. Defaults to FALSE. </dd>
<dt>"BURN_VALUE_FROM": </dt>
<dd>May be set to "Z" to use the Z values of the geometries. dfBurnValue is added to this before burning. Defaults to GDALBurnValueSrc.GBV_UserBurnValue in which case just the dfBurnValue is burned. This is implemented only for points and lines for now. The M value may be supported in the future. </dd>
<dt>"MERGE_ALG": </dt>
<dd>May be REPLACE (the default) or ADD. REPLACE results in overwriting of value, while ADD adds the new value to the existing raster, suitable for heatmaps for instance. </dd>
</dl>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnProgress</em>&nbsp;</td><td>the progress function to report completion. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pProgressArg</em>&nbsp;</td><td>callback data for progress function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CE_None on success or CE_Failure on error. </dd></dl>

</div>
</div>
<a class="anchor" id="adfe5e5d287d6c184aab03acbfa567cb1"></a><!-- doxytag: member="gdal_alg.h::GDALRasterizeLayers" ref="adfe5e5d287d6c184aab03acbfa567cb1" args="(GDALDatasetH hDS, int nBandCount, int *panBandList, int nLayerCount, OGRLayerH *pahLayers, GDALTransformerFunc pfnTransformer, void *pTransformArg, double *padfLayerBurnValues, char **papszOptions, GDALProgressFunc pfnProgress, void *pProgressArg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPLErr GDALRasterizeLayers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a>&nbsp;</td>
          <td class="paramname"> <em>hDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nBandCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>panBandList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nLayerCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRLayerH *&nbsp;</td>
          <td class="paramname"> <em>pahLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal__alg_8h.html#a7df61123fec15deb3da3acabce19e647">GDALTransformerFunc</a>&nbsp;</td>
          <td class="paramname"> <em>pfnTransformer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pTransformArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>padfLayerBurnValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&nbsp;</td>
          <td class="paramname"> <em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pProgressArg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Burn geometries from the specified list of layers into raster. </p>
<p>Rasterize all the geometric objects from a list of layers into a raster dataset. The layers are passed as an array of OGRLayerH handlers.</p>
<p>If the geometries are in the georferenced coordinates of the raster dataset, then the pfnTransform may be passed in NULL and one will be derived internally from the geotransform of the dataset. The transform needs to transform the geometry locations into pixel/line coordinates on the raster dataset.</p>
<p>The output raster may be of any GDAL supported datatype, though currently internally the burning is done either as GDT_Byte or GDT_Float32. This may be improved in the future. An explicit list of burn values for each layer for each band must be passed in.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDS</em>&nbsp;</td><td>output data, must be opened in update mode. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nBandCount</em>&nbsp;</td><td>the number of bands to be updated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>panBandList</em>&nbsp;</td><td>the list of bands to be updated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nLayerCount</em>&nbsp;</td><td>the number of layers being passed in pahLayers array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pahLayers</em>&nbsp;</td><td>the array of layers to burn in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnTransformer</em>&nbsp;</td><td>transformation to apply to geometries to put into pixel/line coordinates on raster. If NULL a geotransform based one will be created internally. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pTransformArg</em>&nbsp;</td><td>callback data for transformer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfLayerBurnValues</em>&nbsp;</td><td>the array of values to burn into the raster. There should be nBandCount values for each layer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>papszOptions</em>&nbsp;</td><td>special options controlling rasterization: </p>
<dl>
<dt>"ATTRIBUTE": </dt>
<dd>Identifies an attribute field on the features to be used for a burn in value. The value will be burned into all output bands. If specified, padfLayerBurnValues will not be used and can be a NULL pointer. </dd>
<dt>"CHUNKYSIZE": </dt>
<dd>The height in lines of the chunk to operate on. The larger the chunk size the less times we need to make a pass through all the shapes. If it is not set or set to zero the default chunk size will be used. Default size will be estimated based on the GDAL cache buffer size using formula: cache_size_bytes/scanline_size_bytes, so the chunk will not exceed the cache. </dd>
<dt>"ALL_TOUCHED": </dt>
<dd>May be set to TRUE to set all pixels touched by the line or polygons, not just those whose center is within the polygon or that are selected by brezenhams line algorithm. Defaults to FALSE. </dd>
<dt>"BURN_VALUE_FROM": </dt>
<dd>May be set to "Z" to use the Z values of the geometries. The value from padfLayerBurnValues or the attribute field value is added to this before burning. In default case dfBurnValue is burned as it is. This is implemented properly only for points and lines for now. Polygons will be burned using the Z value from the first point. The M value may be supported in the future. </dd>
<dt>"MERGE_ALG": </dt>
<dd>May be REPLACE (the default) or ADD. REPLACE results in overwriting of value, while ADD adds the new value to the existing raster, suitable for heatmaps for instance. </dd>
</dl>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnProgress</em>&nbsp;</td><td>the progress function to report completion. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pProgressArg</em>&nbsp;</td><td>callback data for progress function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CE_None on success or CE_Failure on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ab791949af233e16c119e4f49ee573cae"></a><!-- doxytag: member="gdal_alg.h::GDALRasterizeLayersBuf" ref="ab791949af233e16c119e4f49ee573cae" args="(void *pData, int nBufXSize, int nBufYSize, GDALDataType eBufType, int nPixelSpace, int nLineSpace, int nLayerCount, OGRLayerH *pahLayers, const char *pszDstProjection, double *padfDstGeoTransform, GDALTransformerFunc pfnTransformer, void *pTransformArg, double dfBurnValue, char **papszOptions, GDALProgressFunc pfnProgress, void *pProgressArg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPLErr GDALRasterizeLayersBuf </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nBufXSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nBufYSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#a22e22ce0a55036a96f652765793fb7a4">GDALDataType</a>&nbsp;</td>
          <td class="paramname"> <em>eBufType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nPixelSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nLineSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nLayerCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRLayerH *&nbsp;</td>
          <td class="paramname"> <em>pahLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszDstProjection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>padfDstGeoTransform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal__alg_8h.html#a7df61123fec15deb3da3acabce19e647">GDALTransformerFunc</a>&nbsp;</td>
          <td class="paramname"> <em>pfnTransformer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pTransformArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfBurnValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&nbsp;</td>
          <td class="paramname"> <em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pProgressArg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Burn geometries from the specified list of layer into raster. </p>
<p>Rasterize all the geometric objects from a list of layers into supplied raster buffer. The layers are passed as an array of OGRLayerH handlers.</p>
<p>If the geometries are in the georferenced coordinates of the raster dataset, then the pfnTransform may be passed in NULL and one will be derived internally from the geotransform of the dataset. The transform needs to transform the geometry locations into pixel/line coordinates of the target raster.</p>
<p>The output raster may be of any GDAL supported datatype, though currently internally the burning is done either as GDT_Byte or GDT_Float32. This may be improved in the future.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pData</em>&nbsp;</td><td>pointer to the output data array.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nBufXSize</em>&nbsp;</td><td>width of the output data array in pixels.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nBufYSize</em>&nbsp;</td><td>height of the output data array in pixels.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eBufType</em>&nbsp;</td><td>data type of the output data array.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nPixelSpace</em>&nbsp;</td><td>The byte offset from the start of one pixel value in pData to the start of the next pixel value within a scanline. If defaulted (0) the size of the datatype eBufType is used.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nLineSpace</em>&nbsp;</td><td>The byte offset from the start of one scanline in pData to the start of the next. If defaulted the size of the datatype eBufType * nBufXSize is used.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nLayerCount</em>&nbsp;</td><td>the number of layers being passed in pahLayers array.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pahLayers</em>&nbsp;</td><td>the array of layers to burn in.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszDstProjection</em>&nbsp;</td><td>WKT defining the coordinate system of the target raster.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfDstGeoTransform</em>&nbsp;</td><td>geotransformation matrix of the target raster.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnTransformer</em>&nbsp;</td><td>transformation to apply to geometries to put into pixel/line coordinates on raster. If NULL a geotransform based one will be created internally.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pTransformArg</em>&nbsp;</td><td>callback data for transformer.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfBurnValue</em>&nbsp;</td><td>the value to burn into the raster.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>papszOptions</em>&nbsp;</td><td>special options controlling rasterization: </p>
<dl>
<dt>"ATTRIBUTE": </dt>
<dd>Identifies an attribute field on the features to be used for a burn in value. The value will be burned into all output bands. If specified, padfLayerBurnValues will not be used and can be a NULL pointer. </dd>
<dt>"ALL_TOUCHED": </dt>
<dd>May be set to TRUE to set all pixels touched by the line or polygons, not just those whose center is within the polygon or that are selected by brezenhams line algorithm. Defaults to FALSE. </dd>
</dl>
</td></tr>
  </table>
  </dd>
</dl>
<p>"BURN_VALUE_FROM": May be set to "Z" to use the Z values of the geometries. dfBurnValue or the attribute field value is added to this before burning. In default case dfBurnValue is burned as it is. This is implemented properly only for points and lines for now. Polygons will be burned using the Z value from the first point. The M value may be supported in the future. </p>
<p>"MERGE_ALG": May be REPLACE (the default) or ADD. REPLACE results in overwriting of value, while ADD adds the new value to the existing raster, suitable for heatmaps for instance. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pfnProgress</em>&nbsp;</td><td>the progress function to report completion.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pProgressArg</em>&nbsp;</td><td>callback data for progress function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CE_None on success or CE_Failure on error. </dd></dl>

</div>
</div>
<a class="anchor" id="af00f74e03c57842b359130ca73857521"></a><!-- doxytag: member="gdal_alg.h::GDALReprojectionTransform" ref="af00f74e03c57842b359130ca73857521" args="(void *pTransformArg, int bDstToSrc, int nPointCount, double *x, double *y, double *z, int *panSuccess)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDALReprojectionTransform </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pTransformArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bDstToSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nPointCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>padfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>padfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>padfZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>panSuccess</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform reprojection transformation. </p>
<p>Actually performs the reprojection transformation described in <a class="el" href="gdal__alg_8h.html#adce63548b884096e55d1685d4bbd7e63" title="Create reprojection transformer.">GDALCreateReprojectionTransformer()</a>. This function matches the <a class="el" href="gdal__alg_8h.html#a7df61123fec15deb3da3acabce19e647">GDALTransformerFunc()</a> signature. Details of the arguments are described there. </p>

</div>
</div>
<a class="anchor" id="a18e841864cf6d93596626981d26c3000"></a><!-- doxytag: member="gdal_alg.h::GDALSetGenImgProjTransformerDstGeoTransform" ref="a18e841864cf6d93596626981d26c3000" args="(void *, const double *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GDALSetGenImgProjTransformerDstGeoTransform </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>hTransformArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>padfGeoTransform</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set GenImgProj output geotransform. </p>
<p>Normally the "destination geotransform", or transformation between georeferenced output coordinates and pixel/line coordinates on the destination file is extracted from the destination file by <a class="el" href="gdal__alg_8h.html#a7671696d085085a0bfba3c3df9ffcc0a" title="Create image to image transformer.">GDALCreateGenImgProjTransformer()</a> and stored in the GenImgProj private info. However, sometimes it is inconvenient to have an output file handle with appropriate geotransform information when creating the transformation. For these cases, this function can be used to apply the destination geotransform.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hTransformArg</em>&nbsp;</td><td>the handle to update. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfGeoTransform</em>&nbsp;</td><td>the destination geotransform to apply (six doubles). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a33309c0a316b223bd33ae5753cc7f616"></a><!-- doxytag: member="gdal_alg.h::GDALSieveFilter" ref="a33309c0a316b223bd33ae5753cc7f616" args="(GDALRasterBandH hSrcBand, GDALRasterBandH hMaskBand, GDALRasterBandH hDstBand, int nSizeThreshold, int nConnectedness, char **papszOptions, GDALProgressFunc pfnProgress, void *pProgressArg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPLErr GDALSieveFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&nbsp;</td>
          <td class="paramname"> <em>hSrcBand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&nbsp;</td>
          <td class="paramname"> <em>hMaskBand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&nbsp;</td>
          <td class="paramname"> <em>hDstBand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nSizeThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nConnectedness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&nbsp;</td>
          <td class="paramname"> <em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pProgressArg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes small raster polygons. </p>
<p>The function removes raster polygons smaller than a provided threshold size (in pixels) and replaces replaces them with the pixel value of the largest neighbour polygon.</p>
<p>Polygon are determined (per <a class="el" href="classGDALRasterPolygonEnumerator.html">GDALRasterPolygonEnumerator</a>) as regions of the raster where the pixels all have the same value, and that are contiguous (connected).</p>
<p>Pixels determined to be "nodata" per hMaskBand will not be treated as part of a polygon regardless of their pixel values. Nodata areas will never be changed nor affect polygon sizes.</p>
<p>Polygons smaller than the threshold with no neighbours that are as large as the threshold will not be altered. Polygons surrounded by nodata areas will therefore not be altered.</p>
<p>The algorithm makes three passes over the input file to enumerate the polygons and collect limited information about them. Memory use is proportional to the number of polygons (roughly 24 bytes per polygon), but is not directly related to the size of the raster. So very large raster files can be processed effectively if there aren't too many polygons. But extremely noisy rasters with many one pixel polygons will end up being expensive (in memory) to process.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hSrcBand</em>&nbsp;</td><td>the source raster band to be processed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hMaskBand</em>&nbsp;</td><td>an optional mask band. All pixels in the mask band with a value other than zero will be considered suitable for inclusion in polygons. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hDstBand</em>&nbsp;</td><td>the output raster band. It may be the same as hSrcBand to update the source in place. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nSizeThreshold</em>&nbsp;</td><td>raster polygons with sizes smaller than this will be merged into their largest neighbour. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nConnectedness</em>&nbsp;</td><td>either 4 indicating that diagonal pixels are not considered directly adjacent for polygon membership purposes or 8 indicating they are. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>papszOptions</em>&nbsp;</td><td>algorithm options in name=value list form. None currently supported. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnProgress</em>&nbsp;</td><td>callback for reporting algorithm progress matching the GDALProgressFunc() semantics. May be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pProgressArg</em>&nbsp;</td><td>callback argument passed to pfnProgress.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CE_None on success or CE_Failure if an error occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="ae15910acb317cef94f3fd49dca6e4bab"></a><!-- doxytag: member="gdal_alg.h::GDALSimpleImageWarp" ref="ae15910acb317cef94f3fd49dca6e4bab" args="(GDALDatasetH hSrcDS, GDALDatasetH hDstDS, int nBandCount, int *panBandList, GDALTransformerFunc pfnTransform, void *pTransformArg, GDALProgressFunc pfnProgress, void *pProgressArg, char **papszWarpOptions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDALSimpleImageWarp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a>&nbsp;</td>
          <td class="paramname"> <em>hSrcDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a>&nbsp;</td>
          <td class="paramname"> <em>hDstDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nBandCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>panBandList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal__alg_8h.html#a7df61123fec15deb3da3acabce19e647">GDALTransformerFunc</a>&nbsp;</td>
          <td class="paramname"> <em>pfnTransform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pTransformArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&nbsp;</td>
          <td class="paramname"> <em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pProgressArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszWarpOptions</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform simple image warp. </p>
<p>Copies an image from a source dataset to a destination dataset applying an application defined transformation. This algorithm is called simple because it lacks many options such as resampling kernels (other than nearest neighbour), support for data types other than 8bit, and the ability to warp images without holding the entire source and destination image in memory.</p>
<p>The following option(s) may be passed in papszWarpOptions. </p>
<ul>
<li>
"INIT=v[,v...]": This option indicates that the output dataset should be initialized to the indicated value in any area valid data is not written. Distinct values may be listed for each band separated by columns. </li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hSrcDS</em>&nbsp;</td><td>the source image dataset. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hDstDS</em>&nbsp;</td><td>the destination image dataset. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nBandCount</em>&nbsp;</td><td>the number of bands to be warped. If zero, all bands will be processed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>panBandList</em>&nbsp;</td><td>the list of bands to translate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnTransform</em>&nbsp;</td><td>the transformation function to call. See <a class="el" href="gdal__alg_8h.html#a7df61123fec15deb3da3acabce19e647">GDALTransformerFunc()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pTransformArg</em>&nbsp;</td><td>the callback handle to pass to pfnTransform. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnProgress</em>&nbsp;</td><td>the function used to report progress. See GDALProgressFunc(). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pProgressArg</em>&nbsp;</td><td>the callback handle to pass to pfnProgress. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>papszWarpOptions</em>&nbsp;</td><td>additional options controlling the warp.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the operation completes, or FALSE if an error occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="a816819e7495bfce06dbd110f7c57af65"></a><!-- doxytag: member="gdal_alg.h::GDALSuggestedWarpOutput" ref="a816819e7495bfce06dbd110f7c57af65" args="(GDALDatasetH hSrcDS, GDALTransformerFunc pfnTransformer, void *pTransformArg, double *padfGeoTransformOut, int *pnPixels, int *pnLines)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPLErr GDALSuggestedWarpOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a>&nbsp;</td>
          <td class="paramname"> <em>hSrcDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal__alg_8h.html#a7df61123fec15deb3da3acabce19e647">GDALTransformerFunc</a>&nbsp;</td>
          <td class="paramname"> <em>pfnTransformer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pTransformArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>padfGeoTransformOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pnPixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pnLines</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Suggest output file size. </p>
<p>This function is used to suggest the size, and georeferenced extents appropriate given the indicated transformation and input file. It walks the edges of the input file (approximately 20 sample points along each edge) transforming into output coordinates in order to get an extents box.</p>
<p>Then a resolution is computed with the intent that the length of the distance from the top left corner of the output imagery to the bottom right corner would represent the same number of pixels as in the source image. Note that if the image is somewhat rotated the diagonal taken isnt of the whole output bounding rectangle, but instead of the locations where the top/left and bottom/right corners transform. The output pixel size is always square. This is intended to approximately preserve the resolution of the input data in the output file.</p>
<p>The values returned in padfGeoTransformOut, pnPixels and pnLines are the suggested number of pixels and lines for the output file, and the geotransform relating those pixels to the output georeferenced coordinates.</p>
<p>The trickiest part of using the function is ensuring that the transformer created is from source file pixel/line coordinates to output file georeferenced coordinates. This can be accomplished with <a class="el" href="gdal__alg_8h.html#a7671696d085085a0bfba3c3df9ffcc0a" title="Create image to image transformer.">GDALCreateGenImgProjTransformer()</a> by passing a NULL for the hDstDS.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hSrcDS</em>&nbsp;</td><td>the input image (it is assumed the whole input images is being transformed). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnTransformer</em>&nbsp;</td><td>the transformer function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pTransformArg</em>&nbsp;</td><td>the callback data for the transformer function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfGeoTransformOut</em>&nbsp;</td><td>the array of six doubles in which the suggested geotransform is returned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnPixels</em>&nbsp;</td><td>int in which the suggest pixel width of output is returned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnLines</em>&nbsp;</td><td>int in which the suggest pixel height of output is returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CE_None if successful or CE_Failure otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a8ae26881b86e42ff958a8e81c4976fb3"></a><!-- doxytag: member="gdal_alg.h::GDALSuggestedWarpOutput2" ref="a8ae26881b86e42ff958a8e81c4976fb3" args="(GDALDatasetH hSrcDS, GDALTransformerFunc pfnTransformer, void *pTransformArg, double *padfGeoTransformOut, int *pnPixels, int *pnLines, double *padfExtents, int nOptions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPLErr GDALSuggestedWarpOutput2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a>&nbsp;</td>
          <td class="paramname"> <em>hSrcDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal__alg_8h.html#a7df61123fec15deb3da3acabce19e647">GDALTransformerFunc</a>&nbsp;</td>
          <td class="paramname"> <em>pfnTransformer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pTransformArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>padfGeoTransformOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pnPixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pnLines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>padfExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nOptions</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Suggest output file size. </p>
<p>This function is used to suggest the size, and georeferenced extents appropriate given the indicated transformation and input file. It walks the edges of the input file (approximately 20 sample points along each edge) transforming into output coordinates in order to get an extents box.</p>
<p>Then a resolution is computed with the intent that the length of the distance from the top left corner of the output imagery to the bottom right corner would represent the same number of pixels as in the source image. Note that if the image is somewhat rotated the diagonal taken isnt of the whole output bounding rectangle, but instead of the locations where the top/left and bottom/right corners transform. The output pixel size is always square. This is intended to approximately preserve the resolution of the input data in the output file.</p>
<p>The values returned in padfGeoTransformOut, pnPixels and pnLines are the suggested number of pixels and lines for the output file, and the geotransform relating those pixels to the output georeferenced coordinates.</p>
<p>The trickiest part of using the function is ensuring that the transformer created is from source file pixel/line coordinates to output file georeferenced coordinates. This can be accomplished with <a class="el" href="gdal__alg_8h.html#a7671696d085085a0bfba3c3df9ffcc0a" title="Create image to image transformer.">GDALCreateGenImgProjTransformer()</a> by passing a NULL for the hDstDS.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hSrcDS</em>&nbsp;</td><td>the input image (it is assumed the whole input images is being transformed). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnTransformer</em>&nbsp;</td><td>the transformer function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pTransformArg</em>&nbsp;</td><td>the callback data for the transformer function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfGeoTransformOut</em>&nbsp;</td><td>the array of six doubles in which the suggested geotransform is returned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnPixels</em>&nbsp;</td><td>int in which the suggest pixel width of output is returned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnLines</em>&nbsp;</td><td>int in which the suggest pixel height of output is returned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfExtent</em>&nbsp;</td><td>Four entry array to return extents as (xmin, ymin, xmax, ymax). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nOptions</em>&nbsp;</td><td>Options, currently always zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CE_None if successful or CE_Failure otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ab8ba2028a33f1f4eede6fc05ded7cbd6"></a><!-- doxytag: member="gdal_alg.h::GDALTPSTransform" ref="ab8ba2028a33f1f4eede6fc05ded7cbd6" args="(void *pTransformArg, int bDstToSrc, int nPointCount, double *x, double *y, double *z, int *panSuccess)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GDALTPSTransform </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pTransformArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bDstToSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nPointCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>panSuccess</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transforms point based on GCP derived polynomial model. </p>
<p>This function matches the GDALTransformerFunc signature, and can be used to transform one or more points from pixel/line coordinates to georeferenced coordinates (SrcToDst) or vice versa (DstToSrc).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pTransformArg</em>&nbsp;</td><td>return value from <a class="el" href="gdal__alg_8h.html#a245802b88a8126c138d24febe6c9822a" title="Create Thin Plate Spline transformer from GCPs.">GDALCreateTPSTransformer()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bDstToSrc</em>&nbsp;</td><td>TRUE if transformation is from the destination (georeferenced) coordinates to pixel/line or FALSE when transforming from pixel/line to georeferenced coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nPointCount</em>&nbsp;</td><td>the number of values in the x, y and z arrays. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>array containing the X values to be transformed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>array containing the Y values to be transformed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>z</em>&nbsp;</td><td>array containing the Z values to be transformed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>panSuccess</em>&nbsp;</td><td>array in which a flag indicating success (TRUE) or failure (FALSE) of the transformation are placed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE. </dd></dl>

</div>
</div>
<a class="anchor" id="a89ce288fe21fe395fc93c0026419f494"></a><!-- doxytag: member="gdal_alg.h::GDALTransformGeolocations" ref="a89ce288fe21fe395fc93c0026419f494" args="(GDALRasterBandH hXBand, GDALRasterBandH hYBand, GDALRasterBandH hZBand, GDALTransformerFunc pfnTransformer, void *pTransformArg, GDALProgressFunc pfnProgress, void *pProgressArg, char **papszOptions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPLErr GDALTransformGeolocations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&nbsp;</td>
          <td class="paramname"> <em>hXBand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&nbsp;</td>
          <td class="paramname"> <em>hYBand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#aeef8194c3ad5f1ed6ca27ea4cce24685">GDALRasterBandH</a>&nbsp;</td>
          <td class="paramname"> <em>hZBand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal__alg_8h.html#a7df61123fec15deb3da3acabce19e647">GDALTransformerFunc</a>&nbsp;</td>
          <td class="paramname"> <em>pfnTransformer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pTransformArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&nbsp;</td>
          <td class="paramname"> <em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pProgressArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszOptions</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transform locations held in bands. </p>
<p>The X/Y and possibly Z values in the identified bands are transformed using a spatial transformer. The changes values are written back to the source bands so they need to updatable.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hXBand</em>&nbsp;</td><td>the band containing the X locations (usually long/easting). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hYBand</em>&nbsp;</td><td>the band containing the Y locations (usually lat/northing). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hZBand</em>&nbsp;</td><td>the band containing the Z locations (may be NULL). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnTransformer</em>&nbsp;</td><td>the transformer function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pTransformArg</em>&nbsp;</td><td>the callback data for the transformer function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnProgress</em>&nbsp;</td><td>callback for reporting algorithm progress matching the GDALProgressFunc() semantics. May be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pProgressArg</em>&nbsp;</td><td>callback argument passed to pfnProgress. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>papszOptions</em>&nbsp;</td><td>list of name/value options - none currently supported.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CE_None on success or CE_Failure if an error occurs. </dd></dl>

</div>
</div>
</div>
<hr>

Generated for GDAL by 
<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.7.1.
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>GDAL: cpl_conv.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>cpl_conv.h File Reference</h1>  </div>
</div>
<div class="contents">

<p>Various convenience functions for CPL.  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="cpl__port_8h_source.html">cpl_port.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="cpl__vsi_8h_source.html">cpl_vsi.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="cpl__error_8h_source.html">cpl_error.h</a>&quot;</code><br/>

<p><a href="cpl__conv_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCPLSharedFileInfo.html">CPLSharedFileInfo</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLLocaleC.html">CPLLocaleC</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21b7f312da39ddb0a12bdde06b153b48"></a><!-- doxytag: member="cpl_conv.h::CPLFree" ref="a21b7f312da39ddb0a12bdde06b153b48" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>CPLFree</b>&nbsp;&nbsp;&nbsp;VSIFree</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28f1ffd520d1c704e2ca4cfe9b514b81"></a><!-- doxytag: member="cpl_conv.h::CPL_ZIP_API_OFFERED" ref="a28f1ffd520d1c704e2ca4cfe9b514b81" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>CPL_ZIP_API_OFFERED</b></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6f974fbf2abefc9be05ad2c569dad27"></a><!-- doxytag: member="cpl_conv.h::CPLFileFinder" ref="ad6f974fbf2abefc9be05ad2c569dad27" args=")(const char *, const char *)" -->
typedef const char *(*&nbsp;</td><td class="memItemRight" valign="bottom"><b>CPLFileFinder</b> )(const char *, const char *)</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b137c39b2fb50df0629d4eb37a53971"></a><!-- doxytag: member="cpl_conv.h::CPLVerifyConfiguration" ref="a5b137c39b2fb50df0629d4eb37a53971" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>CPLVerifyConfiguration</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a21a509890bf6632f1b1d836c1d3bb970">CPLGetConfigOption</a> (const char *, const char *) CPL_WARN_UNUSED_RESULT</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the value of a configuration option.  <a href="#a21a509890bf6632f1b1d836c1d3bb970"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#aa0cd1a68fe4f2fc7874cd2da605c36ce">CPLSetConfigOption</a> (const char *, const char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a configuration option for GDAL/OGR use.  <a href="#aa0cd1a68fe4f2fc7874cd2da605c36ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#ac8f0d1de8f2b2069c6ea9352ca4442cd">CPLSetThreadLocalConfigOption</a> (const char *pszKey, const char *pszValue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a configuration option for GDAL/OGR use.  <a href="#ac8f0d1de8f2b2069c6ea9352ca4442cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a694fe05b1bececde022a2f182a357e0d"></a><!-- doxytag: member="cpl_conv.h::CPLFreeConfig" ref="a694fe05b1bececde022a2f182a357e0d" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>CPLFreeConfig</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a9a806de98fbddb1337efdb18651aa0f7">CPLMalloc</a> (size_t) CPL_WARN_UNUSED_RESULT</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Safe version of malloc().  <a href="#a9a806de98fbddb1337efdb18651aa0f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a638021df488a13e18115e2e0c013bef0">CPLCalloc</a> (size_t, size_t) CPL_WARN_UNUSED_RESULT</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Safe version of calloc().  <a href="#a638021df488a13e18115e2e0c013bef0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a4fb9e0ce588e0d7360e5f54a453e6f82">CPLRealloc</a> (void *, size_t) CPL_WARN_UNUSED_RESULT</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Safe version of realloc().  <a href="#a4fb9e0ce588e0d7360e5f54a453e6f82"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a01066c0db2a09289d7b14085882d2389">CPLStrdup</a> (const char *) CPL_WARN_UNUSED_RESULT</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Safe version of strdup() function.  <a href="#a01066c0db2a09289d7b14085882d2389"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a1dac5cfc5a7e9dbcf511b461812d89b9">CPLStrlwr</a> (char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert each characters of the string to lower case.  <a href="#a1dac5cfc5a7e9dbcf511b461812d89b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a98e99149a5cb64a79c6a683dc4a4efe2">CPLFGets</a> (char *, int, FILE *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads in at most one less than nBufferSize characters from the fp stream and stores them into the buffer pointed to by pszBuffer.  <a href="#a98e99149a5cb64a79c6a683dc4a4efe2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a0ad35dbadd4f1d04bbedd66774be940f">CPLReadLine</a> (FILE *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simplified line reading from text file.  <a href="#a0ad35dbadd4f1d04bbedd66774be940f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#af049d0b413b82ac770d33cc76f525825">CPLReadLineL</a> (VSILFILE *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simplified line reading from text file.  <a href="#af049d0b413b82ac770d33cc76f525825"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a37852d607dea3a4995be57e88415f391">CPLReadLine2L</a> (VSILFILE *, int nMaxCols, char **papszOptions)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simplified line reading from text file.  <a href="#a37852d607dea3a4995be57e88415f391"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#afb5bf88066f997b1ab3b3911f5e9b722">CPLAtof</a> (const char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts ASCII string to floating point number.  <a href="#afb5bf88066f997b1ab3b3911f5e9b722"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a0a01ca071035c36d4b4f85336e08c5d5">CPLAtofDelim</a> (const char *, char)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts ASCII string to floating point number.  <a href="#a0a01ca071035c36d4b4f85336e08c5d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a2388e43fb089a354eb3583016b2a3b00">CPLStrtod</a> (const char *, char **)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts ASCII string to floating point number.  <a href="#a2388e43fb089a354eb3583016b2a3b00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#ac96c5f1823c54ef96b5783208c817817">CPLStrtodDelim</a> (const char *, char **, char)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts ASCII string to floating point number using specified delimiter.  <a href="#ac96c5f1823c54ef96b5783208c817817"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a1ccda187ed172fd6e33cd98223328531">CPLStrtof</a> (const char *, char **)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts ASCII string to floating point number.  <a href="#a1ccda187ed172fd6e33cd98223328531"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a3a102a1417c98a242900fb8c0076fc1b">CPLStrtofDelim</a> (const char *, char **, char)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts ASCII string to floating point number using specified delimiter.  <a href="#a3a102a1417c98a242900fb8c0076fc1b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#aa07cd1b2aa5e76eb67ba952440198796">CPLAtofM</a> (const char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts ASCII string to floating point number using any numeric locale.  <a href="#aa07cd1b2aa5e76eb67ba952440198796"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a9c2ddf6a8bdb1a9bf2e90e7acbea2cdc">CPLScanString</a> (const char *, int, int, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scan up to a maximum number of characters from a given string, allocate a buffer for a new string and fill it with scanned characters.  <a href="#a9c2ddf6a8bdb1a9bf2e90e7acbea2cdc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#abcdeae39a61518c9c31ecc593eeff621">CPLScanDouble</a> (const char *, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract double from string.  <a href="#abcdeae39a61518c9c31ecc593eeff621"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a338bbe67c148d2555861eb5563b17303">CPLScanLong</a> (const char *, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scan up to a maximum number of characters from a string and convert the result to a long.  <a href="#a338bbe67c148d2555861eb5563b17303"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#ac6e9643c26ab4ee22df95e3dd18c959a">CPLScanULong</a> (const char *, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scan up to a maximum number of characters from a string and convert the result to a unsigned long.  <a href="#ac6e9643c26ab4ee22df95e3dd18c959a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GUIntBig&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#ab4a8e6cf7a0d0f662f6cd4555b074bb5">CPLScanUIntBig</a> (const char *, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract big integer from string.  <a href="#ab4a8e6cf7a0d0f662f6cd4555b074bb5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a2dea859a1f5690d25e5eb32f8d091905">CPLScanPointer</a> (const char *, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract pointer from string.  <a href="#a2dea859a1f5690d25e5eb32f8d091905"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#ae284b3e504edca3eb1eaf568469d61ba">CPLPrintString</a> (char *, const char *, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy the string pointed to by pszSrc, NOT including the terminating `\0' character, to the array pointed to by pszDest.  <a href="#ae284b3e504edca3eb1eaf568469d61ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a0bdbcb209eb9b8e2e6be4fa6e0b750f6">CPLPrintStringFill</a> (char *, const char *, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy the string pointed to by pszSrc, NOT including the terminating `\0' character, to the array pointed to by pszDest.  <a href="#a0bdbcb209eb9b8e2e6be4fa6e0b750f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a33618500e56ec12e6775b3ed9014b8fb">CPLPrintInt32</a> (char *, GInt32, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print GInt32 value into specified string buffer.  <a href="#a33618500e56ec12e6775b3ed9014b8fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a13ca1da1151489f1eee7770296f164aa">CPLPrintUIntBig</a> (char *, GUIntBig, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print GUIntBig value into specified string buffer.  <a href="#a13ca1da1151489f1eee7770296f164aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#ad77e478b4f2e14cc03ae23a9c81434c9">CPLPrintDouble</a> (char *, const char *, double, const char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print double value into specified string buffer.  <a href="#ad77e478b4f2e14cc03ae23a9c81434c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a5be9cf1de05769139a77339ffb970ce4">CPLPrintTime</a> (char *, int, const char *, const struct tm *, const char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print specified time value accordingly to the format options and specified locale name.  <a href="#a5be9cf1de05769139a77339ffb970ce4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#af268becc479787ae48bb2607d0000886">CPLPrintPointer</a> (char *, void *, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print pointer value into specified string buffer.  <a href="#af268becc479787ae48bb2607d0000886"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#affa4a3c8bb4ecbbb9ae3d7ffb35d3572">CPLGetSymbol</a> (const char *, const char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch a function pointer from a shared library / DLL.  <a href="#affa4a3c8bb4ecbbb9ae3d7ffb35d3572"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a5325c900de0918020b747ed07d98da24">CPLGetExecPath</a> (char *pszPathBuf, int nMaxLength)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch path of executable.  <a href="#a5325c900de0918020b747ed07d98da24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a4cd11a5f67bb4816342301fa8a5990a0">CPLGetPath</a> (const char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract directory path portion of filename.  <a href="#a4cd11a5f67bb4816342301fa8a5990a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a3c6f71eaf9b8e8f98242af533752d1bb">CPLGetDirname</a> (const char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract directory path portion of filename.  <a href="#a3c6f71eaf9b8e8f98242af533752d1bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#ae67694bcaaaa43f046325994e3413bac">CPLGetFilename</a> (const char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract non-directory portion of filename.  <a href="#ae67694bcaaaa43f046325994e3413bac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a913ec8c102e1dd312d9447cd815a8673">CPLGetBasename</a> (const char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract basename (non-directory, non-extension) portion of filename.  <a href="#a913ec8c102e1dd312d9447cd815a8673"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#ae46fcfcea1b2e8c24738542613ba4752">CPLGetExtension</a> (const char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract filename extension from full filename.  <a href="#ae46fcfcea1b2e8c24738542613ba4752"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#afc51f03a3789be8a47b8a753eb897856">CPLGetCurrentDir</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current working directory name.  <a href="#afc51f03a3789be8a47b8a753eb897856"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#aee0f81afed5b1b31da1b401822c7a2fb">CPLFormFilename</a> (const char *pszPath, const char *pszBasename, const char *pszExtension)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build a full file path from a passed path, file basename and extension.  <a href="#aee0f81afed5b1b31da1b401822c7a2fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a9c76b24b06830f0da04fe076177f9ff3">CPLFormCIFilename</a> (const char *pszPath, const char *pszBasename, const char *pszExtension)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Case insensitive file searching, returing full path.  <a href="#a9c76b24b06830f0da04fe076177f9ff3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a637fddebebefc776e5c657bcc7366b89">CPLResetExtension</a> (const char *, const char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace the extension with the provided one.  <a href="#a637fddebebefc776e5c657bcc7366b89"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#acb7cd6067d35796aa1af144e5a4283b4">CPLProjectRelativeFilename</a> (const char *pszProjectDir, const char *pszSecondaryFilename)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find a file relative to a project file.  <a href="#acb7cd6067d35796aa1af144e5a4283b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a0cd8ae8d760125ec5b01958a776691ec">CPLIsFilenameRelative</a> (const char *pszFilename)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is filename relative or absolute?  <a href="#a0cd8ae8d760125ec5b01958a776691ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a1f558377064b63f76eefb4065368f8e2">CPLExtractRelativePath</a> (const char *, const char *, int *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get relative path from directory to target file.  <a href="#a1f558377064b63f76eefb4065368f8e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#ac8ed75603810ed09726ebff3463ba80b">CPLCleanTrailingSlash</a> (const char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove trailing forward/backward slash from the path for unix/windows resp.  <a href="#ac8ed75603810ed09726ebff3463ba80b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a7e9657e7ff077fabbc25a41219a8f8ce">CPLCorrespondingPaths</a> (const char *pszOldFilename, const char *pszNewFilename, char **papszFileList)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Identify corresponding paths.  <a href="#a7e9657e7ff077fabbc25a41219a8f8ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#afa9b8f28ae84d5d898b7a3afc6bb6a4b">CPLCheckForFile</a> (char *pszFilename, char **papszSiblingList)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check for file existance.  <a href="#afa9b8f28ae84d5d898b7a3afc6bb6a4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#aaadfd84593d3f707630eb06b520b7dbf">CPLGenerateTempFilename</a> (const char *pszStem)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate temporary file name.  <a href="#aaadfd84593d3f707630eb06b520b7dbf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86d703dd3f7f137d1590b55d7a7e4fb8"></a><!-- doxytag: member="cpl_conv.h::CPLFindFile" ref="a86d703dd3f7f137d1590b55d7a7e4fb8" args="(const char *pszClass, const char *pszBasename)" -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>CPLFindFile</b> (const char *pszClass, const char *pszBasename)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad36c679ea9121ae1a82f0da9010b89ec"></a><!-- doxytag: member="cpl_conv.h::CPLDefaultFindFile" ref="ad36c679ea9121ae1a82f0da9010b89ec" args="(const char *pszClass, const char *pszBasename)" -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>CPLDefaultFindFile</b> (const char *pszClass, const char *pszBasename)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9205b5a0266e9ff0130324016cfe2743"></a><!-- doxytag: member="cpl_conv.h::CPLPushFileFinder" ref="a9205b5a0266e9ff0130324016cfe2743" args="(CPLFileFinder pfnFinder)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>CPLPushFileFinder</b> (CPLFileFinder pfnFinder)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af09a216ab0d69b57b528628ef2f9ee51"></a><!-- doxytag: member="cpl_conv.h::CPLPopFileFinder" ref="af09a216ab0d69b57b528628ef2f9ee51" args="(void)" -->
CPLFileFinder&nbsp;</td><td class="memItemRight" valign="bottom"><b>CPLPopFileFinder</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fb38a901b889d3b0d8a28ede5f97ef5"></a><!-- doxytag: member="cpl_conv.h::CPLPushFinderLocation" ref="a8fb38a901b889d3b0d8a28ede5f97ef5" args="(const char *)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>CPLPushFinderLocation</b> (const char *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9dbfaacc8fd61bcff6c06d5b8061dff4"></a><!-- doxytag: member="cpl_conv.h::CPLPopFinderLocation" ref="a9dbfaacc8fd61bcff6c06d5b8061dff4" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>CPLPopFinderLocation</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d1735b5f7aeeed289c5dd699da9acb1"></a><!-- doxytag: member="cpl_conv.h::CPLFinderClean" ref="a5d1735b5f7aeeed289c5dd699da9acb1" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>CPLFinderClean</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95889f0027c30ed79b3a544a6eacf161"></a><!-- doxytag: member="cpl_conv.h::CPLStat" ref="a95889f0027c30ed79b3a544a6eacf161" args="(const char *, VSIStatBuf *)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>CPLStat</b> (const char *, VSIStatBuf *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">FILE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#af47485362aca554e37796c352a77fc71">CPLOpenShared</a> (const char *, const char *, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a shared file handle.  <a href="#af47485362aca554e37796c352a77fc71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a1afd2c936bbf27a74b02ae6dcadf25a7">CPLCloseShared</a> (FILE *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close shared file.  <a href="#a1afd2c936bbf27a74b02ae6dcadf25a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCPLSharedFileInfo.html">CPLSharedFileInfo</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#ad102985b0ae1672d3d2cf3a4ea8aea4a">CPLGetSharedList</a> (int *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch list of open shared files.  <a href="#ad102985b0ae1672d3d2cf3a4ea8aea4a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#aa7709a32d13e10f2c6c28a176b5a8784">CPLDumpSharedList</a> (FILE *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Report open shared files.  <a href="#aa7709a32d13e10f2c6c28a176b5a8784"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9405d4b641322357f87b9e78f974cc9"></a><!-- doxytag: member="cpl_conv.h::CPLCleanupSharedFileMutex" ref="ac9405d4b641322357f87b9e78f974cc9" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>CPLCleanupSharedFileMutex</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f693923cfd3d171adb34420f09f7891"></a><!-- doxytag: member="cpl_conv.h::CPLDMSToDec" ref="a7f693923cfd3d171adb34420f09f7891" args="(const char *is)" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>CPLDMSToDec</b> (const char *is)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a679f0d2bbc965bcc8d29b56f5210f16b"></a><!-- doxytag: member="cpl_conv.h::CPLDecToDMS" ref="a679f0d2bbc965bcc8d29b56f5210f16b" args="(double dfAngle, const char *pszAxis, int nPrecision)" -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>CPLDecToDMS</b> (double dfAngle, const char *pszAxis, int nPrecision)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#aa4ffc8fd25881635e18d1a53e177a8e1">CPLPackedDMSToDec</a> (double)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a packed DMS value (DDDMMMSSS.SS) into decimal degrees.  <a href="#aa4ffc8fd25881635e18d1a53e177a8e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a97b69cc886a1a5c9618612d8205600e4">CPLDecToPackedDMS</a> (double dfDec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert decimal degrees into packed DMS value (DDDMMMSSS.SS).  <a href="#a97b69cc886a1a5c9618612d8205600e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4d09dcf679de60fdc2262a3a864fae7"></a><!-- doxytag: member="cpl_conv.h::CPLStringToComplex" ref="af4d09dcf679de60fdc2262a3a864fae7" args="(const char *pszString, double *pdfReal, double *pdfImag)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>CPLStringToComplex</b> (const char *pszString, double *pdfReal, double *pdfImag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#aa786ff8dd95ea5b2b641de9ed53cb277">CPLUnlinkTree</a> (const char *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad357816a8e3713a7070e299764b236f7"></a><!-- doxytag: member="cpl_conv.h::CPLCopyFile" ref="ad357816a8e3713a7070e299764b236f7" args="(const char *pszNewPath, const char *pszOldPath)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>CPLCopyFile</b> (const char *pszNewPath, const char *pszOldPath)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2802d9321457b38b3318955c4042f3b9"></a><!-- doxytag: member="cpl_conv.h::CPLMoveFile" ref="a2802d9321457b38b3318955c4042f3b9" args="(const char *pszNewPath, const char *pszOldPath)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>CPLMoveFile</b> (const char *pszNewPath, const char *pszOldPath)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39ca7f6cf51ae51594458fe6e337aabe"></a><!-- doxytag: member="cpl_conv.h::CPLCreateZip" ref="a39ca7f6cf51ae51594458fe6e337aabe" args="(const char *pszZipFilename, char **papszOptions)" -->
void *&nbsp;</td><td class="memItemRight" valign="bottom"><b>CPLCreateZip</b> (const char *pszZipFilename, char **papszOptions)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71a598d868cd731429e0bbd829e901b2"></a><!-- doxytag: member="cpl_conv.h::CPLCreateFileInZip" ref="a71a598d868cd731429e0bbd829e901b2" args="(void *hZip, const char *pszFilename, char **papszOptions)" -->
CPLErr&nbsp;</td><td class="memItemRight" valign="bottom"><b>CPLCreateFileInZip</b> (void *hZip, const char *pszFilename, char **papszOptions)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed2172d84e3d7b71191935cc8b3a50c6"></a><!-- doxytag: member="cpl_conv.h::CPLWriteFileInZip" ref="aed2172d84e3d7b71191935cc8b3a50c6" args="(void *hZip, const void *pBuffer, int nBufferSize)" -->
CPLErr&nbsp;</td><td class="memItemRight" valign="bottom"><b>CPLWriteFileInZip</b> (void *hZip, const void *pBuffer, int nBufferSize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2c084e52d88f873c2a070c51941ce19"></a><!-- doxytag: member="cpl_conv.h::CPLCloseFileInZip" ref="ae2c084e52d88f873c2a070c51941ce19" args="(void *hZip)" -->
CPLErr&nbsp;</td><td class="memItemRight" valign="bottom"><b>CPLCloseFileInZip</b> (void *hZip)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84f8b89602f661237a45545b25b25a05"></a><!-- doxytag: member="cpl_conv.h::CPLCloseZip" ref="a84f8b89602f661237a45545b25b25a05" args="(void *hZip)" -->
CPLErr&nbsp;</td><td class="memItemRight" valign="bottom"><b>CPLCloseZip</b> (void *hZip)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a09f1dd41a8fa1ebc36bc6c34c7c224a3">CPLZLibDeflate</a> (const void *ptr, size_t nBytes, int nLevel, void *outptr, size_t nOutAvailableBytes, size_t *pnOutBytes)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compress a buffer with ZLib DEFLATE compression.  <a href="#a09f1dd41a8fa1ebc36bc6c34c7c224a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a066abbb8471f29f521d19f2252e9959a">CPLZLibInflate</a> (const void *ptr, size_t nBytes, void *outptr, size_t nOutAvailableBytes, size_t *pnOutBytes)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uncompress a buffer compressed with ZLib DEFLATE compression.  <a href="#a066abbb8471f29f521d19f2252e9959a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48d14101425b44a178df6cfbea86e2aa"></a><!-- doxytag: member="cpl_conv.h::CPLValidateXML" ref="a48d14101425b44a178df6cfbea86e2aa" args="(const char *pszXMLFilename, const char *pszXSDFilename, char **papszOptions)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>CPLValidateXML</b> (const char *pszXMLFilename, const char *pszXSDFilename, char **papszOptions)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__conv_8h.html#a7e7dc242d58045315d7672e252e62e7d">CPLsetlocale</a> (int category, const char *locale)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prevents parallel executions of setlocale().  <a href="#a7e7dc242d58045315d7672e252e62e7d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a6935427d664aaacb639ebd7eb8d9a2"></a><!-- doxytag: member="cpl_conv.h::CPLCleanupSetlocaleMutex" ref="a4a6935427d664aaacb639ebd7eb8d9a2" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>CPLCleanupSetlocaleMutex</b> (void)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Various convenience functions for CPL. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="afb5bf88066f997b1ab3b3911f5e9b722"></a><!-- doxytag: member="cpl_conv.h::CPLAtof" ref="afb5bf88066f997b1ab3b3911f5e9b722" args="(const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CPLAtof </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>nptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts ASCII string to floating point number. </p>
<p>This function converts the initial portion of the string pointed to by nptr to double floating point representation. The behaviour is the same as</p>
<p>CPLStrtod(nptr, (char **)NULL);</p>
<p>This function does the same as standard atof(3), but does not take locale in account. That means, the decimal delimiter is always '.' (decimal point). Use <a class="el" href="cpl__conv_8h.html#a0a01ca071035c36d4b4f85336e08c5d5" title="Converts ASCII string to floating point number.">CPLAtofDelim()</a> function if you want to specify custom delimiter.</p>
<p>IMPORTANT NOTE. Existance of this function does not mean you should always use it. Sometimes you should use standard locale aware atof(3) and its family. When you need to process the user's input (for example, command line parameters) use atof(3), because user works in localized environment and her input will be done accordingly the locale set. In particular that means we should not make assumptions about character used as decimal delimiter, it can be either "." or ",". But when you are parsing some ASCII file in predefined format, you most likely need <a class="el" href="cpl__conv_8h.html#afb5bf88066f997b1ab3b3911f5e9b722" title="Converts ASCII string to floating point number.">CPLAtof()</a>, because such files distributed across the systems with different locales and floating point representation shoudl be considered as a part of file format. If the format uses "." as a delimiter the same character must be used when parsing number regardless of actual locale setting.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nptr</em>&nbsp;</td><td>Pointer to string to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Converted value, if any. </dd></dl>

</div>
</div>
<a class="anchor" id="a0a01ca071035c36d4b4f85336e08c5d5"></a><!-- doxytag: member="cpl_conv.h::CPLAtofDelim" ref="a0a01ca071035c36d4b4f85336e08c5d5" args="(const char *, char)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CPLAtofDelim </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>point</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts ASCII string to floating point number. </p>
<p>This function converts the initial portion of the string pointed to by nptr to double floating point representation. The behaviour is the same as</p>
<p>CPLStrtodDelim(nptr, (char **)NULL, point);</p>
<p>This function does the same as standard atof(3), but does not take locale in account. Instead of locale defined decimal delimiter you can specify your own one. Also see notes for <a class="el" href="cpl__conv_8h.html#afb5bf88066f997b1ab3b3911f5e9b722" title="Converts ASCII string to floating point number.">CPLAtof()</a> function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nptr</em>&nbsp;</td><td>Pointer to string to convert. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>point</em>&nbsp;</td><td>Decimal delimiter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Converted value, if any. </dd></dl>

</div>
</div>
<a class="anchor" id="aa07cd1b2aa5e76eb67ba952440198796"></a><!-- doxytag: member="cpl_conv.h::CPLAtofM" ref="aa07cd1b2aa5e76eb67ba952440198796" args="(const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CPLAtofM </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>nptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts ASCII string to floating point number using any numeric locale. </p>
<p>This function converts the initial portion of the string pointed to by nptr to double floating point representation. This function does the same as standard atof(), but it allows a variety of locale representations. That is it supports numeric values with either a comma or a period for the decimal delimiter.</p>
<p>PS. The M stands for Multi-lingual.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nptr</em>&nbsp;</td><td>The string to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Converted value, if any. Zero on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a638021df488a13e18115e2e0c013bef0"></a><!-- doxytag: member="cpl_conv.h::CPLCalloc" ref="a638021df488a13e18115e2e0c013bef0" args="(size_t, size_t) CPL_WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* CPLCalloc </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Safe version of calloc(). </p>
<p>This function is like the C library calloc(), but raises a CE_Fatal error with <a class="el" href="cpl__error_8h.html#aad2b98dd58e4de706a245faddac90403" title="Report an error.">CPLError()</a> if it fails to allocate the desired memory. It should be used for small memory allocations that are unlikely to fail and for which the application is unwilling to test for out of memory conditions. It uses VSICalloc() to get the memory, so any hooking of VSICalloc() will apply to <a class="el" href="cpl__conv_8h.html#a638021df488a13e18115e2e0c013bef0" title="Safe version of calloc().">CPLCalloc()</a> as well. CPLFree() or VSIFree() can be used free memory allocated by <a class="el" href="cpl__conv_8h.html#a638021df488a13e18115e2e0c013bef0" title="Safe version of calloc().">CPLCalloc()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nCount</em>&nbsp;</td><td>number of objects to allocate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nSize</em>&nbsp;</td><td>size (in bytes) of object to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to newly allocated memory, only NULL if nSize * nCount is NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="afa9b8f28ae84d5d898b7a3afc6bb6a4b"></a><!-- doxytag: member="cpl_conv.h::CPLCheckForFile" ref="afa9b8f28ae84d5d898b7a3afc6bb6a4b" args="(char *pszFilename, char **papszSiblingList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLCheckForFile </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszSiblingFiles</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check for file existance. </p>
<p>The function checks if a named file exists in the filesystem, hopefully in an efficient fashion if a sibling file list is available. It exists primarily to do faster file checking for functions like GDAL open methods that get a list of files from the target directory.</p>
<p>If the sibling file list exists (is not NULL) it is assumed to be a list of files in the same directory as the target file, and it will be checked (case insensitively) for a match. If a match is found, pszFilename is updated with the correct case and TRUE is returned.</p>
<p>If papszSiblingFiles is NULL, a <a class="el" href="cpl__vsi_8h.html#ac92fbd5e6fc143b026001b32c4c19ed1" title="Get filesystem object info.">VSIStatL()</a> is used to test for the files existance, and no case insensitive testing is done.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszFilename</em>&nbsp;</td><td>name of file to check for - filename case updated in some cases. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>papszSiblingFiles</em>&nbsp;</td><td>a list of files in the same directory as pszFilename if available, or NULL. This list should have no path components.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if a match is found, or FALSE if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ac8ed75603810ed09726ebff3463ba80b"></a><!-- doxytag: member="cpl_conv.h::CPLCleanTrailingSlash" ref="ac8ed75603810ed09726ebff3463ba80b" args="(const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* CPLCleanTrailingSlash </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszPath</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove trailing forward/backward slash from the path for unix/windows resp. </p>
<p>Returns a string containing the portion of the passed path string with trailing slash removed. If there is no path in the passed filename an empty string will be returned (not NULL).</p>
<pre>
 CPLCleanTrailingSlash( "abc/def/" ) == "abc/def"
 CPLCleanTrailingSlash( "abc/def" ) == "abc/def"
 CPLCleanTrailingSlash( "c:\abc\def\" ) == "c:\abc\def"
 CPLCleanTrailingSlash( "c:\abc\def" ) == "c:\abc\def"
 CPLCleanTrailingSlash( "abc" ) == "abc"
 </pre><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszPath</em>&nbsp;</td><td>the path to be cleaned up</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Path in an internal string which must not be freed. The string may be destroyed by the next CPL filename handling call. </dd></dl>

</div>
</div>
<a class="anchor" id="a1afd2c936bbf27a74b02ae6dcadf25a7"></a><!-- doxytag: member="cpl_conv.h::CPLCloseShared" ref="a1afd2c936bbf27a74b02ae6dcadf25a7" args="(FILE *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CPLCloseShared </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close shared file. </p>
<p>Dereferences the indicated file handle, and closes it if the reference count has dropped to zero. A <a class="el" href="cpl__error_8h.html#aad2b98dd58e4de706a245faddac90403" title="Report an error.">CPLError()</a> is issued if the file is not in the shared file list.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fp</em>&nbsp;</td><td>file handle from <a class="el" href="cpl__conv_8h.html#af47485362aca554e37796c352a77fc71" title="Open a shared file handle.">CPLOpenShared()</a> to deaccess. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7e9657e7ff077fabbc25a41219a8f8ce"></a><!-- doxytag: member="cpl_conv.h::CPLCorrespondingPaths" ref="a7e9657e7ff077fabbc25a41219a8f8ce" args="(const char *pszOldFilename, const char *pszNewFilename, char **papszFileList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char** CPLCorrespondingPaths </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszOldFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszNewFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszFileList</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Identify corresponding paths. </p>
<p>Given a prototype old and new filename this function will attempt to determine corresponding names for a set of other old filenames that will rename them in a similar manner. This correspondance assumes there are two possibly kinds of renaming going on. A change of path, and a change of filename stem.</p>
<p>If a consistent renaming cannot be established for all the files this function will return indicating an error.</p>
<p>The returned file list becomes owned by the caller and should be destroyed with <a class="el" href="cpl__string_8h.html#a5a39b9c5896a273cc6f06c1d5be93238" title="Free string list.">CSLDestroy()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszOldFilename</em>&nbsp;</td><td>path to old prototype file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszNewFilename</em>&nbsp;</td><td>path to new prototype file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>papszFileList</em>&nbsp;</td><td>list of other files associated with pszOldFilename to rename similarly.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a list of files corresponding to papszFileList but renamed to correspond to pszNewFilename. </dd></dl>

</div>
</div>
<a class="anchor" id="a97b69cc886a1a5c9618612d8205600e4"></a><!-- doxytag: member="cpl_conv.h::CPLDecToPackedDMS" ref="a97b69cc886a1a5c9618612d8205600e4" args="(double dfDec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CPLDecToPackedDMS </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfDec</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert decimal degrees into packed DMS value (DDDMMMSSS.SS). </p>
<p>This function converts a value, specified in decimal degrees into packed DMS angle. The standard packed DMS format is:</p>
<p>degrees * 1000000 + minutes * 1000 + seconds</p>
<p>See also <a class="el" href="cpl__conv_8h.html#aa4ffc8fd25881635e18d1a53e177a8e1" title="Convert a packed DMS value (DDDMMMSSS.SS) into decimal degrees.">CPLPackedDMSToDec()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dfDec</em>&nbsp;</td><td>Angle in decimal degrees.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Angle in packed DMS format. </dd></dl>

</div>
</div>
<a class="anchor" id="aa7709a32d13e10f2c6c28a176b5a8784"></a><!-- doxytag: member="cpl_conv.h::CPLDumpSharedList" ref="aa7709a32d13e10f2c6c28a176b5a8784" args="(FILE *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CPLDumpSharedList </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Report open shared files. </p>
<p>Dumps all open shared files to the indicated file handle. If the file handle is NULL information is sent via the <a class="el" href="cpl__error_8h.html#ad0c5d3481dd34c1f3a0f7775ebf74817" title="Display a debugging message.">CPLDebug()</a> call.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fp</em>&nbsp;</td><td>File handle to write to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1f558377064b63f76eefb4065368f8e2"></a><!-- doxytag: member="cpl_conv.h::CPLExtractRelativePath" ref="a1f558377064b63f76eefb4065368f8e2" args="(const char *, const char *, int *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* CPLExtractRelativePath </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszBaseDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pbGotRelative</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get relative path from directory to target file. </p>
<p>Computes a relative path for pszTarget relative to pszBaseDir. Currently this only works if they share a common base path. The returned path is normally into the pszTarget string. It should only be considered valid as long as pszTarget is valid or till the next call to this function, whichever comes first.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszBaseDir</em>&nbsp;</td><td>the name of the directory relative to which the path should be computed. pszBaseDir may be NULL in which case the original target is returned without relitivizing.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszTarget</em>&nbsp;</td><td>the filename to be changed to be relative to pszBaseDir.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pbGotRelative</em>&nbsp;</td><td>Pointer to location in which a flag is placed indicating that the returned path is relative to the basename (TRUE) or not (FALSE). This pointer may be NULL if flag is not desired.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an adjusted path or the original if it could not be made relative to the pszBaseFile's path. </dd></dl>

</div>
</div>
<a class="anchor" id="a98e99149a5cb64a79c6a683dc4a4efe2"></a><!-- doxytag: member="cpl_conv.h::CPLFGets" ref="a98e99149a5cb64a79c6a683dc4a4efe2" args="(char *, int, FILE *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* CPLFGets </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pszBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads in at most one less than nBufferSize characters from the fp stream and stores them into the buffer pointed to by pszBuffer. </p>
<p>Reading stops after an EOF or a newline. If a newline is read, it is _not_ stored into the buffer. A '\0' is stored after the last character in the buffer. All three types of newline terminators recognized by the <a class="el" href="cpl__conv_8h.html#a98e99149a5cb64a79c6a683dc4a4efe2" title="Reads in at most one less than nBufferSize characters from the fp stream and stores them into the buf...">CPLFGets()</a>: single '\r' and '\n' and '\r\n' combination.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszBuffer</em>&nbsp;</td><td>pointer to the targeting character buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nBufferSize</em>&nbsp;</td><td>maximum size of the string to read (not including termonating '\0'). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fp</em>&nbsp;</td><td>file pointer to read from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to the pszBuffer containing a string read from the file or NULL if the error or end of file was encountered. </dd></dl>

</div>
</div>
<a class="anchor" id="a9c76b24b06830f0da04fe076177f9ff3"></a><!-- doxytag: member="cpl_conv.h::CPLFormCIFilename" ref="a9c76b24b06830f0da04fe076177f9ff3" args="(const char *pszPath, const char *pszBasename, const char *pszExtension)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* CPLFormCIFilename </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszBasename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszExtension</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Case insensitive file searching, returing full path. </p>
<p>This function tries to return the path to a file regardless of whether the file exactly matches the basename, and extension case, or is all upper case, or all lower case. The path is treated as case sensitive. This function is equivelent to <a class="el" href="cpl__conv_8h.html#aee0f81afed5b1b31da1b401822c7a2fb" title="Build a full file path from a passed path, file basename and extension.">CPLFormFilename()</a> on case insensitive file systems (like Windows).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszPath</em>&nbsp;</td><td>directory path to the directory containing the file. This may be relative or absolute, and may have a trailing path separator or not. May be NULL.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszBasename</em>&nbsp;</td><td>file basename. May optionally have path and/or extension. May not be NULL.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszExtension</em>&nbsp;</td><td>file extension, optionally including the period. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a fully formed filename in an internal static string. Do not modify or free the returned string. The string may be destroyed by the next CPL call. </dd></dl>

</div>
</div>
<a class="anchor" id="aee0f81afed5b1b31da1b401822c7a2fb"></a><!-- doxytag: member="cpl_conv.h::CPLFormFilename" ref="aee0f81afed5b1b31da1b401822c7a2fb" args="(const char *pszPath, const char *pszBasename, const char *pszExtension)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* CPLFormFilename </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszBasename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszExtension</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build a full file path from a passed path, file basename and extension. </p>
<p>The path, and extension are optional. The basename may in fact contain an extension if desired.</p>
<pre>
 CPLFormFilename("abc/xyz","def", ".dat" ) == "abc/xyz/def.dat"
 CPLFormFilename(NULL,"def", NULL ) == "def"
 CPLFormFilename(NULL,"abc/def.dat", NULL ) == "abc/def.dat"
 CPLFormFilename("/abc/xyz/","def.dat", NULL ) == "/abc/xyz/def.dat"
 </pre><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszPath</em>&nbsp;</td><td>directory path to the directory containing the file. This may be relative or absolute, and may have a trailing path separator or not. May be NULL.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszBasename</em>&nbsp;</td><td>file basename. May optionally have path and/or extension. Must *NOT* be NULL.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszExtension</em>&nbsp;</td><td>file extension, optionally including the period. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a fully formed filename in an internal static string. Do not modify or free the returned string. The string may be destroyed by the next CPL call. </dd></dl>

</div>
</div>
<a class="anchor" id="aaadfd84593d3f707630eb06b520b7dbf"></a><!-- doxytag: member="cpl_conv.h::CPLGenerateTempFilename" ref="aaadfd84593d3f707630eb06b520b7dbf" args="(const char *pszStem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* CPLGenerateTempFilename </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszStem</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate temporary file name. </p>
<p>Returns a filename that may be used for a temporary file. The location of the file tries to follow operating system semantics but may be forced via the CPL_TMPDIR configuration option.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszStem</em>&nbsp;</td><td>if non-NULL this will be part of the filename.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a filename which is valid till the next CPL call in this thread. </dd></dl>

</div>
</div>
<a class="anchor" id="a913ec8c102e1dd312d9447cd815a8673"></a><!-- doxytag: member="cpl_conv.h::CPLGetBasename" ref="a913ec8c102e1dd312d9447cd815a8673" args="(const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* CPLGetBasename </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszFullFilename</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extract basename (non-directory, non-extension) portion of filename. </p>
<p>Returns a string containing the file basename portion of the passed name. If there is no basename (passed value ends in trailing directory separator, or filename starts with a dot) an empty string is returned.</p>
<pre>
 CPLGetBasename( "abc/def.xyz" ) == "def"
 CPLGetBasename( "abc/def" ) == "def"
 CPLGetBasename( "abc/def/" ) == ""
 </pre><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszFullFilename</em>&nbsp;</td><td>the full filename potentially including a path.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>just the non-directory, non-extension portion of the path in an internal string which must not be freed. The string may be destroyed by the next CPL filename handling call. </dd></dl>

</div>
</div>
<a class="anchor" id="a21a509890bf6632f1b1d836c1d3bb970"></a><!-- doxytag: member="cpl_conv.h::CPLGetConfigOption" ref="a21a509890bf6632f1b1d836c1d3bb970" args="(const char *, const char *) CPL_WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* CPLGetConfigOption </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszDefault</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the value of a configuration option. </p>
<p>The value is the value of a (key, value) option set with <a class="el" href="cpl__conv_8h.html#aa0cd1a68fe4f2fc7874cd2da605c36ce" title="Set a configuration option for GDAL/OGR use.">CPLSetConfigOption()</a>. If the given option was no defined with <a class="el" href="cpl__conv_8h.html#aa0cd1a68fe4f2fc7874cd2da605c36ce" title="Set a configuration option for GDAL/OGR use.">CPLSetConfigOption()</a>, it tries to find it in environment variables.</p>
<p>Note: the string returned by <a class="el" href="cpl__conv_8h.html#a21a509890bf6632f1b1d836c1d3bb970" title="Get the value of a configuration option.">CPLGetConfigOption()</a> might be short-lived, and in particular it will become invalid after a call to <a class="el" href="cpl__conv_8h.html#aa0cd1a68fe4f2fc7874cd2da605c36ce" title="Set a configuration option for GDAL/OGR use.">CPLSetConfigOption()</a> with the same key.</p>
<p>To override temporary a potentially existing option with a new value, you can use the following snippet : </p>
<pre>
     // backup old value
     const char* pszOldValTmp = CPLGetConfigOption(pszKey, NULL);
     char* pszOldVal = pszOldValTmp ? CPLStrdup(pszOldValTmp) : NULL;
     // override with new value
     CPLSetConfigOption(pszKey, pszNewVal);
     // do something usefull
     // restore old value
     CPLSetConfigOption(pszKey, pszOldVal);
     CPLFree(pszOldVal);
 </pre><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszKey</em>&nbsp;</td><td>the key of the option to retrieve </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszDefault</em>&nbsp;</td><td>a default value if the key does not match existing defined options (may be NULL) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the value associated to the key, or the default value if not found</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cpl__conv_8h.html#aa0cd1a68fe4f2fc7874cd2da605c36ce" title="Set a configuration option for GDAL/OGR use.">CPLSetConfigOption()</a>, <a href="http://trac.osgeo.org/gdal/wiki/ConfigOptions">http://trac.osgeo.org/gdal/wiki/ConfigOptions</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afc51f03a3789be8a47b8a753eb897856"></a><!-- doxytag: member="cpl_conv.h::CPLGetCurrentDir" ref="afc51f03a3789be8a47b8a753eb897856" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* CPLGetCurrentDir </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the current working directory name. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to buffer, containing current working directory path or NULL in case of error. User is responsible to free that buffer after usage with CPLFree() function. If HAVE_GETCWD macro is not defined, the function returns NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a3c6f71eaf9b8e8f98242af533752d1bb"></a><!-- doxytag: member="cpl_conv.h::CPLGetDirname" ref="a3c6f71eaf9b8e8f98242af533752d1bb" args="(const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* CPLGetDirname </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszFilename</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extract directory path portion of filename. </p>
<p>Returns a string containing the directory path portion of the passed filename. If there is no path in the passed filename the dot will be returned. It is the only difference from <a class="el" href="cpl__conv_8h.html#a4cd11a5f67bb4816342301fa8a5990a0" title="Extract directory path portion of filename.">CPLGetPath()</a>.</p>
<pre>
 CPLGetDirname( "abc/def.xyz" ) == "abc"
 CPLGetDirname( "/abc/def/" ) == "/abc/def"
 CPLGetDirname( "/" ) == "/"
 CPLGetDirname( "/abc/def" ) == "/abc"
 CPLGetDirname( "abc" ) == "."
 </pre><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszFilename</em>&nbsp;</td><td>the filename potentially including a path.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Path in an internal string which must not be freed. The string may be destroyed by the next CPL filename handling call. The returned will generally not contain a trailing path separator. </dd></dl>

</div>
</div>
<a class="anchor" id="a5325c900de0918020b747ed07d98da24"></a><!-- doxytag: member="cpl_conv.h::CPLGetExecPath" ref="a5325c900de0918020b747ed07d98da24" args="(char *pszPathBuf, int nMaxLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLGetExecPath </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pszPathBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nMaxLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch path of executable. </p>
<p>The path to the executable currently running is returned. This path includes the name of the executable. Currently this only works on win32 and linux platforms. The returned path is UTF-8 encoded.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszPathBuf</em>&nbsp;</td><td>the buffer into which the path is placed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nMaxLength</em>&nbsp;</td><td>the buffer size, MAX_PATH+1 is suggested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FALSE on failure or TRUE on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ae46fcfcea1b2e8c24738542613ba4752"></a><!-- doxytag: member="cpl_conv.h::CPLGetExtension" ref="ae46fcfcea1b2e8c24738542613ba4752" args="(const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* CPLGetExtension </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszFullFilename</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extract filename extension from full filename. </p>
<p>Returns a string containing the extention portion of the passed name. If there is no extension (the filename has no dot) an empty string is returned. The returned extension will not include the period.</p>
<pre>
 CPLGetExtension( "abc/def.xyz" ) == "xyz"
 CPLGetExtension( "abc/def" ) == ""
 </pre><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszFullFilename</em>&nbsp;</td><td>the full filename potentially including a path.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>just the extension portion of the path in an internal string which must not be freed. The string may be destroyed by the next CPL filename handling call. </dd></dl>

</div>
</div>
<a class="anchor" id="ae67694bcaaaa43f046325994e3413bac"></a><!-- doxytag: member="cpl_conv.h::CPLGetFilename" ref="ae67694bcaaaa43f046325994e3413bac" args="(const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* CPLGetFilename </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszFullFilename</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extract non-directory portion of filename. </p>
<p>Returns a string containing the bare filename portion of the passed filename. If there is no filename (passed value ends in trailing directory separator) an empty string is returned.</p>
<pre>
 CPLGetFilename( "abc/def.xyz" ) == "def.xyz"
 CPLGetFilename( "/abc/def/" ) == ""
 CPLGetFilename( "abc/def" ) == "def"
 </pre><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszFullFilename</em>&nbsp;</td><td>the full filename potentially including a path.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>just the non-directory portion of the path (points back into original string). </dd></dl>

</div>
</div>
<a class="anchor" id="a4cd11a5f67bb4816342301fa8a5990a0"></a><!-- doxytag: member="cpl_conv.h::CPLGetPath" ref="a4cd11a5f67bb4816342301fa8a5990a0" args="(const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* CPLGetPath </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszFilename</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extract directory path portion of filename. </p>
<p>Returns a string containing the directory path portion of the passed filename. If there is no path in the passed filename an empty string will be returned (not NULL).</p>
<pre>
 CPLGetPath( "abc/def.xyz" ) == "abc"
 CPLGetPath( "/abc/def/" ) == "/abc/def"
 CPLGetPath( "/" ) == "/"
 CPLGetPath( "/abc/def" ) == "/abc"
 CPLGetPath( "abc" ) == ""
 </pre><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszFilename</em>&nbsp;</td><td>the filename potentially including a path.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Path in an internal string which must not be freed. The string may be destroyed by the next CPL filename handling call. The returned will generally not contain a trailing path separator. </dd></dl>

</div>
</div>
<a class="anchor" id="ad102985b0ae1672d3d2cf3a4ea8aea4a"></a><!-- doxytag: member="cpl_conv.h::CPLGetSharedList" ref="ad102985b0ae1672d3d2cf3a4ea8aea4a" args="(int *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCPLSharedFileInfo.html">CPLSharedFileInfo</a>* CPLGetSharedList </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pnCount</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch list of open shared files. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pnCount</em>&nbsp;</td><td>place to put the count of entries.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the pointer to the first in the array of shared file info structures. </dd></dl>

</div>
</div>
<a class="anchor" id="affa4a3c8bb4ecbbb9ae3d7ffb35d3572"></a><!-- doxytag: member="cpl_conv.h::CPLGetSymbol" ref="affa4a3c8bb4ecbbb9ae3d7ffb35d3572" args="(const char *, const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* CPLGetSymbol </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszLibrary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszSymbolName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch a function pointer from a shared library / DLL. </p>
<p>This function is meant to abstract access to shared libraries and DLLs and performs functions similar to dlopen()/dlsym() on Unix and LoadLibrary() / GetProcAddress() on Windows.</p>
<p>If no support for loading entry points from a shared library is available this function will always return NULL. Rules on when this function issues a <a class="el" href="cpl__error_8h.html#aad2b98dd58e4de706a245faddac90403" title="Report an error.">CPLError()</a> or not are not currently well defined, and will have to be resolved in the future.</p>
<p>Currently <a class="el" href="cpl__conv_8h.html#affa4a3c8bb4ecbbb9ae3d7ffb35d3572" title="Fetch a function pointer from a shared library / DLL.">CPLGetSymbol()</a> doesn't try to: </p>
<ul>
<li>
prevent the reference count on the library from going up for every request, or given any opportunity to unload the library. </li>
<li>
Attempt to look for the library in non-standard locations. </li>
<li>
Attempt to try variations on the symbol name, like pre-prending or post-pending an underscore. </li>
</ul>
<p>Some of these issues may be worked on in the future.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszLibrary</em>&nbsp;</td><td>the name of the shared library or DLL containing the function. May contain path to file. If not system supplies search paths will be used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszSymbolName</em>&nbsp;</td><td>the name of the function to fetch a pointer to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the function if found, or NULL if the function isn't found, or the shared library can't be loaded. </dd></dl>

</div>
</div>
<a class="anchor" id="a0cd8ae8d760125ec5b01958a776691ec"></a><!-- doxytag: member="cpl_conv.h::CPLIsFilenameRelative" ref="a0cd8ae8d760125ec5b01958a776691ec" args="(const char *pszFilename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLIsFilenameRelative </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszFilename</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Is filename relative or absolute? </p>
<p>The test is filesystem convention agnostic. That is it will test for Unix style and windows style path conventions regardless of the actual system in use.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszFilename</em>&nbsp;</td><td>the filename with path to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the filename is relative or FALSE if it is absolute. </dd></dl>

</div>
</div>
<a class="anchor" id="a9a806de98fbddb1337efdb18651aa0f7"></a><!-- doxytag: member="cpl_conv.h::CPLMalloc" ref="a9a806de98fbddb1337efdb18651aa0f7" args="(size_t) CPL_WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* CPLMalloc </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nSize</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Safe version of malloc(). </p>
<p>This function is like the C library malloc(), but raises a CE_Fatal error with <a class="el" href="cpl__error_8h.html#aad2b98dd58e4de706a245faddac90403" title="Report an error.">CPLError()</a> if it fails to allocate the desired memory. It should be used for small memory allocations that are unlikely to fail and for which the application is unwilling to test for out of memory conditions. It uses VSIMalloc() to get the memory, so any hooking of VSIMalloc() will apply to <a class="el" href="cpl__conv_8h.html#a9a806de98fbddb1337efdb18651aa0f7" title="Safe version of malloc().">CPLMalloc()</a> as well. CPLFree() or VSIFree() can be used free memory allocated by <a class="el" href="cpl__conv_8h.html#a9a806de98fbddb1337efdb18651aa0f7" title="Safe version of malloc().">CPLMalloc()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nSize</em>&nbsp;</td><td>size (in bytes) of memory block to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to newly allocated memory, only NULL if nSize is zero. </dd></dl>

</div>
</div>
<a class="anchor" id="af47485362aca554e37796c352a77fc71"></a><!-- doxytag: member="cpl_conv.h::CPLOpenShared" ref="af47485362aca554e37796c352a77fc71" args="(const char *, const char *, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FILE* CPLOpenShared </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bLarge</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open a shared file handle. </p>
<p>Some operating systems have limits on the number of file handles that can be open at one time. This function attempts to maintain a registry of already open file handles, and reuse existing ones if the same file is requested by another part of the application.</p>
<p>Note that access is only shared for access types "r", "rb", "r+" and "rb+". All others will just result in direct VSIOpen() calls. Keep in mind that a file is only reused if the file name is exactly the same. Different names referring to the same file will result in different handles.</p>
<p>The VSIFOpen() or <a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file.">VSIFOpenL()</a> function is used to actually open the file, when an existing file handle can't be shared.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszFilename</em>&nbsp;</td><td>the name of the file to open. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszAccess</em>&nbsp;</td><td>the normal fopen()/VSIFOpen() style access string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bLarge</em>&nbsp;</td><td>If TRUE <a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file.">VSIFOpenL()</a> (for large files) will be used instead of VSIFOpen().</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a file handle or NULL if opening fails. </dd></dl>

</div>
</div>
<a class="anchor" id="aa4ffc8fd25881635e18d1a53e177a8e1"></a><!-- doxytag: member="cpl_conv.h::CPLPackedDMSToDec" ref="aa4ffc8fd25881635e18d1a53e177a8e1" args="(double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CPLPackedDMSToDec </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfPacked</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a packed DMS value (DDDMMMSSS.SS) into decimal degrees. </p>
<p>This function converts a packed DMS angle to seconds. The standard packed DMS format is:</p>
<p>degrees * 1000000 + minutes * 1000 + seconds</p>
<p>Example: ang = 120025045.25 yields deg = 120 min = 25 sec = 45.25</p>
<p>The algorithm used for the conversion is as follows:</p>
<p>1. The absolute value of the angle is used.</p>
<p>2. The degrees are separated out: deg = ang/1000000 (fractional portion truncated)</p>
<p>3. The minutes are separated out: min = (ang - deg * 1000000) / 1000 (fractional portion truncated)</p>
<p>4. The seconds are then computed: sec = ang - deg * 1000000 - min * 1000</p>
<p>5. The total angle in seconds is computed: sec = deg * 3600.0 + min * 60.0 + sec</p>
<p>6. The sign of sec is set to that of the input angle.</p>
<p>Packed DMS values used by the USGS GCTP package and probably by other software.</p>
<p>NOTE: This code does not validate input value. If you give the wrong value, you will get the wrong result.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dfPacked</em>&nbsp;</td><td>Angle in packed DMS format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Angle in decimal degrees. </dd></dl>

</div>
</div>
<a class="anchor" id="ad77e478b4f2e14cc03ae23a9c81434c9"></a><!-- doxytag: member="cpl_conv.h::CPLPrintDouble" ref="ad77e478b4f2e14cc03ae23a9c81434c9" args="(char *, const char *, double, const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLPrintDouble </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pszBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszLocale</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print double value into specified string buffer. </p>
<p>Exponential character flag 'E' (or 'e') will be replaced with 'D', as in Fortran. Resulting string will not to be NULL-terminated.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszBuffer</em>&nbsp;</td><td>Pointer to the destination string buffer. Should be large enough to hold the resulting string. Note, that the string will not be NULL-terminated, so user should do this himself, if needed.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszFormat</em>&nbsp;</td><td>Format specifier (for example, "%16.9E").</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfValue</em>&nbsp;</td><td>Numerical value to print.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszLocale</em>&nbsp;</td><td>Pointer to a character string containing locale name ("C", "POSIX", "us_US", "ru_RU.KOI8-R" etc.). If NULL we will not manipulate with locale settings and current process locale will be used for printing. With the pszLocale option we can control what exact locale will be used for printing a numeric value to the string (in most cases it should be C/POSIX).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of characters printed. </dd></dl>

</div>
</div>
<a class="anchor" id="a33618500e56ec12e6775b3ed9014b8fb"></a><!-- doxytag: member="cpl_conv.h::CPLPrintInt32" ref="a33618500e56ec12e6775b3ed9014b8fb" args="(char *, GInt32, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLPrintInt32 </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pszBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GInt32&nbsp;</td>
          <td class="paramname"> <em>iValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nMaxLen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print GInt32 value into specified string buffer. </p>
<p>This string will not be NULL-terminated.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszBuffer</em>&nbsp;</td><td>Pointer to the destination string buffer. Should be large enough to hold the resulting string. Note, that the string will not be NULL-terminated, so user should do this himself, if needed.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iValue</em>&nbsp;</td><td>Numerical value to print.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nMaxLen</em>&nbsp;</td><td>Maximum length of the resulting string. If string length is greater than nMaxLen, it will be truncated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of characters printed. </dd></dl>

</div>
</div>
<a class="anchor" id="af268becc479787ae48bb2607d0000886"></a><!-- doxytag: member="cpl_conv.h::CPLPrintPointer" ref="af268becc479787ae48bb2607d0000886" args="(char *, void *, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLPrintPointer </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pszBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nMaxLen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print pointer value into specified string buffer. </p>
<p>This string will not be NULL-terminated.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszBuffer</em>&nbsp;</td><td>Pointer to the destination string buffer. Should be large enough to hold the resulting string. Note, that the string will not be NULL-terminated, so user should do this himself, if needed.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pValue</em>&nbsp;</td><td>Pointer to ASCII encode.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nMaxLen</em>&nbsp;</td><td>Maximum length of the resulting string. If string length is greater than nMaxLen, it will be truncated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of characters printed. </dd></dl>

</div>
</div>
<a class="anchor" id="ae284b3e504edca3eb1eaf568469d61ba"></a><!-- doxytag: member="cpl_conv.h::CPLPrintString" ref="ae284b3e504edca3eb1eaf568469d61ba" args="(char *, const char *, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLPrintString </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pszDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nMaxLen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy the string pointed to by pszSrc, NOT including the terminating `\0' character, to the array pointed to by pszDest. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszDest</em>&nbsp;</td><td>Pointer to the destination string buffer. Should be large enough to hold the resulting string.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszSrc</em>&nbsp;</td><td>Pointer to the source buffer.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nMaxLen</em>&nbsp;</td><td>Maximum length of the resulting string. If string length is greater than nMaxLen, it will be truncated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of characters printed. </dd></dl>

</div>
</div>
<a class="anchor" id="a0bdbcb209eb9b8e2e6be4fa6e0b750f6"></a><!-- doxytag: member="cpl_conv.h::CPLPrintStringFill" ref="a0bdbcb209eb9b8e2e6be4fa6e0b750f6" args="(char *, const char *, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLPrintStringFill </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pszDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nMaxLen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy the string pointed to by pszSrc, NOT including the terminating `\0' character, to the array pointed to by pszDest. </p>
<p>Remainder of the destination string will be filled with space characters. This is only difference from the PrintString().</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszDest</em>&nbsp;</td><td>Pointer to the destination string buffer. Should be large enough to hold the resulting string.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszSrc</em>&nbsp;</td><td>Pointer to the source buffer.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nMaxLen</em>&nbsp;</td><td>Maximum length of the resulting string. If string length is greater than nMaxLen, it will be truncated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of characters printed. </dd></dl>

</div>
</div>
<a class="anchor" id="a5be9cf1de05769139a77339ffb970ce4"></a><!-- doxytag: member="cpl_conv.h::CPLPrintTime" ref="a5be9cf1de05769139a77339ffb970ce4" args="(char *, int, const char *, const struct tm *, const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLPrintTime </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pszBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nMaxLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct tm *&nbsp;</td>
          <td class="paramname"> <em>poBrokenTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszLocale</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print specified time value accordingly to the format options and specified locale name. </p>
<p>This function does following:</p>
<ul>
<li>if locale parameter is not NULL, the current locale setting will be stored and replaced with the specified one;</li>
<li>format time value with the strftime(3) function;</li>
<li>restore back current locale, if was saved.</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszBuffer</em>&nbsp;</td><td>Pointer to the destination string buffer. Should be large enough to hold the resulting string. Note, that the string will not be NULL-terminated, so user should do this himself, if needed.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nMaxLen</em>&nbsp;</td><td>Maximum length of the resulting string. If string length is greater than nMaxLen, it will be truncated.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszFormat</em>&nbsp;</td><td>Controls the output format. Options are the same as for strftime(3) function.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>poBrokenTime</em>&nbsp;</td><td>Pointer to the broken-down time structure. May be requested with the VSIGMTime() and VSILocalTime() functions.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszLocale</em>&nbsp;</td><td>Pointer to a character string containing locale name ("C", "POSIX", "us_US", "ru_RU.KOI8-R" etc.). If NULL we will not manipulate with locale settings and current process locale will be used for printing. Be aware that it may be unsuitable to use current locale for printing time, because all names will be printed in your native language, as well as time format settings also may be ajusted differently from the C/POSIX defaults. To solve these problems this option was introdiced.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of characters printed. </dd></dl>

</div>
</div>
<a class="anchor" id="a13ca1da1151489f1eee7770296f164aa"></a><!-- doxytag: member="cpl_conv.h::CPLPrintUIntBig" ref="a13ca1da1151489f1eee7770296f164aa" args="(char *, GUIntBig, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLPrintUIntBig </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pszBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GUIntBig&nbsp;</td>
          <td class="paramname"> <em>iValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nMaxLen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print GUIntBig value into specified string buffer. </p>
<p>This string will not be NULL-terminated.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszBuffer</em>&nbsp;</td><td>Pointer to the destination string buffer. Should be large enough to hold the resulting string. Note, that the string will not be NULL-terminated, so user should do this himself, if needed.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iValue</em>&nbsp;</td><td>Numerical value to print.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nMaxLen</em>&nbsp;</td><td>Maximum length of the resulting string. If string length is greater than nMaxLen, it will be truncated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of characters printed. </dd></dl>

</div>
</div>
<a class="anchor" id="acb7cd6067d35796aa1af144e5a4283b4"></a><!-- doxytag: member="cpl_conv.h::CPLProjectRelativeFilename" ref="acb7cd6067d35796aa1af144e5a4283b4" args="(const char *pszProjectDir, const char *pszSecondaryFilename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* CPLProjectRelativeFilename </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszProjectDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszSecondaryFilename</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find a file relative to a project file. </p>
<p>Given the path to a "project" directory, and a path to a secondary file referenced from that project, build a path to the secondary file that the current application can use. If the secondary path is already absolute, rather than relative, then it will be returned unaltered.</p>
<p>Examples: </p>
<pre>
 CPLProjectRelativeFilename("abc/def","tmp/abc.gif") == "abc/def/tmp/abc.gif"
 CPLProjectRelativeFilename("abc/def","/tmp/abc.gif") == "/tmp/abc.gif"
 CPLProjectRelativeFilename("/xy", "abc.gif") == "/xy/abc.gif"
 CPLProjectRelativeFilename("/abc/def","../abc.gif") == "/abc/def/../abc.gif"
 CPLProjectRelativeFilename("C:\WIN","abc.gif") == "C:\WIN\abc.gif"
 </pre><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszProjectDir</em>&nbsp;</td><td>the directory relative to which the secondary files path should be interpreted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszSecondaryFilename</em>&nbsp;</td><td>the filename (potentially with path) that is to be interpreted relative to the project directory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a composed path to the secondary file. The returned string is internal and should not be altered, freed, or depending on past the next CPL call. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ad35dbadd4f1d04bbedd66774be940f"></a><!-- doxytag: member="cpl_conv.h::CPLReadLine" ref="a0ad35dbadd4f1d04bbedd66774be940f" args="(FILE *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* CPLReadLine </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Simplified line reading from text file. </p>
<p>Read a line of text from the given file handle, taking care to capture CR and/or LF and strip off ... equivelent of DKReadLine(). Pointer to an internal buffer is returned. The application shouldn't free it, or depend on it's value past the next call to <a class="el" href="cpl__conv_8h.html#a0ad35dbadd4f1d04bbedd66774be940f" title="Simplified line reading from text file.">CPLReadLine()</a>.</p>
<p>Note that <a class="el" href="cpl__conv_8h.html#a0ad35dbadd4f1d04bbedd66774be940f" title="Simplified line reading from text file.">CPLReadLine()</a> uses VSIFGets(), so any hooking of VSI file services should apply to <a class="el" href="cpl__conv_8h.html#a0ad35dbadd4f1d04bbedd66774be940f" title="Simplified line reading from text file.">CPLReadLine()</a> as well.</p>
<p><a class="el" href="cpl__conv_8h.html#a0ad35dbadd4f1d04bbedd66774be940f" title="Simplified line reading from text file.">CPLReadLine()</a> maintains an internal buffer, which will appear as a single block memory leak in some circumstances. <a class="el" href="cpl__conv_8h.html#a0ad35dbadd4f1d04bbedd66774be940f" title="Simplified line reading from text file.">CPLReadLine()</a> may be called with a NULL FILE * at any time to free this working buffer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fp</em>&nbsp;</td><td>file pointer opened with VSIFOpen().</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to an internal buffer containing a line of text read from the file or NULL if the end of file was encountered. </dd></dl>

</div>
</div>
<a class="anchor" id="a37852d607dea3a4995be57e88415f391"></a><!-- doxytag: member="cpl_conv.h::CPLReadLine2L" ref="a37852d607dea3a4995be57e88415f391" args="(VSILFILE *, int nMaxCols, char **papszOptions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* CPLReadLine2L </td>
          <td>(</td>
          <td class="paramtype">VSILFILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nMaxCars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszOptions</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Simplified line reading from text file. </p>
<p>Similar to <a class="el" href="cpl__conv_8h.html#a0ad35dbadd4f1d04bbedd66774be940f" title="Simplified line reading from text file.">CPLReadLine()</a>, but reading from a large file API handle.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fp</em>&nbsp;</td><td>file pointer opened with <a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file.">VSIFOpenL()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nMaxCars</em>&nbsp;</td><td>maximum number of characters allowed, or -1 for no limit. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>papszOptions</em>&nbsp;</td><td>NULL-terminated array of options. Unused for now.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to an internal buffer containing a line of text read from the file or NULL if the end of file was encountered or the maximum number of characters allowed readched.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.7.0 </dd></dl>

</div>
</div>
<a class="anchor" id="af049d0b413b82ac770d33cc76f525825"></a><!-- doxytag: member="cpl_conv.h::CPLReadLineL" ref="af049d0b413b82ac770d33cc76f525825" args="(VSILFILE *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* CPLReadLineL </td>
          <td>(</td>
          <td class="paramtype">VSILFILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Simplified line reading from text file. </p>
<p>Similar to <a class="el" href="cpl__conv_8h.html#a0ad35dbadd4f1d04bbedd66774be940f" title="Simplified line reading from text file.">CPLReadLine()</a>, but reading from a large file API handle.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fp</em>&nbsp;</td><td>file pointer opened with <a class="el" href="cpl__vsi_8h.html#ae3cfa1605ce32e78fddb534bba7742f5" title="Open file.">VSIFOpenL()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to an internal buffer containing a line of text read from the file or NULL if the end of file was encountered. </dd></dl>

</div>
</div>
<a class="anchor" id="a4fb9e0ce588e0d7360e5f54a453e6f82"></a><!-- doxytag: member="cpl_conv.h::CPLRealloc" ref="a4fb9e0ce588e0d7360e5f54a453e6f82" args="(void *, size_t) CPL_WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* CPLRealloc </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nNewSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Safe version of realloc(). </p>
<p>This function is like the C library realloc(), but raises a CE_Fatal error with <a class="el" href="cpl__error_8h.html#aad2b98dd58e4de706a245faddac90403" title="Report an error.">CPLError()</a> if it fails to allocate the desired memory. It should be used for small memory allocations that are unlikely to fail and for which the application is unwilling to test for out of memory conditions. It uses VSIRealloc() to get the memory, so any hooking of VSIRealloc() will apply to <a class="el" href="cpl__conv_8h.html#a4fb9e0ce588e0d7360e5f54a453e6f82" title="Safe version of realloc().">CPLRealloc()</a> as well. CPLFree() or VSIFree() can be used free memory allocated by <a class="el" href="cpl__conv_8h.html#a4fb9e0ce588e0d7360e5f54a453e6f82" title="Safe version of realloc().">CPLRealloc()</a>.</p>
<p>It is also safe to pass NULL in as the existing memory block for <a class="el" href="cpl__conv_8h.html#a4fb9e0ce588e0d7360e5f54a453e6f82" title="Safe version of realloc().">CPLRealloc()</a>, in which case it uses VSIMalloc() to allocate a new block.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pData</em>&nbsp;</td><td>existing memory block which should be copied to the new block. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nNewSize</em>&nbsp;</td><td>new size (in bytes) of memory block to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to allocated memory, only NULL if nNewSize is zero. </dd></dl>

</div>
</div>
<a class="anchor" id="a637fddebebefc776e5c657bcc7366b89"></a><!-- doxytag: member="cpl_conv.h::CPLResetExtension" ref="a637fddebebefc776e5c657bcc7366b89" args="(const char *, const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* CPLResetExtension </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszExt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replace the extension with the provided one. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszPath</em>&nbsp;</td><td>the input path, this string is not altered. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszExt</em>&nbsp;</td><td>the new extension to apply to the given path.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an altered filename with the new extension. Do not modify or free the returned string. The string may be destroyed by the next CPL call. </dd></dl>

</div>
</div>
<a class="anchor" id="abcdeae39a61518c9c31ecc593eeff621"></a><!-- doxytag: member="cpl_conv.h::CPLScanDouble" ref="abcdeae39a61518c9c31ecc593eeff621" args="(const char *, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CPLScanDouble </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nMaxLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extract double from string. </p>
<p>Scan up to a maximum number of characters from a string and convert the result to a double. This function uses <a class="el" href="cpl__conv_8h.html#afb5bf88066f997b1ab3b3911f5e9b722" title="Converts ASCII string to floating point number.">CPLAtof()</a> to convert string to double value, so it uses a comma as a decimal delimiter.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszString</em>&nbsp;</td><td>String containing characters to be scanned. It may be terminated with a null character.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nMaxLength</em>&nbsp;</td><td>The maximum number of character to consider as part of the number. Less characters will be considered if a null character is encountered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Double value, converted from its ASCII form. </dd></dl>

</div>
</div>
<a class="anchor" id="a338bbe67c148d2555861eb5563b17303"></a><!-- doxytag: member="cpl_conv.h::CPLScanLong" ref="a338bbe67c148d2555861eb5563b17303" args="(const char *, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long CPLScanLong </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nMaxLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scan up to a maximum number of characters from a string and convert the result to a long. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszString</em>&nbsp;</td><td>String containing characters to be scanned. It may be terminated with a null character.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nMaxLength</em>&nbsp;</td><td>The maximum number of character to consider as part of the number. Less characters will be considered if a null character is encountered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Long value, converted from its ASCII form. </dd></dl>

</div>
</div>
<a class="anchor" id="a2dea859a1f5690d25e5eb32f8d091905"></a><!-- doxytag: member="cpl_conv.h::CPLScanPointer" ref="a2dea859a1f5690d25e5eb32f8d091905" args="(const char *, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* CPLScanPointer </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nMaxLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extract pointer from string. </p>
<p>Scan up to a maximum number of characters from a string and convert the result to a pointer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszString</em>&nbsp;</td><td>String containing characters to be scanned. It may be terminated with a null character.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nMaxLength</em>&nbsp;</td><td>The maximum number of character to consider as part of the number. Less characters will be considered if a null character is encountered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer value, converted from its ASCII form. </dd></dl>

</div>
</div>
<a class="anchor" id="a9c2ddf6a8bdb1a9bf2e90e7acbea2cdc"></a><!-- doxytag: member="cpl_conv.h::CPLScanString" ref="a9c2ddf6a8bdb1a9bf2e90e7acbea2cdc" args="(const char *, int, int, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* CPLScanString </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nMaxLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bTrimSpaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bNormalize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scan up to a maximum number of characters from a given string, allocate a buffer for a new string and fill it with scanned characters. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszString</em>&nbsp;</td><td>String containing characters to be scanned. It may be terminated with a null character.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nMaxLength</em>&nbsp;</td><td>The maximum number of character to read. Less characters will be read if a null character is encountered.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bTrimSpaces</em>&nbsp;</td><td>If TRUE, trim ending spaces from the input string. Character considered as empty using isspace(3) function.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bNormalize</em>&nbsp;</td><td>If TRUE, replace ':' symbol with the '_'. It is needed if resulting string will be used in CPL dictionaries.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the resulting string buffer. Caller responsible to free this buffer with CPLFree(). </dd></dl>

</div>
</div>
<a class="anchor" id="ab4a8e6cf7a0d0f662f6cd4555b074bb5"></a><!-- doxytag: member="cpl_conv.h::CPLScanUIntBig" ref="ab4a8e6cf7a0d0f662f6cd4555b074bb5" args="(const char *, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GUIntBig CPLScanUIntBig </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nMaxLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extract big integer from string. </p>
<p>Scan up to a maximum number of characters from a string and convert the result to a GUIntBig.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszString</em>&nbsp;</td><td>String containing characters to be scanned. It may be terminated with a null character.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nMaxLength</em>&nbsp;</td><td>The maximum number of character to consider as part of the number. Less characters will be considered if a null character is encountered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>GUIntBig value, converted from its ASCII form. </dd></dl>

</div>
</div>
<a class="anchor" id="ac6e9643c26ab4ee22df95e3dd18c959a"></a><!-- doxytag: member="cpl_conv.h::CPLScanULong" ref="ac6e9643c26ab4ee22df95e3dd18c959a" args="(const char *, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long CPLScanULong </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nMaxLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scan up to a maximum number of characters from a string and convert the result to a unsigned long. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszString</em>&nbsp;</td><td>String containing characters to be scanned. It may be terminated with a null character.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nMaxLength</em>&nbsp;</td><td>The maximum number of character to consider as part of the number. Less characters will be considered if a null character is encountered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Unsigned long value, converted from its ASCII form. </dd></dl>

</div>
</div>
<a class="anchor" id="aa0cd1a68fe4f2fc7874cd2da605c36ce"></a><!-- doxytag: member="cpl_conv.h::CPLSetConfigOption" ref="aa0cd1a68fe4f2fc7874cd2da605c36ce" args="(const char *, const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CPLSetConfigOption </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a configuration option for GDAL/OGR use. </p>
<p>Those options are defined as a (key, value) couple. The value corresponding to a key can be got later with the <a class="el" href="cpl__conv_8h.html#a21a509890bf6632f1b1d836c1d3bb970" title="Get the value of a configuration option.">CPLGetConfigOption()</a> method.</p>
<p>This mechanism is similar to environment variables, but options set with <a class="el" href="cpl__conv_8h.html#aa0cd1a68fe4f2fc7874cd2da605c36ce" title="Set a configuration option for GDAL/OGR use.">CPLSetConfigOption()</a> overrides, for <a class="el" href="cpl__conv_8h.html#a21a509890bf6632f1b1d836c1d3bb970" title="Get the value of a configuration option.">CPLGetConfigOption()</a> point of view, values defined in the environment.</p>
<p>If <a class="el" href="cpl__conv_8h.html#aa0cd1a68fe4f2fc7874cd2da605c36ce" title="Set a configuration option for GDAL/OGR use.">CPLSetConfigOption()</a> is called several times with the same key, the value provided during the last call will be used.</p>
<p>Options can also be passed on the command line of most GDAL utilities with the with '--config KEY VALUE'. For example, ogrinfo --config CPL_DEBUG ON ~/data/test/point.shp</p>
<p>This function can also be used to clear a setting by passing NULL as the value (note: passing NULL will not unset an existing environment variable; it will just unset a value previously set by <a class="el" href="cpl__conv_8h.html#aa0cd1a68fe4f2fc7874cd2da605c36ce" title="Set a configuration option for GDAL/OGR use.">CPLSetConfigOption()</a>).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszKey</em>&nbsp;</td><td>the key of the option </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszValue</em>&nbsp;</td><td>the value of the option, or NULL to clear a setting.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://trac.osgeo.org/gdal/wiki/ConfigOptions">http://trac.osgeo.org/gdal/wiki/ConfigOptions</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7e7dc242d58045315d7672e252e62e7d"></a><!-- doxytag: member="cpl_conv.h::CPLsetlocale" ref="a7e7dc242d58045315d7672e252e62e7d" args="(int category, const char *locale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* CPLsetlocale </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>category</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>locale</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prevents parallel executions of setlocale(). </p>
<p>Calling setlocale() concurrently from two or more threads is a potential data race. A mutex is used to provide a critical region so that only one thread at a time can be executing setlocale().</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>category</em>&nbsp;</td><td>See your compiler's documentation on setlocale. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>locale</em>&nbsp;</td><td>See your compiler's documentation on setlocale.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>See your compiler's documentation on setlocale. </dd></dl>

</div>
</div>
<a class="anchor" id="ac8f0d1de8f2b2069c6ea9352ca4442cd"></a><!-- doxytag: member="cpl_conv.h::CPLSetThreadLocalConfigOption" ref="ac8f0d1de8f2b2069c6ea9352ca4442cd" args="(const char *pszKey, const char *pszValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CPLSetThreadLocalConfigOption </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a configuration option for GDAL/OGR use. </p>
<p>Those options are defined as a (key, value) couple. The value corresponding to a key can be got later with the <a class="el" href="cpl__conv_8h.html#a21a509890bf6632f1b1d836c1d3bb970" title="Get the value of a configuration option.">CPLGetConfigOption()</a> method.</p>
<p>This function sets the configuration option that only applies in the current thread, as opposed to <a class="el" href="cpl__conv_8h.html#aa0cd1a68fe4f2fc7874cd2da605c36ce" title="Set a configuration option for GDAL/OGR use.">CPLSetConfigOption()</a> which sets an option that applies on all threads.</p>
<p>This function can also be used to clear a setting by passing NULL as the value (note: passing NULL will not unset an existing environment variable; it will just unset a value previously set by <a class="el" href="cpl__conv_8h.html#ac8f0d1de8f2b2069c6ea9352ca4442cd" title="Set a configuration option for GDAL/OGR use.">CPLSetThreadLocalConfigOption()</a>).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszKey</em>&nbsp;</td><td>the key of the option </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszValue</em>&nbsp;</td><td>the value of the option, or NULL to clear a setting. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a01066c0db2a09289d7b14085882d2389"></a><!-- doxytag: member="cpl_conv.h::CPLStrdup" ref="a01066c0db2a09289d7b14085882d2389" args="(const char *) CPL_WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* CPLStrdup </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszString</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Safe version of strdup() function. </p>
<p>This function is similar to the C library strdup() function, but if the memory allocation fails it will issue a CE_Fatal error with <a class="el" href="cpl__error_8h.html#aad2b98dd58e4de706a245faddac90403" title="Report an error.">CPLError()</a> instead of returning NULL. It uses VSIStrdup(), so any hooking of that function will apply to <a class="el" href="cpl__conv_8h.html#a01066c0db2a09289d7b14085882d2389" title="Safe version of strdup() function.">CPLStrdup()</a> as well. Memory allocated with <a class="el" href="cpl__conv_8h.html#a01066c0db2a09289d7b14085882d2389" title="Safe version of strdup() function.">CPLStrdup()</a> can be freed with CPLFree() or VSIFree().</p>
<p>It is also safe to pass a NULL string into <a class="el" href="cpl__conv_8h.html#a01066c0db2a09289d7b14085882d2389" title="Safe version of strdup() function.">CPLStrdup()</a>. <a class="el" href="cpl__conv_8h.html#a01066c0db2a09289d7b14085882d2389" title="Safe version of strdup() function.">CPLStrdup()</a> will allocate and return a zero length string (as opposed to a NULL string).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszString</em>&nbsp;</td><td>input string to be duplicated. May be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to a newly allocated copy of the string. Free with CPLFree() or VSIFree(). </dd></dl>

</div>
</div>
<a class="anchor" id="a1dac5cfc5a7e9dbcf511b461812d89b9"></a><!-- doxytag: member="cpl_conv.h::CPLStrlwr" ref="a1dac5cfc5a7e9dbcf511b461812d89b9" args="(char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* CPLStrlwr </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pszString</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert each characters of the string to lower case. </p>
<p>For example, "ABcdE" will be converted to "abcde". This function is locale dependent.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszString</em>&nbsp;</td><td>input string to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to the same string, pszString. </dd></dl>

</div>
</div>
<a class="anchor" id="a2388e43fb089a354eb3583016b2a3b00"></a><!-- doxytag: member="cpl_conv.h::CPLStrtod" ref="a2388e43fb089a354eb3583016b2a3b00" args="(const char *, char **)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CPLStrtod </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>endptr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts ASCII string to floating point number. </p>
<p>This function converts the initial portion of the string pointed to by nptr to double floating point representation. This function does the same as standard strtod(3), but does not take locale in account. That means, the decimal delimiter is always '.' (decimal point). Use <a class="el" href="cpl__conv_8h.html#ac96c5f1823c54ef96b5783208c817817" title="Converts ASCII string to floating point number using specified delimiter.">CPLStrtodDelim()</a> function if you want to specify custom delimiter. Also see notes for <a class="el" href="cpl__conv_8h.html#afb5bf88066f997b1ab3b3911f5e9b722" title="Converts ASCII string to floating point number.">CPLAtof()</a> function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nptr</em>&nbsp;</td><td>Pointer to string to convert. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>endptr</em>&nbsp;</td><td>If is not NULL, a pointer to the character after the last character used in the conversion is stored in the location referenced by endptr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Converted value, if any. </dd></dl>

</div>
</div>
<a class="anchor" id="ac96c5f1823c54ef96b5783208c817817"></a><!-- doxytag: member="cpl_conv.h::CPLStrtodDelim" ref="ac96c5f1823c54ef96b5783208c817817" args="(const char *, char **, char)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CPLStrtodDelim </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>endptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>point</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts ASCII string to floating point number using specified delimiter. </p>
<p>This function converts the initial portion of the string pointed to by nptr to double floating point representation. This function does the same as standard strtod(3), but does not take locale in account. Instead of locale defined decimal delimiter you can specify your own one. Also see notes for <a class="el" href="cpl__conv_8h.html#afb5bf88066f997b1ab3b3911f5e9b722" title="Converts ASCII string to floating point number.">CPLAtof()</a> function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nptr</em>&nbsp;</td><td>Pointer to string to convert. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>endptr</em>&nbsp;</td><td>If is not NULL, a pointer to the character after the last character used in the conversion is stored in the location referenced by endptr. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>point</em>&nbsp;</td><td>Decimal delimiter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Converted value, if any. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ccda187ed172fd6e33cd98223328531"></a><!-- doxytag: member="cpl_conv.h::CPLStrtof" ref="a1ccda187ed172fd6e33cd98223328531" args="(const char *, char **)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float CPLStrtof </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>endptr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts ASCII string to floating point number. </p>
<p>This function converts the initial portion of the string pointed to by nptr to single floating point representation. This function does the same as standard strtof(3), but does not take locale in account. That means, the decimal delimiter is always '.' (decimal point). Use <a class="el" href="cpl__conv_8h.html#a3a102a1417c98a242900fb8c0076fc1b" title="Converts ASCII string to floating point number using specified delimiter.">CPLStrtofDelim()</a> function if you want to specify custom delimiter. Also see notes for <a class="el" href="cpl__conv_8h.html#afb5bf88066f997b1ab3b3911f5e9b722" title="Converts ASCII string to floating point number.">CPLAtof()</a> function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nptr</em>&nbsp;</td><td>Pointer to string to convert. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>endptr</em>&nbsp;</td><td>If is not NULL, a pointer to the character after the last character used in the conversion is stored in the location referenced by endptr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Converted value, if any. </dd></dl>

</div>
</div>
<a class="anchor" id="a3a102a1417c98a242900fb8c0076fc1b"></a><!-- doxytag: member="cpl_conv.h::CPLStrtofDelim" ref="a3a102a1417c98a242900fb8c0076fc1b" args="(const char *, char **, char)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float CPLStrtofDelim </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>endptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>point</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts ASCII string to floating point number using specified delimiter. </p>
<p>This function converts the initial portion of the string pointed to by nptr to single floating point representation. This function does the same as standard strtof(3), but does not take locale in account. Instead of locale defined decimal delimiter you can specify your own one. Also see notes for <a class="el" href="cpl__conv_8h.html#afb5bf88066f997b1ab3b3911f5e9b722" title="Converts ASCII string to floating point number.">CPLAtof()</a> function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nptr</em>&nbsp;</td><td>Pointer to string to convert. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>endptr</em>&nbsp;</td><td>If is not NULL, a pointer to the character after the last character used in the conversion is stored in the location referenced by endptr. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>point</em>&nbsp;</td><td>Decimal delimiter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Converted value, if any. </dd></dl>

</div>
</div>
<a class="anchor" id="aa786ff8dd95ea5b2b641de9ed53cb277"></a><!-- doxytag: member="cpl_conv.h::CPLUnlinkTree" ref="aa786ff8dd95ea5b2b641de9ed53cb277" args="(const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLUnlinkTree </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszPath</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on successful completion, -1 if function fails. </dd></dl>

</div>
</div>
<a class="anchor" id="a09f1dd41a8fa1ebc36bc6c34c7c224a3"></a><!-- doxytag: member="cpl_conv.h::CPLZLibDeflate" ref="a09f1dd41a8fa1ebc36bc6c34c7c224a3" args="(const void *ptr, size_t nBytes, int nLevel, void *outptr, size_t nOutAvailableBytes, size_t *pnOutBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* CPLZLibDeflate </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>outptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nOutAvailableBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>pnOutBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compress a buffer with ZLib DEFLATE compression. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>input buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nBytes</em>&nbsp;</td><td>size of input buffer in bytes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nLevel</em>&nbsp;</td><td>ZLib compression level (-1 for default). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>outptr</em>&nbsp;</td><td>output buffer, or NULL to let the function allocate it. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nOutAvailableBytes</em>&nbsp;</td><td>size of output buffer if provided, or ignored. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnOutBytes</em>&nbsp;</td><td>pointer to a size_t, where to store the size of the output buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output buffer (to be freed with VSIFree() if not provided) or NULL in case of error.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.10.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a066abbb8471f29f521d19f2252e9959a"></a><!-- doxytag: member="cpl_conv.h::CPLZLibInflate" ref="a066abbb8471f29f521d19f2252e9959a" args="(const void *ptr, size_t nBytes, void *outptr, size_t nOutAvailableBytes, size_t *pnOutBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* CPLZLibInflate </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>outptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nOutAvailableBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>pnOutBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Uncompress a buffer compressed with ZLib DEFLATE compression. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>input buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nBytes</em>&nbsp;</td><td>size of input buffer in bytes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>outptr</em>&nbsp;</td><td>output buffer, or NULL to let the function allocate it. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nOutAvailableBytes</em>&nbsp;</td><td>size of output buffer if provided, or ignored. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnOutBytes</em>&nbsp;</td><td>pointer to a size_t, where to store the size of the output buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output buffer (to be freed with VSIFree() if not provided) or NULL in case of error.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.10.0 </dd></dl>

</div>
</div>
</div>
<hr>

Generated for GDAL by 
<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.7.1.
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>GDAL: cpl_virtualmem.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>cpl_virtualmem.h File Reference</h1>  </div>
</div>
<div class="contents">

<p>Virtual memory management.  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="cpl__port_8h_source.html">cpl_port.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="cpl__vsi_8h_source.html">cpl_vsi.h</a>&quot;</code><br/>

<p><a href="cpl__virtualmem_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opaque type that represents a virtual memory mapping.  <a href="#aac693188a82d797c5a651f275fddab82"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#a575c56435cea278a5bf98bf2c21e7b8f">CPLVirtualMemCachePageCbk</a> )(<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt, size_t nOffset, void *pPageToFill, size_t nToFill, void *pUserData)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback triggered when a still unmapped page of virtual memory is accessed.  <a href="#a575c56435cea278a5bf98bf2c21e7b8f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#aec0c6ca7bd8ad956b6f62faefdcc5b66">CPLVirtualMemUnCachePageCbk</a> )(<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt, size_t nOffset, const void *pPageToBeEvicted, size_t nToBeEvicted, void *pUserData)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback triggered when a dirty mapped page is going to be freed.  <a href="#aec0c6ca7bd8ad956b6f62faefdcc5b66"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#aba9d54d83138551ff3067d8e23d8448c">CPLVirtualMemFreeUserData</a> )(void *pUserData)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback triggered when a virtual memory mapping is destroyed.  <a href="#aba9d54d83138551ff3067d8e23d8448c"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#aeba7fc305d946740f9e88513220c73a1">CPLVirtualMemAccessMode</a> { <a class="el" href="cpl__virtualmem_8h.html#aeba7fc305d946740f9e88513220c73a1ac449c40cb0760b72f362e2cf4cd3da79">VIRTUALMEM_READONLY</a>, 
<a class="el" href="cpl__virtualmem_8h.html#aeba7fc305d946740f9e88513220c73a1a67628910ddcd5816bf230061adc45d97">VIRTUALMEM_READONLY_ENFORCED</a>, 
<a class="el" href="cpl__virtualmem_8h.html#aeba7fc305d946740f9e88513220c73a1aa6486140a01b52ef723a17a39f9e1169">VIRTUALMEM_READWRITE</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Access mode of a virtual memory mapping. </p>
 <a href="cpl__virtualmem_8h.html#aeba7fc305d946740f9e88513220c73a1">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#af7db376bca14d8aeb40dc171b969fbad">CPLGetPageSize</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the size of a page of virtual memory.  <a href="#af7db376bca14d8aeb40dc171b969fbad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#ae3f4f669f48fc2755a43566524725878">CPLVirtualMemNew</a> (size_t nSize, size_t nCacheSize, size_t nPageSizeHint, int bSingleThreadUsage, <a class="el" href="cpl__virtualmem_8h.html#aeba7fc305d946740f9e88513220c73a1">CPLVirtualMemAccessMode</a> eAccessMode, <a class="el" href="cpl__virtualmem_8h.html#a575c56435cea278a5bf98bf2c21e7b8f">CPLVirtualMemCachePageCbk</a> pfnCachePage, <a class="el" href="cpl__virtualmem_8h.html#aec0c6ca7bd8ad956b6f62faefdcc5b66">CPLVirtualMemUnCachePageCbk</a> pfnUnCachePage, <a class="el" href="cpl__virtualmem_8h.html#aba9d54d83138551ff3067d8e23d8448c">CPLVirtualMemFreeUserData</a> pfnFreeUserData, void *pCbkUserData)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new virtual memory mapping.  <a href="#ae3f4f669f48fc2755a43566524725878"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#a00d1f6e9104464fc2052be91c2a20cd2">CPLIsVirtualMemFileMapAvailable</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return if virtual memory mapping of a file is available.  <a href="#a00d1f6e9104464fc2052be91c2a20cd2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#a51a1fc455ba063709c4c7acd3def44ea">CPLVirtualMemFileMapNew</a> (VSILFILE *fp, vsi_l_offset nOffset, vsi_l_offset nLength, <a class="el" href="cpl__virtualmem_8h.html#aeba7fc305d946740f9e88513220c73a1">CPLVirtualMemAccessMode</a> eAccessMode, <a class="el" href="cpl__virtualmem_8h.html#aba9d54d83138551ff3067d8e23d8448c">CPLVirtualMemFreeUserData</a> pfnFreeUserData, void *pCbkUserData)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new virtual memory mapping from a file.  <a href="#a51a1fc455ba063709c4c7acd3def44ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#abc5e12022cf50ba82ab31d5d8cba2fa7">CPLVirtualMemDerivedNew</a> (<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *pVMemBase, vsi_l_offset nOffset, vsi_l_offset nSize, <a class="el" href="cpl__virtualmem_8h.html#aba9d54d83138551ff3067d8e23d8448c">CPLVirtualMemFreeUserData</a> pfnFreeUserData, void *pCbkUserData)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new virtual memory mapping derived from an other virtual memory mapping.  <a href="#abc5e12022cf50ba82ab31d5d8cba2fa7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#ac7e397a190759c66d3ee1130a20fb279">CPLVirtualMemFree</a> (<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a virtual memory mapping.  <a href="#ac7e397a190759c66d3ee1130a20fb279"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#a36fbbf1e7a217655fdd19231154a8cfa">CPLVirtualMemGetAddr</a> (<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the pointer to the start of a virtual memory mapping.  <a href="#a36fbbf1e7a217655fdd19231154a8cfa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#a0b3e9db855ad1ee7bde1657d91209b72">CPLVirtualMemGetSize</a> (<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the size of the virtual memory mapping.  <a href="#a0b3e9db855ad1ee7bde1657d91209b72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#a53512758f6e597b095dcd8a146d7838e">CPLVirtualMemIsFileMapping</a> (<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return if the virtal memory mapping is a direct file mapping.  <a href="#a53512758f6e597b095dcd8a146d7838e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__virtualmem_8h.html#aeba7fc305d946740f9e88513220c73a1">CPLVirtualMemAccessMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#a8c8d6a1df28c479c9dbb4c1086e570f3">CPLVirtualMemGetAccessMode</a> (<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the access mode of the virtual memory mapping.  <a href="#a8c8d6a1df28c479c9dbb4c1086e570f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#aee835258a343e77447f54b9e078cddc5">CPLVirtualMemGetPageSize</a> (<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the page size associated to a virtual memory mapping.  <a href="#aee835258a343e77447f54b9e078cddc5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#abdf17d57f9361d6b71341b96c188e904">CPLVirtualMemIsAccessThreadSafe</a> (<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return TRUE if this memory mapping can be accessed safely from concurrent threads.  <a href="#abdf17d57f9361d6b71341b96c188e904"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#aa94d9fee83792450f556ea68f3a27f31">CPLVirtualMemDeclareThread</a> (<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declare that a thread will access a virtual memory mapping.  <a href="#aa94d9fee83792450f556ea68f3a27f31"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#a60a2dba5c24c0c7c478202928fecf93c">CPLVirtualMemUnDeclareThread</a> (<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declare that a thread will stop accessing a virtual memory mapping.  <a href="#a60a2dba5c24c0c7c478202928fecf93c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#a4f98d8a992f8bf393719c51c5551c07e">CPLVirtualMemPin</a> (<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt, void *pAddr, size_t nSize, int bWriteOp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make sure that a region of virtual memory will be realized.  <a href="#a4f98d8a992f8bf393719c51c5551c07e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#a33e690c9c5b7f636cd8c0254eba63cb8">CPLVirtualMemManagerTerminate</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cleanup any resource and handlers related to virtual memory.  <a href="#a33e690c9c5b7f636cd8c0254eba63cb8"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Virtual memory management. </p>
<p>This file provides mechanism to define virtual memory mappings, whose content is allocated transparently and filled on-the-fly. Those virtual memory mappings can be much larger than the available RAM, but only parts of the virtual memory mapping, in the limit of the allowed the cache size, will actually be physically allocated.</p>
<p>This exploits low-level mechanisms of the operating system (virtual memory allocation, page protection and handler of virtual memory exceptions).</p>
<p>It is also possible to create a virtual memory mapping from a file or part of a file.</p>
<p>The current implementation is Linux only. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="aac693188a82d797c5a651f275fddab82"></a><!-- doxytag: member="cpl_virtualmem.h::CPLVirtualMem" ref="aac693188a82d797c5a651f275fddab82" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> <a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Opaque type that represents a virtual memory mapping. </p>

</div>
</div>
<a class="anchor" id="a575c56435cea278a5bf98bf2c21e7b8f"></a><!-- doxytag: member="cpl_virtualmem.h::CPLVirtualMemCachePageCbk" ref="a575c56435cea278a5bf98bf2c21e7b8f" args=")(CPLVirtualMem *ctxt, size_t nOffset, void *pPageToFill, size_t nToFill, void *pUserData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="cpl__virtualmem_8h.html#a575c56435cea278a5bf98bf2c21e7b8f">CPLVirtualMemCachePageCbk</a>)(<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt, size_t nOffset, void *pPageToFill, size_t nToFill, void *pUserData)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback triggered when a still unmapped page of virtual memory is accessed. </p>
<p>The callback has the responsibility of filling the page with relevant values</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctxt</em>&nbsp;</td><td>virtual memory handle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nOffset</em>&nbsp;</td><td>offset of the page in the memory mapping. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pPageToFill</em>&nbsp;</td><td>address of the page to fill. Note that the address might be a temporary location, and not at <a class="el" href="cpl__virtualmem_8h.html#a36fbbf1e7a217655fdd19231154a8cfa" title="Return the pointer to the start of a virtual memory mapping.">CPLVirtualMemGetAddr()</a> + nOffset. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nToFill</em>&nbsp;</td><td>number of bytes of the page. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pUserData</em>&nbsp;</td><td>user data that was passed to <a class="el" href="cpl__virtualmem_8h.html#ae3f4f669f48fc2755a43566524725878" title="Create a new virtual memory mapping.">CPLVirtualMemNew()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aba9d54d83138551ff3067d8e23d8448c"></a><!-- doxytag: member="cpl_virtualmem.h::CPLVirtualMemFreeUserData" ref="aba9d54d83138551ff3067d8e23d8448c" args=")(void *pUserData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="cpl__virtualmem_8h.html#aba9d54d83138551ff3067d8e23d8448c">CPLVirtualMemFreeUserData</a>)(void *pUserData)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback triggered when a virtual memory mapping is destroyed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pUserData</em>&nbsp;</td><td>user data that was passed to <a class="el" href="cpl__virtualmem_8h.html#ae3f4f669f48fc2755a43566524725878" title="Create a new virtual memory mapping.">CPLVirtualMemNew()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aec0c6ca7bd8ad956b6f62faefdcc5b66"></a><!-- doxytag: member="cpl_virtualmem.h::CPLVirtualMemUnCachePageCbk" ref="aec0c6ca7bd8ad956b6f62faefdcc5b66" args=")(CPLVirtualMem *ctxt, size_t nOffset, const void *pPageToBeEvicted, size_t nToBeEvicted, void *pUserData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="cpl__virtualmem_8h.html#aec0c6ca7bd8ad956b6f62faefdcc5b66">CPLVirtualMemUnCachePageCbk</a>)(<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt, size_t nOffset, const void *pPageToBeEvicted, size_t nToBeEvicted, void *pUserData)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback triggered when a dirty mapped page is going to be freed. </p>
<p>(saturation of cache, or termination of the virtual memory mapping).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctxt</em>&nbsp;</td><td>virtual memory handle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nOffset</em>&nbsp;</td><td>offset of the page in the memory mapping. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pPageToBeEvicted</em>&nbsp;</td><td>address of the page that will be flushed. Note that the address might be a temporary location, and not at <a class="el" href="cpl__virtualmem_8h.html#a36fbbf1e7a217655fdd19231154a8cfa" title="Return the pointer to the start of a virtual memory mapping.">CPLVirtualMemGetAddr()</a> + nOffset. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nToBeEvicted</em>&nbsp;</td><td>number of bytes of the page. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pUserData</em>&nbsp;</td><td>user data that was passed to <a class="el" href="cpl__virtualmem_8h.html#ae3f4f669f48fc2755a43566524725878" title="Create a new virtual memory mapping.">CPLVirtualMemNew()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="aeba7fc305d946740f9e88513220c73a1"></a><!-- doxytag: member="cpl_virtualmem.h::CPLVirtualMemAccessMode" ref="aeba7fc305d946740f9e88513220c73a1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="cpl__virtualmem_8h.html#aeba7fc305d946740f9e88513220c73a1">CPLVirtualMemAccessMode</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access mode of a virtual memory mapping. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="aeba7fc305d946740f9e88513220c73a1ac449c40cb0760b72f362e2cf4cd3da79"></a><!-- doxytag: member="VIRTUALMEM_READONLY" ref="aeba7fc305d946740f9e88513220c73a1ac449c40cb0760b72f362e2cf4cd3da79" args="" -->VIRTUALMEM_READONLY</em>&nbsp;</td><td>
<p>The mapping is meant at being read-only, but writes will not be prevented. Note that any content written will be lost. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aeba7fc305d946740f9e88513220c73a1a67628910ddcd5816bf230061adc45d97"></a><!-- doxytag: member="VIRTUALMEM_READONLY_ENFORCED" ref="aeba7fc305d946740f9e88513220c73a1a67628910ddcd5816bf230061adc45d97" args="" -->VIRTUALMEM_READONLY_ENFORCED</em>&nbsp;</td><td>
<p>The mapping is meant at being read-only, and this will be enforced through the operating system page protection mechanism. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aeba7fc305d946740f9e88513220c73a1aa6486140a01b52ef723a17a39f9e1169"></a><!-- doxytag: member="VIRTUALMEM_READWRITE" ref="aeba7fc305d946740f9e88513220c73a1aa6486140a01b52ef723a17a39f9e1169" args="" -->VIRTUALMEM_READWRITE</em>&nbsp;</td><td>
<p>The mapping is meant at being read-write, and modified pages can be saved thanks to the pfnUnCachePage callback </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="af7db376bca14d8aeb40dc171b969fbad"></a><!-- doxytag: member="cpl_virtualmem.h::CPLGetPageSize" ref="af7db376bca14d8aeb40dc171b969fbad" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t CPLGetPageSize </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the size of a page of virtual memory. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the page size.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a00d1f6e9104464fc2052be91c2a20cd2"></a><!-- doxytag: member="cpl_virtualmem.h::CPLIsVirtualMemFileMapAvailable" ref="a00d1f6e9104464fc2052be91c2a20cd2" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLIsVirtualMemFileMapAvailable </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return if virtual memory mapping of a file is available. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if virtual memory mapping of a file is available. </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="aa94d9fee83792450f556ea68f3a27f31"></a><!-- doxytag: member="cpl_virtualmem.h::CPLVirtualMemDeclareThread" ref="aa94d9fee83792450f556ea68f3a27f31" args="(CPLVirtualMem *ctxt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CPLVirtualMemDeclareThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *&nbsp;</td>
          <td class="paramname"> <em>ctxt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Declare that a thread will access a virtual memory mapping. </p>
<p>This function must be called by a thread that wants to access the content of a virtual memory mapping, except if the virtual memory mapping has been created with bSingleThreadUsage = TRUE.</p>
<p>This function must be paired with <a class="el" href="cpl__virtualmem_8h.html#a60a2dba5c24c0c7c478202928fecf93c" title="Declare that a thread will stop accessing a virtual memory mapping.">CPLVirtualMemUnDeclareThread()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctxt</em>&nbsp;</td><td>context returned by <a class="el" href="cpl__virtualmem_8h.html#ae3f4f669f48fc2755a43566524725878" title="Create a new virtual memory mapping.">CPLVirtualMemNew()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="abc5e12022cf50ba82ab31d5d8cba2fa7"></a><!-- doxytag: member="cpl_virtualmem.h::CPLVirtualMemDerivedNew" ref="abc5e12022cf50ba82ab31d5d8cba2fa7" args="(CPLVirtualMem *pVMemBase, vsi_l_offset nOffset, vsi_l_offset nSize, CPLVirtualMemFreeUserData pfnFreeUserData, void *pCbkUserData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a>* CPLVirtualMemDerivedNew </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *&nbsp;</td>
          <td class="paramname"> <em>pVMemBase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vsi_l_offset&nbsp;</td>
          <td class="paramname"> <em>nOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vsi_l_offset&nbsp;</td>
          <td class="paramname"> <em>nSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aba9d54d83138551ff3067d8e23d8448c">CPLVirtualMemFreeUserData</a>&nbsp;</td>
          <td class="paramname"> <em>pfnFreeUserData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pCbkUserData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new virtual memory mapping derived from an other virtual memory mapping. </p>
<p>This may be usefull in case of creating mapping for pixel interleaved data.</p>
<p>The new mapping takes a reference on the base mapping.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pVMemBase</em>&nbsp;</td><td>Base virtual memory mapping </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nOffset</em>&nbsp;</td><td>Offset in the base virtual memory mapping from which to start the new mapping. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nSize</em>&nbsp;</td><td>Size of the base virtual memory mapping to expose in the the new mapping. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnFreeUserData</em>&nbsp;</td><td>callback that is called when the object is destroyed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pCbkUserData</em>&nbsp;</td><td>user data passed to pfnFreeUserData. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a virtual memory object that must be freed by <a class="el" href="cpl__virtualmem_8h.html#ac7e397a190759c66d3ee1130a20fb279" title="Free a virtual memory mapping.">CPLVirtualMemFree()</a>, or NULL in case of failure.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a51a1fc455ba063709c4c7acd3def44ea"></a><!-- doxytag: member="cpl_virtualmem.h::CPLVirtualMemFileMapNew" ref="a51a1fc455ba063709c4c7acd3def44ea" args="(VSILFILE *fp, vsi_l_offset nOffset, vsi_l_offset nLength, CPLVirtualMemAccessMode eAccessMode, CPLVirtualMemFreeUserData pfnFreeUserData, void *pCbkUserData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a>* CPLVirtualMemFileMapNew </td>
          <td>(</td>
          <td class="paramtype">VSILFILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vsi_l_offset&nbsp;</td>
          <td class="paramname"> <em>nOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vsi_l_offset&nbsp;</td>
          <td class="paramname"> <em>nLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aeba7fc305d946740f9e88513220c73a1">CPLVirtualMemAccessMode</a>&nbsp;</td>
          <td class="paramname"> <em>eAccessMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aba9d54d83138551ff3067d8e23d8448c">CPLVirtualMemFreeUserData</a>&nbsp;</td>
          <td class="paramname"> <em>pfnFreeUserData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pCbkUserData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new virtual memory mapping from a file. </p>
<p>The file must be a "real" file recognized by the operating system, and not a VSI extended virtual file.</p>
<p>In VIRTUALMEM_READWRITE mode, updates to the memory mapping will be written in the file.</p>
<p>On Linux AMD64 platforms, the maximum value for nLength is 128 TB. On Linux x86 platforms, the maximum value for nLength is 2 GB.</p>
<p>Only supported on Linux for now.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fp</em>&nbsp;</td><td>Virtual file handle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nOffset</em>&nbsp;</td><td>Offset in the file to start the mapping from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nLength</em>&nbsp;</td><td>Length of the portion of the file to map into memory. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eAccessMode</em>&nbsp;</td><td>Permission to use for the virtual memory mapping. This must be consistant with how the file has been opened. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnFreeUserData</em>&nbsp;</td><td>callback that is called when the object is destroyed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pCbkUserData</em>&nbsp;</td><td>user data passed to pfnFreeUserData. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a virtual memory object that must be freed by <a class="el" href="cpl__virtualmem_8h.html#ac7e397a190759c66d3ee1130a20fb279" title="Free a virtual memory mapping.">CPLVirtualMemFree()</a>, or NULL in case of failure.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ac7e397a190759c66d3ee1130a20fb279"></a><!-- doxytag: member="cpl_virtualmem.h::CPLVirtualMemFree" ref="ac7e397a190759c66d3ee1130a20fb279" args="(CPLVirtualMem *ctxt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CPLVirtualMemFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *&nbsp;</td>
          <td class="paramname"> <em>ctxt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free a virtual memory mapping. </p>
<p>The pointer returned by <a class="el" href="cpl__virtualmem_8h.html#a36fbbf1e7a217655fdd19231154a8cfa" title="Return the pointer to the start of a virtual memory mapping.">CPLVirtualMemGetAddr()</a> will no longer be valid. If the virtual memory mapping was created with read/write permissions and that they are dirty (i.e. modified) pages, they will be flushed through the pfnUnCachePage callback before being freed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctxt</em>&nbsp;</td><td>context returned by <a class="el" href="cpl__virtualmem_8h.html#ae3f4f669f48fc2755a43566524725878" title="Create a new virtual memory mapping.">CPLVirtualMemNew()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a8c8d6a1df28c479c9dbb4c1086e570f3"></a><!-- doxytag: member="cpl_virtualmem.h::CPLVirtualMemGetAccessMode" ref="a8c8d6a1df28c479c9dbb4c1086e570f3" args="(CPLVirtualMem *ctxt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__virtualmem_8h.html#aeba7fc305d946740f9e88513220c73a1">CPLVirtualMemAccessMode</a> CPLVirtualMemGetAccessMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *&nbsp;</td>
          <td class="paramname"> <em>ctxt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the access mode of the virtual memory mapping. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctxt</em>&nbsp;</td><td>context returned by <a class="el" href="cpl__virtualmem_8h.html#ae3f4f669f48fc2755a43566524725878" title="Create a new virtual memory mapping.">CPLVirtualMemNew()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the access mode of the virtual memory mapping.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a36fbbf1e7a217655fdd19231154a8cfa"></a><!-- doxytag: member="cpl_virtualmem.h::CPLVirtualMemGetAddr" ref="a36fbbf1e7a217655fdd19231154a8cfa" args="(CPLVirtualMem *ctxt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* CPLVirtualMemGetAddr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *&nbsp;</td>
          <td class="paramname"> <em>ctxt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the pointer to the start of a virtual memory mapping. </p>
<p>The bytes in the range [p:p+CPLVirtualMemGetSize()-1] where p is the pointer returned by this function will be valid, until <a class="el" href="cpl__virtualmem_8h.html#ac7e397a190759c66d3ee1130a20fb279" title="Free a virtual memory mapping.">CPLVirtualMemFree()</a> is called.</p>
<p>Note that if a range of bytes used as an argument of a system call (such as read() or write()) contains pages that have not been "realized", the system call will fail with EFAULT. <a class="el" href="cpl__virtualmem_8h.html#a4f98d8a992f8bf393719c51c5551c07e" title="Make sure that a region of virtual memory will be realized.">CPLVirtualMemPin()</a> can be used to work around this issue.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctxt</em>&nbsp;</td><td>context returned by <a class="el" href="cpl__virtualmem_8h.html#ae3f4f669f48fc2755a43566524725878" title="Create a new virtual memory mapping.">CPLVirtualMemNew()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the pointer to the start of a virtual memory mapping.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="aee835258a343e77447f54b9e078cddc5"></a><!-- doxytag: member="cpl_virtualmem.h::CPLVirtualMemGetPageSize" ref="aee835258a343e77447f54b9e078cddc5" args="(CPLVirtualMem *ctxt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t CPLVirtualMemGetPageSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *&nbsp;</td>
          <td class="paramname"> <em>ctxt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the page size associated to a virtual memory mapping. </p>
<p>The value returned will be at least <a class="el" href="cpl__virtualmem_8h.html#af7db376bca14d8aeb40dc171b969fbad" title="Return the size of a page of virtual memory.">CPLGetPageSize()</a>, but potentially larger.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctxt</em>&nbsp;</td><td>context returned by <a class="el" href="cpl__virtualmem_8h.html#ae3f4f669f48fc2755a43566524725878" title="Create a new virtual memory mapping.">CPLVirtualMemNew()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the page size</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a0b3e9db855ad1ee7bde1657d91209b72"></a><!-- doxytag: member="cpl_virtualmem.h::CPLVirtualMemGetSize" ref="a0b3e9db855ad1ee7bde1657d91209b72" args="(CPLVirtualMem *ctxt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t CPLVirtualMemGetSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *&nbsp;</td>
          <td class="paramname"> <em>ctxt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the size of the virtual memory mapping. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctxt</em>&nbsp;</td><td>context returned by <a class="el" href="cpl__virtualmem_8h.html#ae3f4f669f48fc2755a43566524725878" title="Create a new virtual memory mapping.">CPLVirtualMemNew()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the size of the virtual memory mapping.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="abdf17d57f9361d6b71341b96c188e904"></a><!-- doxytag: member="cpl_virtualmem.h::CPLVirtualMemIsAccessThreadSafe" ref="abdf17d57f9361d6b71341b96c188e904" args="(CPLVirtualMem *ctxt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLVirtualMemIsAccessThreadSafe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *&nbsp;</td>
          <td class="paramname"> <em>ctxt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return TRUE if this memory mapping can be accessed safely from concurrent threads. </p>
<p>The situation that can cause problems is when several threads try to access a page of the mapping that is not yet mapped.</p>
<p>The return value of this function depends on whether bSingleThreadUsage has been set of not in <a class="el" href="cpl__virtualmem_8h.html#ae3f4f669f48fc2755a43566524725878" title="Create a new virtual memory mapping.">CPLVirtualMemNew()</a> and/or the implementation.</p>
<p>On Linux, this will always return TRUE if bSingleThreadUsage = FALSE.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctxt</em>&nbsp;</td><td>context returned by <a class="el" href="cpl__virtualmem_8h.html#ae3f4f669f48fc2755a43566524725878" title="Create a new virtual memory mapping.">CPLVirtualMemNew()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if this memory mapping can be accessed safely from concurrent threads.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a53512758f6e597b095dcd8a146d7838e"></a><!-- doxytag: member="cpl_virtualmem.h::CPLVirtualMemIsFileMapping" ref="a53512758f6e597b095dcd8a146d7838e" args="(CPLVirtualMem *ctxt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLVirtualMemIsFileMapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *&nbsp;</td>
          <td class="paramname"> <em>ctxt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return if the virtal memory mapping is a direct file mapping. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctxt</em>&nbsp;</td><td>context returned by <a class="el" href="cpl__virtualmem_8h.html#ae3f4f669f48fc2755a43566524725878" title="Create a new virtual memory mapping.">CPLVirtualMemNew()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the virtal memory mapping is a direct file mapping.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a33e690c9c5b7f636cd8c0254eba63cb8"></a><!-- doxytag: member="cpl_virtualmem.h::CPLVirtualMemManagerTerminate" ref="a33e690c9c5b7f636cd8c0254eba63cb8" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CPLVirtualMemManagerTerminate </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cleanup any resource and handlers related to virtual memory. </p>
<p>This function must be called after the last CPLVirtualMem object has been freed.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ae3f4f669f48fc2755a43566524725878"></a><!-- doxytag: member="cpl_virtualmem.h::CPLVirtualMemNew" ref="ae3f4f669f48fc2755a43566524725878" args="(size_t nSize, size_t nCacheSize, size_t nPageSizeHint, int bSingleThreadUsage, CPLVirtualMemAccessMode eAccessMode, CPLVirtualMemCachePageCbk pfnCachePage, CPLVirtualMemUnCachePageCbk pfnUnCachePage, CPLVirtualMemFreeUserData pfnFreeUserData, void *pCbkUserData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a>* CPLVirtualMemNew </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nCacheSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nPageSizeHint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bSingleThreadUsage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aeba7fc305d946740f9e88513220c73a1">CPLVirtualMemAccessMode</a>&nbsp;</td>
          <td class="paramname"> <em>eAccessMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#a575c56435cea278a5bf98bf2c21e7b8f">CPLVirtualMemCachePageCbk</a>&nbsp;</td>
          <td class="paramname"> <em>pfnCachePage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aec0c6ca7bd8ad956b6f62faefdcc5b66">CPLVirtualMemUnCachePageCbk</a>&nbsp;</td>
          <td class="paramname"> <em>pfnUnCachePage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aba9d54d83138551ff3067d8e23d8448c">CPLVirtualMemFreeUserData</a>&nbsp;</td>
          <td class="paramname"> <em>pfnFreeUserData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pCbkUserData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new virtual memory mapping. </p>
<p>This will reserve an area of virtual memory of size nSize, whose size might be potentially much larger than the physical memory available. Initially, no physical memory will be allocated. As soon as memory pages will be accessed, they will be allocated transparently and filled with the pfnCachePage callback. When the allowed cache size is reached, the least recently used pages will be unallocated.</p>
<p>On Linux AMD64 platforms, the maximum value for nSize is 128 TB. On Linux x86 platforms, the maximum value for nSize is 2 GB.</p>
<p>Only supported on Linux for now.</p>
<p>Note that on Linux, this function will install a SIGSEGV handler. The original handler will be restored by <a class="el" href="cpl__virtualmem_8h.html#a33e690c9c5b7f636cd8c0254eba63cb8" title="Cleanup any resource and handlers related to virtual memory.">CPLVirtualMemManagerTerminate()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nSize</em>&nbsp;</td><td>size in bytes of the virtual memory mapping. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nCacheSize</em>&nbsp;</td><td>size in bytes of the maximum memory that will be really allocated (must ideally fit into RAM). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nPageSizeHint</em>&nbsp;</td><td>hint for the page size. Must be a multiple of the system page size, returned by <a class="el" href="cpl__virtualmem_8h.html#af7db376bca14d8aeb40dc171b969fbad" title="Return the size of a page of virtual memory.">CPLGetPageSize()</a>. Minimum value is generally 4096. Might be set to 0 to let the function determine a default page size. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bSingleThreadUsage</em>&nbsp;</td><td>set to TRUE if there will be no concurrent threads that will access the virtual memory mapping. This can optimize performance a bit. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eAccessMode</em>&nbsp;</td><td>permission to use for the virtual memory mapping. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnCachePage</em>&nbsp;</td><td>callback triggered when a still unmapped page of virtual memory is accessed. The callback has the responsibility of filling the page with relevant values. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnUnCachePage</em>&nbsp;</td><td>callback triggered when a dirty mapped page is going to be freed (saturation of cache, or termination of the virtual memory mapping). Might be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnFreeUserData</em>&nbsp;</td><td>callback that can be used to free pCbkUserData. Might be NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pCbkUserData</em>&nbsp;</td><td>user data passed to pfnCachePage and pfnUnCachePage.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a virtual memory object that must be freed by <a class="el" href="cpl__virtualmem_8h.html#ac7e397a190759c66d3ee1130a20fb279" title="Free a virtual memory mapping.">CPLVirtualMemFree()</a>, or NULL in case of failure.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a4f98d8a992f8bf393719c51c5551c07e"></a><!-- doxytag: member="cpl_virtualmem.h::CPLVirtualMemPin" ref="a4f98d8a992f8bf393719c51c5551c07e" args="(CPLVirtualMem *ctxt, void *pAddr, size_t nSize, int bWriteOp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CPLVirtualMemPin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *&nbsp;</td>
          <td class="paramname"> <em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bWriteOp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make sure that a region of virtual memory will be realized. </p>
<p>Calling this function is not required, but might be usefull when debugging a process with tools like gdb or valgrind that do not naturally like segmentation fault signals.</p>
<p>It is also needed when wanting to provide part of virtual memory mapping to a system call such as read() or write(). If read() or write() is called on a memory region not yet realized, the call will fail with EFAULT.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctxt</em>&nbsp;</td><td>context returned by <a class="el" href="cpl__virtualmem_8h.html#ae3f4f669f48fc2755a43566524725878" title="Create a new virtual memory mapping.">CPLVirtualMemNew()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pAddr</em>&nbsp;</td><td>the memory region to pin. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nSize</em>&nbsp;</td><td>the size of the memory region. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bWriteOp</em>&nbsp;</td><td>set to TRUE if the memory are will be accessed in write mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a60a2dba5c24c0c7c478202928fecf93c"></a><!-- doxytag: member="cpl_virtualmem.h::CPLVirtualMemUnDeclareThread" ref="a60a2dba5c24c0c7c478202928fecf93c" args="(CPLVirtualMem *ctxt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CPLVirtualMemUnDeclareThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *&nbsp;</td>
          <td class="paramname"> <em>ctxt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Declare that a thread will stop accessing a virtual memory mapping. </p>
<p>This function must be called by a thread that will no longer access the content of a virtual memory mapping, except if the virtual memory mapping has been created with bSingleThreadUsage = TRUE.</p>
<p>This function must be paired with <a class="el" href="cpl__virtualmem_8h.html#aa94d9fee83792450f556ea68f3a27f31" title="Declare that a thread will access a virtual memory mapping.">CPLVirtualMemDeclareThread()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctxt</em>&nbsp;</td><td>context returned by <a class="el" href="cpl__virtualmem_8h.html#ae3f4f669f48fc2755a43566524725878" title="Create a new virtual memory mapping.">CPLVirtualMemNew()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
</div>
<hr>

Generated for GDAL by 
<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.7.1.
</body>
</html>

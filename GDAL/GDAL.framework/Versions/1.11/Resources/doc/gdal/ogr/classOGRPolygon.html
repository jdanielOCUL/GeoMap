<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OGR: OGRPolygon Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>OGRPolygon Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="OGRPolygon" --><!-- doxytag: inherits="OGRSurface" -->
<p><code>#include &lt;<a class="el" href="ogr__geometry_8h_source.html">ogr_geometry.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for OGRPolygon:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classOGRPolygon.png" usemap="#OGRPolygon_map" alt=""/>
  <map id="OGRPolygon_map" name="OGRPolygon_map">
<area href="classOGRSurface.html" alt="OGRSurface" shape="rect" coords="0,56,93,80"/>
<area href="classOGRGeometry.html" alt="OGRGeometry" shape="rect" coords="0,0,93,24"/>
</map>
</div>

<p><a href="classOGRPolygon-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6142a7ee45f6bf7a3a189fa978437913"></a><!-- doxytag: member="OGRPolygon::OGRPolygon" ref="a6142a7ee45f6bf7a3a189fa978437913" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRPolygon.html#a6142a7ee45f6bf7a3a189fa978437913">OGRPolygon</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an empty polygon. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRPolygon.html#a12ddd81003dfabd7d3c977c41fa5f506">getGeometryName</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch WKT name for geometry type.  <a href="#a12ddd81003dfabd7d3c977c41fa5f506"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRPolygon.html#a2e23fcc24129c50c2245f707938fdf4d">getGeometryType</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch geometry type.  <a href="#a2e23fcc24129c50c2245f707938fdf4d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRPolygon.html#a723ac02b4551c683ab7ad88e6616c16b">clone</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a copy of this object.  <a href="#a723ac02b4551c683ab7ad88e6616c16b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRPolygon.html#a8e8ea1eb8916cf60a69650fd3a9025f9">empty</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear geometry information. This restores the geometry to it's initial state after construction, and before assignment of actual geometry.  <a href="#a8e8ea1eb8916cf60a69650fd3a9025f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRPolygon.html#aa974efb0dd2bdc7b62fa23dfdc4f8c72">transform</a> (<a class="el" href="classOGRCoordinateTransformation.html">OGRCoordinateTransformation</a> *poCT)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Apply arbitrary coordinate transformation to geometry.  <a href="#aa974efb0dd2bdc7b62fa23dfdc4f8c72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRPolygon.html#a3b8a81f9742e981c242668d2d4d4a69d">flattenTo2D</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert geometry to strictly 2D. In a sense this converts all Z coordinates to 0.0.  <a href="#a3b8a81f9742e981c242668d2d4d4a69d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRBoolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRPolygon.html#a1e14ee632878f6af3a4c93d7bf82a433">IsEmpty</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns TRUE (non-zero) if the object has no points.  <a href="#a1e14ee632878f6af3a4c93d7bf82a433"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRPolygon.html#a51fa8080389d47784fdb6a8ae097b5fa">segmentize</a> (double dfMaxLength)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modify the geometry such it has no segment longer then the given distance.  <a href="#a51fa8080389d47784fdb6a8ae097b5fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRPolygon.html#ad8ba9b796aafc593f5bd7bcf1086bc3d">get_Area</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute area of polygon.  <a href="#ad8ba9b796aafc593f5bd7bcf1086bc3d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRPolygon.html#a76e64f21cd31a6256cc425a6b5639069">PointOnSurface</a> (<a class="el" href="classOGRPoint.html">OGRPoint</a> *poPoint) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method relates to the SFCOM ISurface::get_PointOnSurface() method.  <a href="#a76e64f21cd31a6256cc425a6b5639069"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRPolygon.html#ad8193c4d42032c4106bdccb907bc66ab">WkbSize</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns size of related binary representation.  <a href="#ad8193c4d42032c4106bdccb907bc66ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRPolygon.html#a46b833f19bf35fcea113233310a245ce">importFromWkb</a> (unsigned char *, int=-1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign geometry from well known binary data.  <a href="#a46b833f19bf35fcea113233310a245ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRPolygon.html#acad2d60fac70ce252616ce8bcff006d5">exportToWkb</a> (OGRwkbByteOrder, unsigned char *, <a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6">OGRwkbVariant</a>=wkbVariantOgc) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a geometry into well known binary format.  <a href="#acad2d60fac70ce252616ce8bcff006d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRPolygon.html#a84d3b6e0ee2b098528a537bb874b4856">importFromWkt</a> (char **)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign geometry from well known text data.  <a href="#a84d3b6e0ee2b098528a537bb874b4856"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRPolygon.html#ade6a6d5d628f3ad57d0ce9dca8e26618">exportToWkt</a> (char **ppszDstText) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a geometry into well known text format.  <a href="#ade6a6d5d628f3ad57d0ce9dca8e26618"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRPolygon.html#ad395f8c5a45dfa639b3c9aa71a303fae">getDimension</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the dimension of this object.  <a href="#ad395f8c5a45dfa639b3c9aa71a303fae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRPolygon.html#a00a97e4a76eafe94b5cbb9d52d722457">getEnvelope</a> (<a class="el" href="classOGREnvelope.html">OGREnvelope</a> *psEnvelope) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure.  <a href="#a00a97e4a76eafe94b5cbb9d52d722457"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRPolygon.html#a8da89cab9c581a4665b183836f80ae20">getEnvelope</a> (<a class="el" href="classOGREnvelope3D.html">OGREnvelope3D</a> *psEnvelope) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes and returns the bounding envelope (3D) for this geometry in the passed psEnvelope structure.  <a href="#a8da89cab9c581a4665b183836f80ae20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRBoolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRPolygon.html#a5daaf7cbfb1263a4b9fc126f5c51cf37">Equals</a> (<a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns TRUE if two geometries are equivalent.  <a href="#a5daaf7cbfb1263a4b9fc126f5c51cf37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRPolygon.html#aae4be814a04641d5ad9f8c79e00b3c35">setCoordinateDimension</a> (int nDimension)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the coordinate dimension.  <a href="#aae4be814a04641d5ad9f8c79e00b3c35"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRPolygon.html#a6a2400d013a7538169b6f610499d9e30">addRing</a> (<a class="el" href="classOGRLinearRing.html">OGRLinearRing</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a ring to a polygon.  <a href="#a6a2400d013a7538169b6f610499d9e30"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRPolygon.html#a17f7fca852efca8155fba7cbad7572c0">addRingDirectly</a> (<a class="el" href="classOGRLinearRing.html">OGRLinearRing</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a ring to a polygon.  <a href="#a17f7fca852efca8155fba7cbad7572c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRLinearRing.html">OGRLinearRing</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRPolygon.html#ad4ba927fb74871bf029e6a3efec3586c">getExteriorRing</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch reference to external polygon ring.  <a href="#ad4ba927fb74871bf029e6a3efec3586c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRPolygon.html#a3b996195adcf9fcd4f33570a37753dde">getNumInteriorRings</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the number of internal rings.  <a href="#a3b996195adcf9fcd4f33570a37753dde"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRLinearRing.html">OGRLinearRing</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRPolygon.html#af0bf0b1d1104e142b47637659518ad9c">getInteriorRing</a> (int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch reference to indicated internal ring.  <a href="#af0bf0b1d1104e142b47637659518ad9c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRLinearRing.html">OGRLinearRing</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRPolygon.html#a8ed182b4cd75d1ae4fd81d6e1027f740">stealExteriorRing</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">"Steal" reference to external polygon ring.  <a href="#a8ed182b4cd75d1ae4fd81d6e1027f740"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRLinearRing.html">OGRLinearRing</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRPolygon.html#a4095bca5e424f73d33e3925e19365dfa">stealInteriorRing</a> (int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">"Steal" reference to indicated interior ring.  <a href="#a4095bca5e424f73d33e3925e19365dfa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRPolygon.html#af5f15a5673fde9522b4e70abdb9cec93">closeRings</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Force rings to be closed.  <a href="#af5f15a5673fde9522b4e70abdb9cec93"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRPolygon.html#a0aeea5e4fa4f33e3723ec51db9b0661c">swapXY</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swap x and y coordinates.  <a href="#a0aeea5e4fa4f33e3723ec51db9b0661c"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Concrete class representing polygons.</p>
<p>Note that the OpenGIS simple features polygons consist of one outer ring, and zero or more inner rings. A polygon cannot represent disconnected regions (such as multiple islands in a political body). The <a class="el" href="classOGRMultiPolygon.html">OGRMultiPolygon</a> must be used for this. </p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a6a2400d013a7538169b6f610499d9e30"></a><!-- doxytag: member="OGRPolygon::addRing" ref="a6a2400d013a7538169b6f610499d9e30" args="(OGRLinearRing *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRPolygon::addRing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRLinearRing.html">OGRLinearRing</a> *&nbsp;</td>
          <td class="paramname"> <em>poNewRing</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a ring to a polygon. </p>
<p>If the polygon has no external ring (it is empty) this will be used as the external ring, otherwise it is used as an internal ring. The passed <a class="el" href="classOGRLinearRing.html">OGRLinearRing</a> remains the responsibility of the caller (an internal copy is made).</p>
<p>This method has no SFCOM analog.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poNewRing</em>&nbsp;</td><td>ring to be added to the polygon. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classOGRGeometry.html#a2a93f43a3b66462195b46f7fd2196dfc">OGRGeometry::getCoordinateDimension()</a>.</p>

<p>Referenced by <a class="el" href="classOGRPolygon.html#a723ac02b4551c683ab7ad88e6616c16b">clone()</a>, and <a class="el" href="classOGRLayer.html#a5cd4ceb8f4ec20594be63280c8e4498a">OGRLayer::SetSpatialFilterRect()</a>.</p>

</div>
</div>
<a class="anchor" id="a17f7fca852efca8155fba7cbad7572c0"></a><!-- doxytag: member="OGRPolygon::addRingDirectly" ref="a17f7fca852efca8155fba7cbad7572c0" args="(OGRLinearRing *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRPolygon::addRingDirectly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRLinearRing.html">OGRLinearRing</a> *&nbsp;</td>
          <td class="paramname"> <em>poNewRing</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a ring to a polygon. </p>
<p>If the polygon has no external ring (it is empty) this will be used as the external ring, otherwise it is used as an internal ring. Ownership of the passed ring is assumed by the <a class="el" href="classOGRPolygon.html">OGRPolygon</a>, but otherwise this method operates the same as OGRPolygon::AddRing().</p>
<p>This method has no SFCOM analog.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poNewRing</em>&nbsp;</td><td>ring to be added to the polygon. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classOGRGeometry.html#a2a93f43a3b66462195b46f7fd2196dfc">OGRGeometry::getCoordinateDimension()</a>.</p>

<p>Referenced by <a class="el" href="classOGRGeometryFactory.html#afd61936e41ea69831b3196e817658d08">OGRGeometryFactory::forceToPolygon()</a>, <a class="el" href="classOGRMultiPolygon.html#a23b4a553c2b3ccde257359c78782eaf8">OGRMultiPolygon::importFromWkt()</a>, <a class="el" href="ogr__api_8h.html#a74f64386be8d675e8da33d289ccc9892">OGRBuildPolygonFromEdges()</a>, and <a class="el" href="classOGRGeometryFactory.html#afa3e76499553c3dc0a1621af98b88be6">OGRGeometryFactory::organizePolygons()</a>.</p>

</div>
</div>
<a class="anchor" id="a723ac02b4551c683ab7ad88e6616c16b"></a><!-- doxytag: member="OGRPolygon::clone" ref="a723ac02b4551c683ab7ad88e6616c16b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRPolygon::clone </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a copy of this object. </p>
<p>This method relates to the SFCOM IGeometry::clone() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a1725918932da7d59f9ee72829ac171fa" title="Make a copy of this object.">OGR_G_Clone()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new object instance with the same geometry, and spatial reference system as the original. </dd></dl>

<p>Implements <a class="el" href="classOGRGeometry.html#af4cf9f6eee1997268a481b39401c3161">OGRGeometry</a>.</p>

<p>References <a class="el" href="classOGRPolygon.html#a6a2400d013a7538169b6f610499d9e30">addRing()</a>, <a class="el" href="classOGRGeometry.html#a4308e3549c65aa12cc2ba41be15d99a0">OGRGeometry::assignSpatialReference()</a>, and <a class="el" href="classOGRGeometry.html#a194f0bbdae896539852106cafbffbe87">OGRGeometry::getSpatialReference()</a>.</p>

</div>
</div>
<a class="anchor" id="af5f15a5673fde9522b4e70abdb9cec93"></a><!-- doxytag: member="OGRPolygon::closeRings" ref="af5f15a5673fde9522b4e70abdb9cec93" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRPolygon::closeRings </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Force rings to be closed. </p>
<p>If this geometry, or any contained geometries has polygon rings that are not closed, they will be closed by adding the starting point at the end. </p>

<p>Reimplemented from <a class="el" href="classOGRGeometry.html#aeb6cf249316b3046e0d4f77ec400e844">OGRGeometry</a>.</p>

</div>
</div>
<a class="anchor" id="a8e8ea1eb8916cf60a69650fd3a9025f9"></a><!-- doxytag: member="OGRPolygon::empty" ref="a8e8ea1eb8916cf60a69650fd3a9025f9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRPolygon::empty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear geometry information. This restores the geometry to it's initial state after construction, and before assignment of actual geometry. </p>
<p>This method relates to the SFCOM IGeometry::Empty() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a90cc83b0a3052b8fbe2ed77a86323bf2" title="Clear geometry information. This restores the geometry to it&#39;s initial state after construction...">OGR_G_Empty()</a>. </p>

<p>Implements <a class="el" href="classOGRGeometry.html#a1702b5b8142abe761061a6cd44e50b05">OGRGeometry</a>.</p>

<p>Referenced by <a class="el" href="classOGRPolygon.html#a84d3b6e0ee2b098528a537bb874b4856">importFromWkt()</a>.</p>

</div>
</div>
<a class="anchor" id="a5daaf7cbfb1263a4b9fc126f5c51cf37"></a><!-- doxytag: member="OGRPolygon::Equals" ref="a5daaf7cbfb1263a4b9fc126f5c51cf37" args="(OGRGeometry *) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRBoolean OGRPolygon::Equals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td>
          <td class="paramname"> <em>poOtherGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns TRUE if two geometries are equivalent. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#abaed0c4fb6f08abc280f91619e2e47d3" title="Returns TRUE if two geometries are equivalent.">OGR_G_Equals()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if equivalent or FALSE otherwise. </dd></dl>

<p>Implements <a class="el" href="classOGRGeometry.html#ae751513a46c7e7b154796bfe494faf16">OGRGeometry</a>.</p>

<p>References <a class="el" href="classOGRLineString.html#a8568a09caf084295b39df28c31586c01">OGRLineString::Equals()</a>, <a class="el" href="classOGRPolygon.html#ad4ba927fb74871bf029e6a3efec3586c">getExteriorRing()</a>, <a class="el" href="classOGRPolygon.html#a2e23fcc24129c50c2245f707938fdf4d">getGeometryType()</a>, <a class="el" href="classOGRGeometry.html#a5c6bca18682cb933e3227552d480e1a5">OGRGeometry::getGeometryType()</a>, <a class="el" href="classOGRPolygon.html#af0bf0b1d1104e142b47637659518ad9c">getInteriorRing()</a>, <a class="el" href="classOGRPolygon.html#a3b996195adcf9fcd4f33570a37753dde">getNumInteriorRings()</a>, <a class="el" href="classOGRGeometry.html#ac8653ba97e53f3e3b041946ca2acc111">OGRGeometry::IsEmpty()</a>, and <a class="el" href="classOGRPolygon.html#a1e14ee632878f6af3a4c93d7bf82a433">IsEmpty()</a>.</p>

</div>
</div>
<a class="anchor" id="acad2d60fac70ce252616ce8bcff006d5"></a><!-- doxytag: member="OGRPolygon::exportToWkb" ref="acad2d60fac70ce252616ce8bcff006d5" args="(OGRwkbByteOrder, unsigned char *, OGRwkbVariant=wkbVariantOgc) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRPolygon::exportToWkb </td>
          <td>(</td>
          <td class="paramtype">OGRwkbByteOrder&nbsp;</td>
          <td class="paramname"> <em>eByteOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>pabyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6">OGRwkbVariant</a>&nbsp;</td>
          <td class="paramname"> <em>eWkbVariant</em> = <code>wkbVariantOgc</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a geometry into well known binary format. </p>
<p>This method relates to the SFCOM IWks::ExportToWKB() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ad5c94ae76c09774dba8725c24daeefd6" title="Convert a geometry into well known binary format.">OGR_G_ExportToWkb()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>eByteOrder</em>&nbsp;</td><td>One of wkbXDR or wkbNDR indicating MSB or LSB byte order respectively. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pabyData</em>&nbsp;</td><td>a buffer into which the binary representation is written. This buffer must be at least <a class="el" href="classOGRGeometry.html#acd1a8164dae2e44e50990756ed6b8b4a" title="Returns size of related binary representation.">OGRGeometry::WkbSize()</a> byte in size. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eWkbVariant</em>&nbsp;</td><td>What standard to use when exporting geometries with three dimensions (or more). The default wkbVariantOgc is the historical OGR variant. wkbVariantIso is the variant defined in ISO SQL/MM and adopted by OGC for SFSQL 1.2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Currently OGRERR_NONE is always returned. </dd></dl>

<p>Implements <a class="el" href="classOGRGeometry.html#ad46eeb33da8b6de99f1697f8de9cbea7">OGRGeometry</a>.</p>

<p>References <a class="el" href="classOGRGeometry.html#a2a93f43a3b66462195b46f7fd2196dfc">OGRGeometry::getCoordinateDimension()</a>, <a class="el" href="classOGRPolygon.html#a2e23fcc24129c50c2245f707938fdf4d">getGeometryType()</a>, and <a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6ac103ec17c4045fb9f3013638726a8bd5">wkbVariantIso</a>.</p>

</div>
</div>
<a class="anchor" id="ade6a6d5d628f3ad57d0ce9dca8e26618"></a><!-- doxytag: member="OGRPolygon::exportToWkt" ref="ade6a6d5d628f3ad57d0ce9dca8e26618" args="(char **ppszDstText) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRPolygon::exportToWkt </td>
          <td>(</td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>ppszDstText</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a geometry into well known text format. </p>
<p>This method relates to the SFCOM IWks::ExportToWKT() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a3bc9310302e2dbfaab1690de9e2fd2fb" title="Convert a geometry into well known text format.">OGR_G_ExportToWkt()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ppszDstText</em>&nbsp;</td><td>a text buffer is allocated by the program, and assigned to the passed pointer. After use, *ppszDstText should be freed with OGRFree().</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Currently OGRERR_NONE is always returned. </dd></dl>

<p>Implements <a class="el" href="classOGRGeometry.html#a0c941d5efdff84666af5a6f6b540aafb">OGRGeometry</a>.</p>

<p>References <a class="el" href="classOGRLineString.html#a80aa40481584eca17808d1abacb435f9">OGRLineString::exportToWkt()</a>, <a class="el" href="classOGRGeometry.html#a2a93f43a3b66462195b46f7fd2196dfc">OGRGeometry::getCoordinateDimension()</a>, <a class="el" href="classOGRPolygon.html#ad4ba927fb74871bf029e6a3efec3586c">getExteriorRing()</a>, <a class="el" href="classOGRPolygon.html#a1e14ee632878f6af3a4c93d7bf82a433">IsEmpty()</a>, and <a class="el" href="classOGRLineString.html#aed2edaf7e5af02f2724ec073f0957ee0">OGRLineString::setCoordinateDimension()</a>.</p>

<p>Referenced by <a class="el" href="classOGRGeometryFactory.html#afa3e76499553c3dc0a1621af98b88be6">OGRGeometryFactory::organizePolygons()</a>.</p>

</div>
</div>
<a class="anchor" id="a3b8a81f9742e981c242668d2d4d4a69d"></a><!-- doxytag: member="OGRPolygon::flattenTo2D" ref="a3b8a81f9742e981c242668d2d4d4a69d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRPolygon::flattenTo2D </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert geometry to strictly 2D. In a sense this converts all Z coordinates to 0.0. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#afdb7354b55c7448b60b44cd9e36073b8" title="Convert geometry to strictly 2D. In a sense this converts all Z coordinates to 0.0.">OGR_G_FlattenTo2D()</a>. </p>

<p>Implements <a class="el" href="classOGRGeometry.html#aaae1a2ced937a5900b2bfeb717bad6c9">OGRGeometry</a>.</p>

</div>
</div>
<a class="anchor" id="ad8ba9b796aafc593f5bd7bcf1086bc3d"></a><!-- doxytag: member="OGRPolygon::get_Area" ref="ad8ba9b796aafc593f5bd7bcf1086bc3d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGRPolygon::get_Area </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute area of polygon. </p>
<p>The area is computed as the area of the outer ring less the area of all internal rings.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>computed area. </dd></dl>

<p>Implements <a class="el" href="classOGRSurface.html#a3b2c3125ec8c0b3a986e43cd1056f9e4">OGRSurface</a>.</p>

<p>References <a class="el" href="classOGRLinearRing.html#a3cf7de4ec5ce40d8703a2fae7a343a3e">OGRLinearRing::get_Area()</a>, <a class="el" href="classOGRPolygon.html#ad4ba927fb74871bf029e6a3efec3586c">getExteriorRing()</a>, <a class="el" href="classOGRPolygon.html#af0bf0b1d1104e142b47637659518ad9c">getInteriorRing()</a>, and <a class="el" href="classOGRPolygon.html#a3b996195adcf9fcd4f33570a37753dde">getNumInteriorRings()</a>.</p>

<p>Referenced by <a class="el" href="classOGRMultiPolygon.html#af62f5cde29360891cfadcb42c714941d">OGRMultiPolygon::get_Area()</a>, and <a class="el" href="classOGRGeometryFactory.html#afa3e76499553c3dc0a1621af98b88be6">OGRGeometryFactory::organizePolygons()</a>.</p>

</div>
</div>
<a class="anchor" id="ad395f8c5a45dfa639b3c9aa71a303fae"></a><!-- doxytag: member="OGRPolygon::getDimension" ref="ad395f8c5a45dfa639b3c9aa71a303fae" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRPolygon::getDimension </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the dimension of this object. </p>
<p>This method corresponds to the SFCOM IGeometry::GetDimension() method. It indicates the dimension of the object, but does not indicate the dimension of the underlying space (as indicated by <a class="el" href="classOGRGeometry.html#a2a93f43a3b66462195b46f7fd2196dfc" title="Get the dimension of the coordinates in this object.">OGRGeometry::getCoordinateDimension()</a>).</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a94b633e1acd208c258ad49f8d4fd4104" title="Get the dimension of this geometry.">OGR_G_GetDimension()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 for points, 1 for lines and 2 for surfaces. </dd></dl>

<p>Implements <a class="el" href="classOGRGeometry.html#aadca09471fa9917452e087ba12d73eeb">OGRGeometry</a>.</p>

</div>
</div>
<a class="anchor" id="a00a97e4a76eafe94b5cbb9d52d722457"></a><!-- doxytag: member="OGRPolygon::getEnvelope" ref="a00a97e4a76eafe94b5cbb9d52d722457" args="(OGREnvelope *psEnvelope) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRPolygon::getEnvelope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGREnvelope.html">OGREnvelope</a> *&nbsp;</td>
          <td class="paramname"> <em>psEnvelope</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a617a9c9ea85157661619a1d8f0a69cf9" title="Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure...">OGR_G_GetEnvelope()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psEnvelope</em>&nbsp;</td><td>the structure in which to place the results. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classOGRGeometry.html#aa3d42b06ae6f7bbef6d1a2886da8d398">OGRGeometry</a>.</p>

<p>References <a class="el" href="classOGRLineString.html#acd1805288a923f93a147b643f45e8e68">OGRLineString::getEnvelope()</a>, and <a class="el" href="classOGRPolygon.html#a1e14ee632878f6af3a4c93d7bf82a433">IsEmpty()</a>.</p>

</div>
</div>
<a class="anchor" id="a8da89cab9c581a4665b183836f80ae20"></a><!-- doxytag: member="OGRPolygon::getEnvelope" ref="a8da89cab9c581a4665b183836f80ae20" args="(OGREnvelope3D *psEnvelope) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRPolygon::getEnvelope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGREnvelope3D.html">OGREnvelope3D</a> *&nbsp;</td>
          <td class="paramname"> <em>psEnvelope</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes and returns the bounding envelope (3D) for this geometry in the passed psEnvelope structure. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a9a950633ac824042b0afdb88c670c5ce" title="Computes and returns the bounding envelope (3D) for this geometry in the passed psEnvelope structure...">OGR_G_GetEnvelope3D()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psEnvelope</em>&nbsp;</td><td>the structure in which to place the results.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.9.0 </dd></dl>

<p>Implements <a class="el" href="classOGRGeometry.html#a3926892dbde299ffd652ee109b5967c5">OGRGeometry</a>.</p>

<p>References <a class="el" href="classOGRLineString.html#acd1805288a923f93a147b643f45e8e68">OGRLineString::getEnvelope()</a>, and <a class="el" href="classOGRPolygon.html#a1e14ee632878f6af3a4c93d7bf82a433">IsEmpty()</a>.</p>

</div>
</div>
<a class="anchor" id="ad4ba927fb74871bf029e6a3efec3586c"></a><!-- doxytag: member="OGRPolygon::getExteriorRing" ref="ad4ba927fb74871bf029e6a3efec3586c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRLinearRing.html">OGRLinearRing</a> * OGRPolygon::getExteriorRing </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch reference to external polygon ring. </p>
<p>Note that the returned ring pointer is to an internal data object of the <a class="el" href="classOGRPolygon.html">OGRPolygon</a>. It should not be modified or deleted by the application, and the pointer is only valid till the polygon is next modified. Use the <a class="el" href="classOGRGeometry.html#af4cf9f6eee1997268a481b39401c3161" title="Make a copy of this object.">OGRGeometry::clone()</a> method to make a separate copy within the application.</p>
<p>Relates to the SFCOM IPolygon::get_ExteriorRing() method.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to external ring. May be NULL if the <a class="el" href="classOGRPolygon.html">OGRPolygon</a> is empty. </dd></dl>

<p>Referenced by <a class="el" href="classOGRGeometry.html#a2e70f05d61566a5ddaa29b44f637cfff">OGRGeometry::dumpReadable()</a>, <a class="el" href="classOGRPolygon.html#a5daaf7cbfb1263a4b9fc126f5c51cf37">Equals()</a>, <a class="el" href="classOGRPolygon.html#ade6a6d5d628f3ad57d0ce9dca8e26618">exportToWkt()</a>, <a class="el" href="classOGRGeometryFactory.html#a1c00a78cec110d71175726d6f26b1b39">OGRGeometryFactory::forceToMultiLineString()</a>, <a class="el" href="classOGRGeometryFactory.html#afd61936e41ea69831b3196e817658d08">OGRGeometryFactory::forceToPolygon()</a>, <a class="el" href="classOGRPolygon.html#ad8ba9b796aafc593f5bd7bcf1086bc3d">get_Area()</a>, and <a class="el" href="classOGRGeometryFactory.html#afa3e76499553c3dc0a1621af98b88be6">OGRGeometryFactory::organizePolygons()</a>.</p>

</div>
</div>
<a class="anchor" id="a12ddd81003dfabd7d3c977c41fa5f506"></a><!-- doxytag: member="OGRPolygon::getGeometryName" ref="a12ddd81003dfabd7d3c977c41fa5f506" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * OGRPolygon::getGeometryName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch WKT name for geometry type. </p>
<p>There is no SFCOM analog to this method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a18121f835b2fb724a0c1a87beb1a437a" title="Fetch WKT name for geometry type.">OGR_G_GetGeometryName()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>name used for this geometry type in well known text format. The returned pointer is to a static internal string and should not be modified or freed. </dd></dl>

<p>Implements <a class="el" href="classOGRGeometry.html#aba109e1c53ce1452942f85eae66d88b8">OGRGeometry</a>.</p>

</div>
</div>
<a class="anchor" id="a2e23fcc24129c50c2245f707938fdf4d"></a><!-- doxytag: member="OGRPolygon::getGeometryType" ref="a2e23fcc24129c50c2245f707938fdf4d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a> OGRPolygon::getGeometryType </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch geometry type. </p>
<p>Note that the geometry type may include the 2.5D flag. To get a 2D flattened version of the geometry type apply the wkbFlatten() macro to the return result.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a8fae58102f5c4a4cf2526e5ca8369a76" title="Fetch geometry type.">OGR_G_GetGeometryType()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the geometry type code. </dd></dl>

<p>Implements <a class="el" href="classOGRGeometry.html#a5c6bca18682cb933e3227552d480e1a5">OGRGeometry</a>.</p>

<p>Referenced by <a class="el" href="classOGRPolygon.html#a5daaf7cbfb1263a4b9fc126f5c51cf37">Equals()</a>, and <a class="el" href="classOGRPolygon.html#acad2d60fac70ce252616ce8bcff006d5">exportToWkb()</a>.</p>

</div>
</div>
<a class="anchor" id="af0bf0b1d1104e142b47637659518ad9c"></a><!-- doxytag: member="OGRPolygon::getInteriorRing" ref="af0bf0b1d1104e142b47637659518ad9c" args="(int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRLinearRing.html">OGRLinearRing</a> * OGRPolygon::getInteriorRing </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iRing</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch reference to indicated internal ring. </p>
<p>Note that the returned ring pointer is to an internal data object of the <a class="el" href="classOGRPolygon.html">OGRPolygon</a>. It should not be modified or deleted by the application, and the pointer is only valid till the polygon is next modified. Use the <a class="el" href="classOGRGeometry.html#af4cf9f6eee1997268a481b39401c3161" title="Make a copy of this object.">OGRGeometry::clone()</a> method to make a separate copy within the application.</p>
<p>Relates to the SFCOM IPolygon::get_InternalRing() method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iRing</em>&nbsp;</td><td>internal ring index from 0 to getNumInternalRings() - 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to interior ring. May be NULL. </dd></dl>

<p>Referenced by <a class="el" href="classOGRGeometry.html#a2e70f05d61566a5ddaa29b44f637cfff">OGRGeometry::dumpReadable()</a>, <a class="el" href="classOGRPolygon.html#a5daaf7cbfb1263a4b9fc126f5c51cf37">Equals()</a>, <a class="el" href="classOGRGeometryFactory.html#a1c00a78cec110d71175726d6f26b1b39">OGRGeometryFactory::forceToMultiLineString()</a>, and <a class="el" href="classOGRPolygon.html#ad8ba9b796aafc593f5bd7bcf1086bc3d">get_Area()</a>.</p>

</div>
</div>
<a class="anchor" id="a3b996195adcf9fcd4f33570a37753dde"></a><!-- doxytag: member="OGRPolygon::getNumInteriorRings" ref="a3b996195adcf9fcd4f33570a37753dde" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRPolygon::getNumInteriorRings </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch the number of internal rings. </p>
<p>Relates to the SFCOM IPolygon::get_NumInteriorRings() method.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>count of internal rings, zero or more. </dd></dl>

<p>Referenced by <a class="el" href="classOGRGeometry.html#a2e70f05d61566a5ddaa29b44f637cfff">OGRGeometry::dumpReadable()</a>, <a class="el" href="classOGRPolygon.html#a5daaf7cbfb1263a4b9fc126f5c51cf37">Equals()</a>, <a class="el" href="classOGRGeometryFactory.html#a1c00a78cec110d71175726d6f26b1b39">OGRGeometryFactory::forceToMultiLineString()</a>, <a class="el" href="classOGRGeometryFactory.html#afd61936e41ea69831b3196e817658d08">OGRGeometryFactory::forceToPolygon()</a>, and <a class="el" href="classOGRPolygon.html#ad8ba9b796aafc593f5bd7bcf1086bc3d">get_Area()</a>.</p>

</div>
</div>
<a class="anchor" id="a46b833f19bf35fcea113233310a245ce"></a><!-- doxytag: member="OGRPolygon::importFromWkb" ref="a46b833f19bf35fcea113233310a245ce" args="(unsigned char *, int=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRPolygon::importFromWkb </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>pabyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nSize</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assign geometry from well known binary data. </p>
<p>The object must have already been instantiated as the correct derived type of geometry object to match the binaries type. This method is used by the <a class="el" href="classOGRGeometryFactory.html">OGRGeometryFactory</a> class, but not normally called by application code.</p>
<p>This method relates to the SFCOM IWks::ImportFromWKB() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#afa5a9173aa3b10a4db09ed696a92ba4a" title="Assign geometry from well known binary data.">OGR_G_ImportFromWkb()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pabyData</em>&nbsp;</td><td>the binary input data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nSize</em>&nbsp;</td><td>the size of pabyData in bytes, or zero if not known.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE if all goes well, otherwise any of OGRERR_NOT_ENOUGH_DATA, OGRERR_UNSUPPORTED_GEOMETRY_TYPE, or OGRERR_CORRUPT_DATA may be returned. </dd></dl>

<p>Implements <a class="el" href="classOGRGeometry.html#ab2c6583c2b7c3e526dcfe54a61470c1f">OGRGeometry</a>.</p>

<p>References <a class="el" href="cpl__vsi_8h.html#a9b88331b0be4f7f2bd43e7b830af7038">VSIMalloc2()</a>, and <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa11991cd1245f146f3efd694553433aeb">wkbPolygon</a>.</p>

</div>
</div>
<a class="anchor" id="a84d3b6e0ee2b098528a537bb874b4856"></a><!-- doxytag: member="OGRPolygon::importFromWkt" ref="a84d3b6e0ee2b098528a537bb874b4856" args="(char **)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRPolygon::importFromWkt </td>
          <td>(</td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>ppszInput</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assign geometry from well known text data. </p>
<p>The object must have already been instantiated as the correct derived type of geometry object to match the text type. This method is used by the <a class="el" href="classOGRGeometryFactory.html">OGRGeometryFactory</a> class, but not normally called by application code.</p>
<p>This method relates to the SFCOM IWks::ImportFromWKT() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a4286ba243fb05a831a49f52aabcbc6f8" title="Assign geometry from well known text data.">OGR_G_ImportFromWkt()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ppszInput</em>&nbsp;</td><td>pointer to a pointer to the source text. The pointer is updated to pointer after the consumed text.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE if all goes well, otherwise any of OGRERR_NOT_ENOUGH_DATA, OGRERR_UNSUPPORTED_GEOMETRY_TYPE, or OGRERR_CORRUPT_DATA may be returned. </dd></dl>

<p>Implements <a class="el" href="classOGRGeometry.html#a30561a301d44b1f90393ea4a78a5b0a5">OGRGeometry</a>.</p>

<p>References <a class="el" href="classOGRPolygon.html#a8e8ea1eb8916cf60a69650fd3a9025f9">empty()</a>, and <a class="el" href="classOGRLineString.html#a49a2c161f48b2bd5ad6c7e2832c0cf15">OGRLineString::setPoints()</a>.</p>

</div>
</div>
<a class="anchor" id="a1e14ee632878f6af3a4c93d7bf82a433"></a><!-- doxytag: member="OGRPolygon::IsEmpty" ref="a1e14ee632878f6af3a4c93d7bf82a433" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRBoolean OGRPolygon::IsEmpty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns TRUE (non-zero) if the object has no points. </p>
<p>Normally this returns FALSE except between when an object is instantiated and points have been assigned.</p>
<p>This method relates to the SFCOM IGeometry::IsEmpty() method.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if object is empty, otherwise FALSE. </dd></dl>

<p>Implements <a class="el" href="classOGRGeometry.html#ac8653ba97e53f3e3b041946ca2acc111">OGRGeometry</a>.</p>

<p>Referenced by <a class="el" href="classOGRPolygon.html#a5daaf7cbfb1263a4b9fc126f5c51cf37">Equals()</a>, <a class="el" href="classOGRPolygon.html#ade6a6d5d628f3ad57d0ce9dca8e26618">exportToWkt()</a>, and <a class="el" href="classOGRPolygon.html#a00a97e4a76eafe94b5cbb9d52d722457">getEnvelope()</a>.</p>

</div>
</div>
<a class="anchor" id="a76e64f21cd31a6256cc425a6b5639069"></a><!-- doxytag: member="OGRPolygon::PointOnSurface" ref="a76e64f21cd31a6256cc425a6b5639069" args="(OGRPoint *poPoint) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRPolygon::PointOnSurface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRPoint.html">OGRPoint</a> *&nbsp;</td>
          <td class="paramname"> <em>poPoint</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method relates to the SFCOM ISurface::get_PointOnSurface() method. </p>
<p>NOTE: Only implemented when GEOS included in build.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poPoint</em>&nbsp;</td><td>point to be set with an internal point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE if it succeeds or OGRERR_FAILURE otherwise. </dd></dl>

<p>Implements <a class="el" href="classOGRSurface.html#a1d28c548d1ceba9841597c5a37356226">OGRSurface</a>.</p>

<p>References <a class="el" href="classOGRPoint.html#a3f4973eec2851ff655b61c600f8bf2f9">OGRPoint::empty()</a>, <a class="el" href="classOGRPoint.html#a1d7f8cb579cd0d029efda38026bf4b68">OGRPoint::getX()</a>, <a class="el" href="classOGRPoint.html#a235eac8e50f6ce105ff5c16655d05ba9">OGRPoint::getY()</a>, <a class="el" href="classOGRPoint.html#a3d25537f07a1e7dd51868f82ad7df52f">OGRPoint::IsEmpty()</a>, <a class="el" href="ogr__api_8h.html#af89dc63f138aee453cf8ff3e2b1c0833">OGR_G_PointOnSurface()</a>, <a class="el" href="classOGRPoint.html#a0eef5e2d9e0edeca0e0f06c7527facb4">OGRPoint::setX()</a>, and <a class="el" href="classOGRPoint.html#ab064eaaedb2140ed1410e7c2ce4ad1ca">OGRPoint::setY()</a>.</p>

</div>
</div>
<a class="anchor" id="a51fa8080389d47784fdb6a8ae097b5fa"></a><!-- doxytag: member="OGRPolygon::segmentize" ref="a51fa8080389d47784fdb6a8ae097b5fa" args="(double dfMaxLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRPolygon::segmentize </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfMaxLength</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modify the geometry such it has no segment longer then the given distance. </p>
<p>Interpolated points will have Z and M values (if needed) set to 0. Distance computation is performed in 2d only</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#ade9f08c8d63bc0e726cb20c201c86423" title="Modify the geometry such it has no segment longer then the given distance.">OGR_G_Segmentize()</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dfMaxLength</em>&nbsp;</td><td>the maximum distance between 2 points after segmentization </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classOGRGeometry.html#a91685bd7c0bdd67cd073a8b4da3c06a5">OGRGeometry</a>.</p>

</div>
</div>
<a class="anchor" id="aae4be814a04641d5ad9f8c79e00b3c35"></a><!-- doxytag: member="OGRPolygon::setCoordinateDimension" ref="aae4be814a04641d5ad9f8c79e00b3c35" args="(int nDimension)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRPolygon::setCoordinateDimension </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nNewDimension</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the coordinate dimension. </p>
<p>This method sets the explicit coordinate dimension. Setting the coordinate dimension of a geometry to 2 should zero out any existing Z values. Setting the dimension of a geometry collection will not necessarily affect the children geometries.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nNewDimension</em>&nbsp;</td><td>New coordinate dimension value, either 2 or 3. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classOGRGeometry.html#a79f84a2b948d511f28c47c47577dea49">OGRGeometry</a>.</p>

</div>
</div>
<a class="anchor" id="a8ed182b4cd75d1ae4fd81d6e1027f740"></a><!-- doxytag: member="OGRPolygon::stealExteriorRing" ref="a8ed182b4cd75d1ae4fd81d6e1027f740" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRLinearRing.html">OGRLinearRing</a> * OGRPolygon::stealExteriorRing </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>"Steal" reference to external polygon ring. </p>
<p>After the call to that function, only call to <a class="el" href="classOGRPolygon.html#a4095bca5e424f73d33e3925e19365dfa" title="&quot;Steal&quot; reference to indicated interior ring.">stealInteriorRing()</a> or destruction of the <a class="el" href="classOGRPolygon.html">OGRPolygon</a> is valid. Other operations may crash.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to external ring. May be NULL if the <a class="el" href="classOGRPolygon.html">OGRPolygon</a> is empty. </dd></dl>

<p>Referenced by <a class="el" href="classOGRGeometryFactory.html#afd61936e41ea69831b3196e817658d08">OGRGeometryFactory::forceToPolygon()</a>.</p>

</div>
</div>
<a class="anchor" id="a4095bca5e424f73d33e3925e19365dfa"></a><!-- doxytag: member="OGRPolygon::stealInteriorRing" ref="a4095bca5e424f73d33e3925e19365dfa" args="(int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRLinearRing.html">OGRLinearRing</a> * OGRPolygon::stealInteriorRing </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iRing</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>"Steal" reference to indicated interior ring. </p>
<p>After the call to that function, only call to <a class="el" href="classOGRPolygon.html#a4095bca5e424f73d33e3925e19365dfa" title="&quot;Steal&quot; reference to indicated interior ring.">stealInteriorRing()</a> or destruction of the <a class="el" href="classOGRPolygon.html">OGRPolygon</a> is valid. Other operations may crash.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iRing</em>&nbsp;</td><td>internal ring index from 0 to getNumInternalRings() - 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to interior ring. May be NULL. </dd></dl>

<p>Referenced by <a class="el" href="classOGRGeometryFactory.html#afd61936e41ea69831b3196e817658d08">OGRGeometryFactory::forceToPolygon()</a>.</p>

</div>
</div>
<a class="anchor" id="a0aeea5e4fa4f33e3723ec51db9b0661c"></a><!-- doxytag: member="OGRPolygon::swapXY" ref="a0aeea5e4fa4f33e3723ec51db9b0661c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRPolygon::swapXY </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swap x and y coordinates. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.8.0 </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRGeometry.html#a3ffd51d4998a8e2ae422c69b6adf480a">OGRGeometry</a>.</p>

</div>
</div>
<a class="anchor" id="aa974efb0dd2bdc7b62fa23dfdc4f8c72"></a><!-- doxytag: member="OGRPolygon::transform" ref="aa974efb0dd2bdc7b62fa23dfdc4f8c72" args="(OGRCoordinateTransformation *poCT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRPolygon::transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRCoordinateTransformation.html">OGRCoordinateTransformation</a> *&nbsp;</td>
          <td class="paramname"> <em>poCT</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply arbitrary coordinate transformation to geometry. </p>
<p>This method will transform the coordinates of a geometry from their current spatial reference system to a new target spatial reference system. Normally this means reprojecting the vectors, but it could include datum shifts, and changes of units.</p>
<p>Note that this method does not require that the geometry already have a spatial reference system. It will be assumed that they can be treated as having the source spatial reference system of the <a class="el" href="classOGRCoordinateTransformation.html">OGRCoordinateTransformation</a> object, and the actual SRS of the geometry will be ignored. On successful completion the output <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> of the <a class="el" href="classOGRCoordinateTransformation.html">OGRCoordinateTransformation</a> will be assigned to the geometry.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a59a5b3f954b11cfbf6e78807c28d6090" title="Apply arbitrary coordinate transformation to geometry.">OGR_G_Transform()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poCT</em>&nbsp;</td><td>the transformation to apply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE on success or an error code. </dd></dl>

<p>Implements <a class="el" href="classOGRGeometry.html#aa9e8bfb3c2129f25cf622660f734e1ba">OGRGeometry</a>.</p>

<p>References <a class="el" href="classOGRGeometry.html#a4308e3549c65aa12cc2ba41be15d99a0">OGRGeometry::assignSpatialReference()</a>, <a class="el" href="classOGRCoordinateTransformation.html#ae56218b826d186a8b7dcaf63d9b14fdd">OGRCoordinateTransformation::GetTargetCS()</a>, and <a class="el" href="classOGRLineString.html#a75675b1f158fd1d5d35cc431227ed000">OGRLineString::transform()</a>.</p>

</div>
</div>
<a class="anchor" id="ad8193c4d42032c4106bdccb907bc66ab"></a><!-- doxytag: member="OGRPolygon::WkbSize" ref="ad8193c4d42032c4106bdccb907bc66ab" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRPolygon::WkbSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns size of related binary representation. </p>
<p>This method returns the exact number of bytes required to hold the well known binary representation of this geometry object. Its computation may be slightly expensive for complex geometries.</p>
<p>This method relates to the SFCOM IWks::WkbSize() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a5f7035a933b957a9d453184c154c237c" title="Returns size of related binary representation.">OGR_G_WkbSize()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>size of binary representation in bytes. </dd></dl>

<p>Implements <a class="el" href="classOGRGeometry.html#acd1a8164dae2e44e50990756ed6b8b4a">OGRGeometry</a>.</p>

<p>References <a class="el" href="classOGRGeometry.html#a2a93f43a3b66462195b46f7fd2196dfc">OGRGeometry::getCoordinateDimension()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="ogr__geometry_8h_source.html">ogr_geometry.h</a></li>
<li>ogrpolygon.cpp</li>
</ul>
</div>
<hr>

Generated for GDAL by 
<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.7.1.
</body>
</html>

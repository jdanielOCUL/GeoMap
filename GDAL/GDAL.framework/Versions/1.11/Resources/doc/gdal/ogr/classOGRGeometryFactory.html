<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OGR: OGRGeometryFactory Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>OGRGeometryFactory Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="OGRGeometryFactory" -->
<p><code>#include &lt;<a class="el" href="ogr__geometry_8h_source.html">ogr_geometry.h</a>&gt;</code></p>

<p><a href="classOGRGeometryFactory-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometryFactory.html#a699688dba97260f2eb29f802e39cb0ec">createFromWkb</a> (unsigned char *, <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *, <a class="el" href="classOGRGeometry.html">OGRGeometry</a> **, int=-1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a geometry object of the appropriate type from it's well known binary representation.  <a href="#a699688dba97260f2eb29f802e39cb0ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometryFactory.html#a9418f71bcfb1e334173882c38d89d070">createFromWkt</a> (char **, <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *, <a class="el" href="classOGRGeometry.html">OGRGeometry</a> **)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a geometry object of the appropriate type from it's well known text representation.  <a href="#a9418f71bcfb1e334173882c38d89d070"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometryFactory.html#ab8aea6f0bfbea4c3c33d0ca64bf82e11">createFromFgf</a> (unsigned char *, <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *, <a class="el" href="classOGRGeometry.html">OGRGeometry</a> **, int=-1, int *=NULL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a geometry object of the appropriate type from it's FGF (FDO Geometry Format) binary representation.  <a href="#ab8aea6f0bfbea4c3c33d0ca64bf82e11"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometryFactory.html#af8714df4e6b6c5d5b2cdbdeec78af08c">createFromGML</a> (const char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create geometry from GML.  <a href="#af8714df4e6b6c5d5b2cdbdeec78af08c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometryFactory.html#aae001086e26985d95c36ccd255a8c6d5">destroyGeometry</a> (<a class="el" href="classOGRGeometry.html">OGRGeometry</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy geometry object.  <a href="#aae001086e26985d95c36ccd255a8c6d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometryFactory.html#ae4887e270d5099357f9a19b1eda6027a">createGeometry</a> (<a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an empty geometry of desired type.  <a href="#ae4887e270d5099357f9a19b1eda6027a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometryFactory.html#afd61936e41ea69831b3196e817658d08">forceToPolygon</a> (<a class="el" href="classOGRGeometry.html">OGRGeometry</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert to polygon.  <a href="#afd61936e41ea69831b3196e817658d08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometryFactory.html#adcae79ea28620e332a3d1df87f1180f3">forceToLineString</a> (<a class="el" href="classOGRGeometry.html">OGRGeometry</a> *, bool bOnlyInOrder=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert to line string.  <a href="#adcae79ea28620e332a3d1df87f1180f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometryFactory.html#a2a40032fa65cc71c028516bf8fc0df3e">forceToMultiPolygon</a> (<a class="el" href="classOGRGeometry.html">OGRGeometry</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert to multipolygon.  <a href="#a2a40032fa65cc71c028516bf8fc0df3e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometryFactory.html#aa97b7837101f6c56e476520d10a9f3c3">forceToMultiPoint</a> (<a class="el" href="classOGRGeometry.html">OGRGeometry</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert to multipoint.  <a href="#aa97b7837101f6c56e476520d10a9f3c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometryFactory.html#a1c00a78cec110d71175726d6f26b1b39">forceToMultiLineString</a> (<a class="el" href="classOGRGeometry.html">OGRGeometry</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert to multilinestring.  <a href="#a1c00a78cec110d71175726d6f26b1b39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometryFactory.html#afa3e76499553c3dc0a1621af98b88be6">organizePolygons</a> (<a class="el" href="classOGRGeometry.html">OGRGeometry</a> **papoPolygons, int nPolygonCount, int *pbResultValidGeometry, const char **papszOptions=NULL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Organize polygons based on geometries.  <a href="#afa3e76499553c3dc0a1621af98b88be6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometryFactory.html#a04998dcdbb37aa37871891593c048544">haveGEOS</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if GEOS enabled.  <a href="#a04998dcdbb37aa37871891593c048544"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometryFactory.html#a3b8d418c534cc7d909d706b4483316ae">approximateArcAngles</a> (double dfX, double dfY, double dfZ, double dfPrimaryRadius, double dfSecondaryAxis, double dfRotation, double dfStartAngle, double dfEndAngle, double dfMaxAngleStepSizeDegrees)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Create geometry objects from well known text/binary. </p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a3b8d418c534cc7d909d706b4483316ae"></a><!-- doxytag: member="OGRGeometryFactory::approximateArcAngles" ref="a3b8d418c534cc7d909d706b4483316ae" args="(double dfX, double dfY, double dfZ, double dfPrimaryRadius, double dfSecondaryAxis, double dfRotation, double dfStartAngle, double dfEndAngle, double dfMaxAngleStepSizeDegrees)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometryFactory::approximateArcAngles </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfCenterX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfCenterY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfPrimaryRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfSecondaryRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfRotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfStartAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfEndAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfMaxAngleStepSizeDegrees</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stroke arc to linestring.</p>
<p>Stroke an arc of a circle to a linestring based on a center point, radius, start angle and end angle, all angles in degrees.</p>
<p>If the dfMaxAngleStepSizeDegrees is zero, then a default value will be used. This is currently 4 degrees unless the user has overridden the value with the OGR_ARC_STEPSIZE configuration variable.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cpl__conv_8h.html#aa0cd1a68fe4f2fc7874cd2da605c36ce">CPLSetConfigOption()</a></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dfCenterX</em>&nbsp;</td><td>center X </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfCenterY</em>&nbsp;</td><td>center Y </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfZ</em>&nbsp;</td><td>center Z </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfPrimaryRadius</em>&nbsp;</td><td>X radius of ellipse. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfSecondaryRadius</em>&nbsp;</td><td>Y radius of ellipse. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfRotation</em>&nbsp;</td><td>rotation of the ellipse clockwise. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfStartAngle</em>&nbsp;</td><td>angle to first point on arc (clockwise of X-positive) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfEndAngle</em>&nbsp;</td><td>angle to last point on arc (clockwise of X-positive) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfMaxAngleStepSizeDegrees</em>&nbsp;</td><td>the largest step in degrees along the arc, zero to use the default setting.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classOGRLineString.html">OGRLineString</a> geometry representing an approximation of the arc.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.8.0 </dd></dl>

<p>References <a class="el" href="classOGRLineString.html#a68fe89e30ccbfaf76c481349c13968c4">OGRLineString::setPoint()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a7c9ee71d0030dc30bdd595c37ab71062">OGR_G_ApproximateArcAngles()</a>.</p>

</div>
</div>
<a class="anchor" id="ab8aea6f0bfbea4c3c33d0ca64bf82e11"></a><!-- doxytag: member="OGRGeometryFactory::createFromFgf" ref="ab8aea6f0bfbea4c3c33d0ca64bf82e11" args="(unsigned char *, OGRSpatialReference *, OGRGeometry **, int=&#45;1, int *=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRGeometryFactory::createFromFgf </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>pabyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&nbsp;</td>
          <td class="paramname"> <em>poSR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> **&nbsp;</td>
          <td class="paramname"> <em>ppoReturn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nBytes</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pnBytesConsumed</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a geometry object of the appropriate type from it's FGF (FDO Geometry Format) binary representation. </p>
<p>Also note that this is a static method, and that there is no need to instantiate an <a class="el" href="classOGRGeometryFactory.html">OGRGeometryFactory</a> object.</p>
<p>The C function OGR_G_CreateFromFgf() is the same as this method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pabyData</em>&nbsp;</td><td>pointer to the input BLOB data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>poSR</em>&nbsp;</td><td>pointer to the spatial reference to be assigned to the created geometry object. This may be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ppoReturn</em>&nbsp;</td><td>the newly created geometry object will be assigned to the indicated pointer on return. This will be NULL in case of failure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nBytes</em>&nbsp;</td><td>the number of bytes available in pabyData. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnBytesConsumed</em>&nbsp;</td><td>if not NULL, it will be set to the number of bytes consumed (at most nBytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE if all goes well, otherwise any of OGRERR_NOT_ENOUGH_DATA, OGRERR_UNSUPPORTED_GEOMETRY_TYPE, or OGRERR_CORRUPT_DATA may be returned. </dd></dl>

</div>
</div>
<a class="anchor" id="af8714df4e6b6c5d5b2cdbdeec78af08c"></a><!-- doxytag: member="OGRGeometryFactory::createFromGML" ref="af8714df4e6b6c5d5b2cdbdeec78af08c" args="(const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometryFactory::createFromGML </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszData</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create geometry from GML. </p>
<p>This method translates a fragment of GML containing only the geometry portion into a corresponding <a class="el" href="classOGRGeometry.html">OGRGeometry</a>. There are many limitations on the forms of GML geometries supported by this parser, but they are too numerous to list here.</p>
<p>The following GML2 elements are parsed : Point, LineString, Polygon, MultiPoint, MultiLineString, MultiPolygon, MultiGeometry.</p>
<p>(OGR &gt;= 1.8.0) The following GML3 elements are parsed : Surface, MultiSurface, PolygonPatch, Triangle, Rectangle, Curve, MultiCurve, LineStringSegment, Arc, Circle, CompositeSurface, OrientableSurface, Solid, Tin, TriangulatedSurface.</p>
<p>Arc and Circle elements are stroked to linestring, by using a 4 degrees step, unless the user has overridden the value with the OGR_ARC_STEPSIZE configuration variable.</p>
<p>The C function <a class="el" href="ogr__api_8h.html#aef37aa4d89f303fee679f97d32461d69" title="Create geometry from GML.">OGR_G_CreateFromGML()</a> is the same as this method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszData</em>&nbsp;</td><td>The GML fragment for the geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a geometry on succes, or NULL on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a699688dba97260f2eb29f802e39cb0ec"></a><!-- doxytag: member="OGRGeometryFactory::createFromWkb" ref="a699688dba97260f2eb29f802e39cb0ec" args="(unsigned char *, OGRSpatialReference *, OGRGeometry **, int=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRGeometryFactory::createFromWkb </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>pabyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&nbsp;</td>
          <td class="paramname"> <em>poSR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> **&nbsp;</td>
          <td class="paramname"> <em>ppoReturn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nBytes</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a geometry object of the appropriate type from it's well known binary representation. </p>
<p>Note that if nBytes is passed as zero, no checking can be done on whether the pabyData is sufficient. This can result in a crash if the input data is corrupt. This function returns no indication of the number of bytes from the data source actually used to represent the returned geometry object. Use <a class="el" href="classOGRGeometry.html#acd1a8164dae2e44e50990756ed6b8b4a" title="Returns size of related binary representation.">OGRGeometry::WkbSize()</a> on the returned geometry to establish the number of bytes it required in WKB format.</p>
<p>Also note that this is a static method, and that there is no need to instantiate an <a class="el" href="classOGRGeometryFactory.html">OGRGeometryFactory</a> object.</p>
<p>The C function <a class="el" href="ogr__api_8h.html#a3172c8e5b8a094b8ce97fa5d44bcd204" title="Create a geometry object of the appropriate type from it&#39;s well known binary representation.">OGR_G_CreateFromWkb()</a> is the same as this method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pabyData</em>&nbsp;</td><td>pointer to the input BLOB data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>poSR</em>&nbsp;</td><td>pointer to the spatial reference to be assigned to the created geometry object. This may be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ppoReturn</em>&nbsp;</td><td>the newly created geometry object will be assigned to the indicated pointer on return. This will be NULL in case of failure. If not NULL, *ppoReturn should be freed with <a class="el" href="classOGRGeometryFactory.html#aae001086e26985d95c36ccd255a8c6d5" title="Destroy geometry object.">OGRGeometryFactory::destroyGeometry()</a> after use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nBytes</em>&nbsp;</td><td>the number of bytes available in pabyData, or -1 if it isn't known.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE if all goes well, otherwise any of OGRERR_NOT_ENOUGH_DATA, OGRERR_UNSUPPORTED_GEOMETRY_TYPE, or OGRERR_CORRUPT_DATA may be returned. </dd></dl>

<p>References <a class="el" href="classOGRGeometry.html#a4308e3549c65aa12cc2ba41be15d99a0">OGRGeometry::assignSpatialReference()</a>, <a class="el" href="classOGRGeometryFactory.html#ae4887e270d5099357f9a19b1eda6027a">createGeometry()</a>, and <a class="el" href="classOGRGeometry.html#ab2c6583c2b7c3e526dcfe54a61470c1f">OGRGeometry::importFromWkb()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a3172c8e5b8a094b8ce97fa5d44bcd204">OGR_G_CreateFromWkb()</a>.</p>

</div>
</div>
<a class="anchor" id="a9418f71bcfb1e334173882c38d89d070"></a><!-- doxytag: member="OGRGeometryFactory::createFromWkt" ref="a9418f71bcfb1e334173882c38d89d070" args="(char **, OGRSpatialReference *, OGRGeometry **)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRGeometryFactory::createFromWkt </td>
          <td>(</td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>ppszData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&nbsp;</td>
          <td class="paramname"> <em>poSR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> **&nbsp;</td>
          <td class="paramname"> <em>ppoReturn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a geometry object of the appropriate type from it's well known text representation. </p>
<p>The C function <a class="el" href="ogr__api_8h.html#ac02c3ed5f7ebd5039dc2ae70154fd94a" title="Create a geometry object of the appropriate type from it&#39;s well known text representation.">OGR_G_CreateFromWkt()</a> is the same as this method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ppszData</em>&nbsp;</td><td>input zero terminated string containing well known text representation of the geometry to be created. The pointer is updated to point just beyond that last character consumed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>poSR</em>&nbsp;</td><td>pointer to the spatial reference to be assigned to the created geometry object. This may be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ppoReturn</em>&nbsp;</td><td>the newly created geometry object will be assigned to the indicated pointer on return. This will be NULL if the method fails. If not NULL, *ppoReturn should be freed with <a class="el" href="classOGRGeometryFactory.html#aae001086e26985d95c36ccd255a8c6d5" title="Destroy geometry object.">OGRGeometryFactory::destroyGeometry()</a> after use.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example:</b></p>
<pre>
    const char* wkt= "POINT(0 0)";</pre><pre>    // cast because OGR_G_CreateFromWkt will move the pointer 
    char* pszWkt = (char*) wkt;
    OGRSpatialReferenceH ref = OSRNewSpatialReference(NULL);
    OGRGeometryH new_geom;
    OGRErr err = OGR_G_CreateFromWkt(&amp;pszWkt, ref, &amp;new_geom);
  </pre><dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE if all goes well, otherwise any of OGRERR_NOT_ENOUGH_DATA, OGRERR_UNSUPPORTED_GEOMETRY_TYPE, or OGRERR_CORRUPT_DATA may be returned. </dd></dl>

<p>References <a class="el" href="classOGRGeometry.html#a4308e3549c65aa12cc2ba41be15d99a0">OGRGeometry::assignSpatialReference()</a>, and <a class="el" href="classOGRGeometry.html#a30561a301d44b1f90393ea4a78a5b0a5">OGRGeometry::importFromWkt()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ac02c3ed5f7ebd5039dc2ae70154fd94a">OGR_G_CreateFromWkt()</a>.</p>

</div>
</div>
<a class="anchor" id="ae4887e270d5099357f9a19b1eda6027a"></a><!-- doxytag: member="OGRGeometryFactory::createGeometry" ref="ae4887e270d5099357f9a19b1eda6027a" args="(OGRwkbGeometryType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometryFactory::createGeometry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&nbsp;</td>
          <td class="paramname"> <em>eGeometryType</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an empty geometry of desired type. </p>
<p>This is equivalent to allocating the desired geometry with new, but the allocation is guaranteed to take place in the context of the GDAL/OGR heap.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a4e47710cf70e5bc72216704ddfead0dd" title="Create an empty geometry of desired type.">OGR_G_CreateGeometry()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>eGeometryType</em>&nbsp;</td><td>the type code of the geometry class to be instantiated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly create geometry or NULL on failure. Should be freed with <a class="el" href="classOGRGeometryFactory.html#aae001086e26985d95c36ccd255a8c6d5" title="Destroy geometry object.">OGRGeometryFactory::destroyGeometry()</a> after use. </dd></dl>

<p>References <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa7f299e8edaee30fd3c7a40baf19b48b1">wkbGeometryCollection</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa48a515899277ce8ccd0bb6041fd42bcc">wkbLinearRing</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa09fd8f51759a1cf351b04e786a2a9058">wkbLineString</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa2ecf4d40ab038779cbc1de22ddcb3429">wkbMultiLineString</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa826c812d3551fa07feb4c3664517c29c">wkbMultiPoint</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa7ff2322e0696d383d7715b7e7be1a7b1">wkbMultiPolygon</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa6f8377c5a4a9d36ae2384f4a5f45d77f">wkbPoint</a>, and <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa11991cd1245f146f3efd694553433aeb">wkbPolygon</a>.</p>

<p>Referenced by <a class="el" href="classOGRGeometryFactory.html#a699688dba97260f2eb29f802e39cb0ec">createFromWkb()</a>, and <a class="el" href="ogr__api_8h.html#a4e47710cf70e5bc72216704ddfead0dd">OGR_G_CreateGeometry()</a>.</p>

</div>
</div>
<a class="anchor" id="aae001086e26985d95c36ccd255a8c6d5"></a><!-- doxytag: member="OGRGeometryFactory::destroyGeometry" ref="aae001086e26985d95c36ccd255a8c6d5" args="(OGRGeometry *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometryFactory::destroyGeometry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td>
          <td class="paramname"> <em>poGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy geometry object. </p>
<p>Equivalent to invoking delete on a geometry, but it guaranteed to take place within the context of the GDAL/OGR heap.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ac4e665f5f9690c4fa0c190b930fe9492" title="Destroy geometry object.">OGR_G_DestroyGeometry()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poGeom</em>&nbsp;</td><td>the geometry to deallocate. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ac4e665f5f9690c4fa0c190b930fe9492">OGR_G_DestroyGeometry()</a>.</p>

</div>
</div>
<a class="anchor" id="adcae79ea28620e332a3d1df87f1180f3"></a><!-- doxytag: member="OGRGeometryFactory::forceToLineString" ref="adcae79ea28620e332a3d1df87f1180f3" args="(OGRGeometry *, bool bOnlyInOrder=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometryFactory::forceToLineString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td>
          <td class="paramname"> <em>poGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>bOnlyInOrder</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert to line string. </p>
<p>Tries to force the provided geometry to be a line string. Currently this just effects a change on multilinestrings. The passed in geometry is consumed and a new one returned (or potentially the same one).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poGeom</em>&nbsp;</td><td>the input geometry - ownership is passed to the method. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bOnlyInOrder</em>&nbsp;</td><td>flag that, if set to FALSE, indicate that the order of points in a linestring might be reversed if it enables to match the extremity of another linestring. If set to TRUE, the start of a linestring must match the end of another linestring. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>new geometry. </dd></dl>

<p>References <a class="el" href="classOGRLineString.html#ae43246dc54357517eeca68c7112ae0f5">OGRLineString::addSubLineString()</a>, <a class="el" href="classOGRLineString.html#a99daa05665aef02aa0601eb53af814c1">OGRLineString::EndPoint()</a>, <a class="el" href="classOGRPoint.html#a4e04bfdd79cbf0c74d90ef20e99f13a3">OGRPoint::Equals()</a>, <a class="el" href="classOGRGeometryCollection.html#ad609f2c7886918a766dd3d3a4fa52ec3">OGRGeometryCollection::getGeometryRef()</a>, <a class="el" href="classOGRGeometry.html#a5c6bca18682cb933e3227552d480e1a5">OGRGeometry::getGeometryType()</a>, <a class="el" href="classOGRGeometryCollection.html#a878ea43754b6c6dc824d3a0d1b3dd0e3">OGRGeometryCollection::getNumGeometries()</a>, <a class="el" href="classOGRLineString.html#a7ea70605cd6ac71221177586c2ec5cfc">OGRLineString::getNumPoints()</a>, <a class="el" href="classOGRGeometryCollection.html#ae37405203118eeb0430ef38668a385b7">OGRGeometryCollection::removeGeometry()</a>, <a class="el" href="classOGRLineString.html#ac8299e2d3d5a3d6cf4bc9323d842db3a">OGRLineString::reversePoints()</a>, <a class="el" href="classOGRLineString.html#a48a9e983559b88ecad0629db15f0c790">OGRLineString::StartPoint()</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa7f299e8edaee30fd3c7a40baf19b48b1">wkbGeometryCollection</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa09fd8f51759a1cf351b04e786a2a9058">wkbLineString</a>, and <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa2ecf4d40ab038779cbc1de22ddcb3429">wkbMultiLineString</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a670481ed69704f2be0c2c24a304d3bf5">OGR_G_ForceToLineString()</a>.</p>

</div>
</div>
<a class="anchor" id="a1c00a78cec110d71175726d6f26b1b39"></a><!-- doxytag: member="OGRGeometryFactory::forceToMultiLineString" ref="a1c00a78cec110d71175726d6f26b1b39" args="(OGRGeometry *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometryFactory::forceToMultiLineString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td>
          <td class="paramname"> <em>poGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert to multilinestring. </p>
<p>Tries to force the provided geometry to be a multilinestring.</p>
<ul>
<li>linestrings are placed in a multilinestring.</li>
<li>geometry collections will be converted to multilinestring if they only contain linestrings.</li>
<li>polygons will be changed to a collection of linestrings (one per ring).</li>
</ul>
<p>The passed in geometry is consumed and a new one returned (or potentially the same one).</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>new geometry. </dd></dl>

<p>References <a class="el" href="classOGRMultiLineString.html#ac030cf7183a73d625320b4ab6e7a7fb9">OGRMultiLineString::addGeometryDirectly()</a>, <a class="el" href="classOGRLineString.html#ae43246dc54357517eeca68c7112ae0f5">OGRLineString::addSubLineString()</a>, <a class="el" href="classOGRGeometry.html#a4308e3549c65aa12cc2ba41be15d99a0">OGRGeometry::assignSpatialReference()</a>, <a class="el" href="classOGRPolygon.html#ad4ba927fb74871bf029e6a3efec3586c">OGRPolygon::getExteriorRing()</a>, <a class="el" href="classOGRGeometryCollection.html#ad609f2c7886918a766dd3d3a4fa52ec3">OGRGeometryCollection::getGeometryRef()</a>, <a class="el" href="classOGRGeometry.html#a5c6bca18682cb933e3227552d480e1a5">OGRGeometry::getGeometryType()</a>, <a class="el" href="classOGRPolygon.html#af0bf0b1d1104e142b47637659518ad9c">OGRPolygon::getInteriorRing()</a>, <a class="el" href="classOGRGeometryCollection.html#a878ea43754b6c6dc824d3a0d1b3dd0e3">OGRGeometryCollection::getNumGeometries()</a>, <a class="el" href="classOGRPolygon.html#a3b996195adcf9fcd4f33570a37753dde">OGRPolygon::getNumInteriorRings()</a>, <a class="el" href="classOGRLineString.html#a7ea70605cd6ac71221177586c2ec5cfc">OGRLineString::getNumPoints()</a>, <a class="el" href="classOGRGeometry.html#a194f0bbdae896539852106cafbffbe87">OGRGeometry::getSpatialReference()</a>, <a class="el" href="classOGRGeometryCollection.html#ae37405203118eeb0430ef38668a385b7">OGRGeometryCollection::removeGeometry()</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa7f299e8edaee30fd3c7a40baf19b48b1">wkbGeometryCollection</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa09fd8f51759a1cf351b04e786a2a9058">wkbLineString</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa2ecf4d40ab038779cbc1de22ddcb3429">wkbMultiLineString</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa7ff2322e0696d383d7715b7e7be1a7b1">wkbMultiPolygon</a>, and <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa11991cd1245f146f3efd694553433aeb">wkbPolygon</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ac3d8424596b90664b7280a9e7c89dc96">OGR_G_ForceToMultiLineString()</a>.</p>

</div>
</div>
<a class="anchor" id="aa97b7837101f6c56e476520d10a9f3c3"></a><!-- doxytag: member="OGRGeometryFactory::forceToMultiPoint" ref="aa97b7837101f6c56e476520d10a9f3c3" args="(OGRGeometry *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometryFactory::forceToMultiPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td>
          <td class="paramname"> <em>poGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert to multipoint. </p>
<p>Tries to force the provided geometry to be a multipoint. Currently this just effects a change on points. The passed in geometry is consumed and a new one returned (or potentially the same one).</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>new geometry. </dd></dl>

<p>References <a class="el" href="classOGRMultiPoint.html#a976d4fb497d3b45bb210ab4bde7ecb67">OGRMultiPoint::addGeometryDirectly()</a>, <a class="el" href="classOGRGeometry.html#a4308e3549c65aa12cc2ba41be15d99a0">OGRGeometry::assignSpatialReference()</a>, <a class="el" href="classOGRGeometryCollection.html#ad609f2c7886918a766dd3d3a4fa52ec3">OGRGeometryCollection::getGeometryRef()</a>, <a class="el" href="classOGRGeometry.html#a5c6bca18682cb933e3227552d480e1a5">OGRGeometry::getGeometryType()</a>, <a class="el" href="classOGRGeometryCollection.html#a878ea43754b6c6dc824d3a0d1b3dd0e3">OGRGeometryCollection::getNumGeometries()</a>, <a class="el" href="classOGRGeometry.html#a194f0bbdae896539852106cafbffbe87">OGRGeometry::getSpatialReference()</a>, <a class="el" href="classOGRGeometryCollection.html#ae37405203118eeb0430ef38668a385b7">OGRGeometryCollection::removeGeometry()</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa7f299e8edaee30fd3c7a40baf19b48b1">wkbGeometryCollection</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa826c812d3551fa07feb4c3664517c29c">wkbMultiPoint</a>, and <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa6f8377c5a4a9d36ae2384f4a5f45d77f">wkbPoint</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#aedd1952b5cde54253746d9da1a2b0500">OGR_G_ForceToMultiPoint()</a>.</p>

</div>
</div>
<a class="anchor" id="a2a40032fa65cc71c028516bf8fc0df3e"></a><!-- doxytag: member="OGRGeometryFactory::forceToMultiPolygon" ref="a2a40032fa65cc71c028516bf8fc0df3e" args="(OGRGeometry *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometryFactory::forceToMultiPolygon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td>
          <td class="paramname"> <em>poGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert to multipolygon. </p>
<p>Tries to force the provided geometry to be a multipolygon. Currently this just effects a change on polygons. The passed in geometry is consumed and a new one returned (or potentially the same one).</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>new geometry. </dd></dl>

<p>References <a class="el" href="classOGRMultiPolygon.html#a246ff65cee942960a98f64539ebbf7ad">OGRMultiPolygon::addGeometryDirectly()</a>, <a class="el" href="classOGRGeometry.html#a4308e3549c65aa12cc2ba41be15d99a0">OGRGeometry::assignSpatialReference()</a>, <a class="el" href="classOGRGeometryCollection.html#ad609f2c7886918a766dd3d3a4fa52ec3">OGRGeometryCollection::getGeometryRef()</a>, <a class="el" href="classOGRGeometry.html#a5c6bca18682cb933e3227552d480e1a5">OGRGeometry::getGeometryType()</a>, <a class="el" href="classOGRGeometryCollection.html#a878ea43754b6c6dc824d3a0d1b3dd0e3">OGRGeometryCollection::getNumGeometries()</a>, <a class="el" href="classOGRGeometry.html#a194f0bbdae896539852106cafbffbe87">OGRGeometry::getSpatialReference()</a>, <a class="el" href="classOGRGeometryCollection.html#ae37405203118eeb0430ef38668a385b7">OGRGeometryCollection::removeGeometry()</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa7f299e8edaee30fd3c7a40baf19b48b1">wkbGeometryCollection</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa7ff2322e0696d383d7715b7e7be1a7b1">wkbMultiPolygon</a>, and <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa11991cd1245f146f3efd694553433aeb">wkbPolygon</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#abea3d494951ab99e72b59cbd5318e8c4">OGR_G_ForceToMultiPolygon()</a>.</p>

</div>
</div>
<a class="anchor" id="afd61936e41ea69831b3196e817658d08"></a><!-- doxytag: member="OGRGeometryFactory::forceToPolygon" ref="afd61936e41ea69831b3196e817658d08" args="(OGRGeometry *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometryFactory::forceToPolygon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td>
          <td class="paramname"> <em>poGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert to polygon. </p>
<p>Tries to force the provided geometry to be a polygon. Currently this just effects a change on multipolygons. The passed in geometry is consumed and a new one returned (or potentially the same one).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poGeom</em>&nbsp;</td><td>the input geometry - ownership is passed to the method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>new geometry. </dd></dl>

<p>References <a class="el" href="classOGRPolygon.html#a17f7fca852efca8155fba7cbad7572c0">OGRPolygon::addRingDirectly()</a>, <a class="el" href="classOGRGeometry.html#a4308e3549c65aa12cc2ba41be15d99a0">OGRGeometry::assignSpatialReference()</a>, <a class="el" href="classOGRPolygon.html#ad4ba927fb74871bf029e6a3efec3586c">OGRPolygon::getExteriorRing()</a>, <a class="el" href="classOGRGeometryCollection.html#ad609f2c7886918a766dd3d3a4fa52ec3">OGRGeometryCollection::getGeometryRef()</a>, <a class="el" href="classOGRGeometry.html#a5c6bca18682cb933e3227552d480e1a5">OGRGeometry::getGeometryType()</a>, <a class="el" href="classOGRGeometryCollection.html#a878ea43754b6c6dc824d3a0d1b3dd0e3">OGRGeometryCollection::getNumGeometries()</a>, <a class="el" href="classOGRPolygon.html#a3b996195adcf9fcd4f33570a37753dde">OGRPolygon::getNumInteriorRings()</a>, <a class="el" href="classOGRGeometry.html#a194f0bbdae896539852106cafbffbe87">OGRGeometry::getSpatialReference()</a>, <a class="el" href="classOGRPolygon.html#a8ed182b4cd75d1ae4fd81d6e1027f740">OGRPolygon::stealExteriorRing()</a>, <a class="el" href="classOGRPolygon.html#a4095bca5e424f73d33e3925e19365dfa">OGRPolygon::stealInteriorRing()</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa7f299e8edaee30fd3c7a40baf19b48b1">wkbGeometryCollection</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa7ff2322e0696d383d7715b7e7be1a7b1">wkbMultiPolygon</a>, and <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa11991cd1245f146f3efd694553433aeb">wkbPolygon</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ac4d5e3d348db62e46ebba718edb36abe">OGR_G_ForceToPolygon()</a>.</p>

</div>
</div>
<a class="anchor" id="a04998dcdbb37aa37871891593c048544"></a><!-- doxytag: member="OGRGeometryFactory::haveGEOS" ref="a04998dcdbb37aa37871891593c048544" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRGeometryFactory::haveGEOS </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if GEOS enabled. </p>
<p>This static method returns TRUE if GEOS support is built into OGR, otherwise it returns FALSE.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if available, otherwise FALSE. </dd></dl>

<p>Referenced by <a class="el" href="classOGRLayer.html#a56d7ee3b2020e53c730d67ee4f1e2fb6">OGRLayer::Clip()</a>, <a class="el" href="classOGRLayer.html#ae8fcf55ffa259f32df35edcb05274439">OGRLayer::Erase()</a>, <a class="el" href="classOGRLayer.html#acac6a0bde9737555b22c6ac7fa967431">OGRLayer::Identity()</a>, <a class="el" href="classOGRLayer.html#ac189f54996c2d6fd769889ec99e0f48a">OGRLayer::Intersection()</a>, <a class="el" href="classOGRGeometryFactory.html#afa3e76499553c3dc0a1621af98b88be6">organizePolygons()</a>, <a class="el" href="classOGRLayer.html#a781aa76c6b44b19de09f61816e32245b">OGRLayer::SymDifference()</a>, <a class="el" href="classOGRLayer.html#aeb8ab475561f2aca2c0e605cfb810b22">OGRLayer::Union()</a>, and <a class="el" href="classOGRLayer.html#aa1c5dc5ca195956c46d35a85b0b21d9b">OGRLayer::Update()</a>.</p>

</div>
</div>
<a class="anchor" id="afa3e76499553c3dc0a1621af98b88be6"></a><!-- doxytag: member="OGRGeometryFactory::organizePolygons" ref="afa3e76499553c3dc0a1621af98b88be6" args="(OGRGeometry **papoPolygons, int nPolygonCount, int *pbResultValidGeometry, const char **papszOptions=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometryFactory::organizePolygons </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> **&nbsp;</td>
          <td class="paramname"> <em>papoPolygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nPolygonCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pbIsValidGeometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>papszOptions</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Organize polygons based on geometries. </p>
<p>Analyse a set of rings (passed as simple polygons), and based on a geometric analysis convert them into a polygon with inner rings, (or a MultiPolygon if dealing with more than one polygon) that follow the OGC Simple Feature specification.</p>
<p>All the input geometries must be OGRPolygons with only a valid exterior ring (at least 4 points) and no interior rings.</p>
<p>The passed in geometries become the responsibility of the method, but the papoPolygons "pointer array" remains owned by the caller.</p>
<p>For faster computation, a polygon is considered to be inside another one if a single point of its external ring is included into the other one. (unless 'OGR_DEBUG_ORGANIZE_POLYGONS' configuration option is set to TRUE. In that case, a slower algorithm that tests exact topological relationships is used if GEOS is available.)</p>
<p>In cases where a big number of polygons is passed to this function, the default processing may be really slow. You can skip the processing by adding METHOD=SKIP to the option list (the result of the function will be a multi-polygon with all polygons as toplevel polygons) or only make it analyze counterclockwise polygons by adding METHOD=ONLY_CCW to the option list if you can assume that the outline of holes is counterclockwise defined (this is the convention for example in shapefiles, Personal Geodatabases or File Geodatabases).</p>
<p>For FileGDB, in most cases, but not always, a faster method than ONLY_CCW can be used. It is CCW_INNER_JUST_AFTER_CW_OUTER. When using it, inner rings are assumed to be counterclockwise oriented, and following immediately the outer ring (clockwise oriented) that they belong to. If that assumption is not met, an inner ring could be attached to the wrong outer ring, so this method must be used with care.</p>
<p>If the OGR_ORGANIZE_POLYGONS configuration option is defined, its value will override the value of the METHOD option of papszOptions (usefull to modify the behaviour of the shapefile driver)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>papoPolygons</em>&nbsp;</td><td>array of geometry pointers - should all be OGRPolygons. Ownership of the geometries is passed, but not of the array itself. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nPolygonCount</em>&nbsp;</td><td>number of items in papoPolygons </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pbIsValidGeometry</em>&nbsp;</td><td>value will be set TRUE if result is valid or FALSE otherwise. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>papszOptions</em>&nbsp;</td><td>a list of strings for passing options</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a single resulting geometry (either <a class="el" href="classOGRPolygon.html">OGRPolygon</a> or <a class="el" href="classOGRMultiPolygon.html">OGRMultiPolygon</a>). </dd></dl>

<p>References <a class="el" href="classOGRMultiPolygon.html#a246ff65cee942960a98f64539ebbf7ad">OGRMultiPolygon::addGeometryDirectly()</a>, <a class="el" href="classOGRPolygon.html#a17f7fca852efca8155fba7cbad7572c0">OGRPolygon::addRingDirectly()</a>, <a class="el" href="classOGRPolygon.html#ade6a6d5d628f3ad57d0ce9dca8e26618">OGRPolygon::exportToWkt()</a>, <a class="el" href="classOGRPolygon.html#ad8ba9b796aafc593f5bd7bcf1086bc3d">OGRPolygon::get_Area()</a>, <a class="el" href="classOGRGeometry.html#aa3d42b06ae6f7bbef6d1a2886da8d398">OGRGeometry::getEnvelope()</a>, <a class="el" href="classOGRPolygon.html#ad4ba927fb74871bf029e6a3efec3586c">OGRPolygon::getExteriorRing()</a>, <a class="el" href="classOGRLineString.html#a7ea70605cd6ac71221177586c2ec5cfc">OGRLineString::getNumPoints()</a>, <a class="el" href="classOGRLineString.html#aab63760022e49a795477f2fd31da059f">OGRLineString::getPoint()</a>, <a class="el" href="classOGRPoint.html#a1d7f8cb579cd0d029efda38026bf4b68">OGRPoint::getX()</a>, <a class="el" href="classOGRPoint.html#a235eac8e50f6ce105ff5c16655d05ba9">OGRPoint::getY()</a>, <a class="el" href="classOGRGeometryFactory.html#a04998dcdbb37aa37871891593c048544">haveGEOS()</a>, <a class="el" href="classOGRLinearRing.html#a34b47e8dd2e24eb447ca70c1d04259db">OGRLinearRing::isClockwise()</a>, <a class="el" href="classOGRGeometry.html#afc672c524568f3ee6ee5257b250d2b12">OGRGeometry::Overlaps()</a>, <a class="el" href="classOGRPoint.html#a0eef5e2d9e0edeca0e0f06c7527facb4">OGRPoint::setX()</a>, <a class="el" href="classOGRPoint.html#ab064eaaedb2140ed1410e7c2ce4ad1ca">OGRPoint::setY()</a>, and <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa11991cd1245f146f3efd694553433aeb">wkbPolygon</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="ogr__geometry_8h_source.html">ogr_geometry.h</a></li>
<li>ogrgeometryfactory.cpp</li>
</ul>
</div>
<hr>

Generated for GDAL by 
<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.7.1.
</body>
</html>

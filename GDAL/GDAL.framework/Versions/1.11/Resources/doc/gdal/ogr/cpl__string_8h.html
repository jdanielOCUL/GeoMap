<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OGR: cpl_string.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="dir_9f99e07d1011014ac11448b6dc0b7a3e.html">port</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>cpl_string.h File Reference</h1>  </div>
</div>
<div class="contents">
<code>#include &quot;<a class="el" href="cpl__vsi_8h_source.html">cpl_vsi.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="cpl__error_8h_source.html">cpl_error.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="cpl__conv_8h_source.html">cpl_conv.h</a>&quot;</code><br/>
<code>#include &lt;string&gt;</code><br/>

<p><a href="cpl__string_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLString.html">CPLString</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenient string class based on std::string.  <a href="classCPLString.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLStringList.html">CPLStringList</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">String list class designed around our use of C "char**" string lists.  <a href="classCPLStringList.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#ac1ffd0e5baf9729f09388a38c07f5835">CSLCount</a> (char **papszStrList)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a5a39b9c5896a273cc6f06c1d5be93238">CSLDestroy</a> (char **papszStrList)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a8b9c9ad6c5a416c91f1fca55d9a91701">CSLDuplicate</a> (char **papszStrList)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#ad2766cf9f275a413c46ac4f7fa749be7">CSLMerge</a> (char **papszOrig, char **papszOverride)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Merge two lists.  <a href="#ad2766cf9f275a413c46ac4f7fa749be7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a36f1e4efb0da65e3d900d3a0ce8cbaab">CSLTokenizeString2</a> (const char *pszString, const char *pszDelimeter, int nCSLTFlags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#ad7af0a270dc019a17bf1326da8e6a970">CSLLoad</a> (const char *pszFname)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a52852635691b8ca3390ab98d000b5e45">CSLLoad2</a> (const char *pszFname, int nMaxLines, int nMaxCols, char **papszOptions)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#aadb00ff49c2d9dc32c043ca58fd9d8cd">CSLFindString</a> (char **, const char *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#aa1211d7957346bdb49bd40a80475615a">CSLPartialFindString</a> (char **papszHaystack, const char *pszNeedle)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a0901440811294a6a0d6762b6e64107e3">CSLFindName</a> (char **papszStrList, const char *pszName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#ada798bb0fafd08c7908d0f3716f341b3">CSLTestBoolean</a> (const char *pszValue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a40ff577b83aca84a603414183e6903d3">CPLParseNameValue</a> (const char *pszNameValue, char **ppszKey)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a8dbce00a6e7fa4710613e3e4c963dd5d">CSLSetNameValue</a> (char **papszStrList, const char *pszName, const char *pszValue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a97b38f55a35f3c1d66ba343692ab9ec0">CSLSetNameValueSeparator</a> (char **papszStrList, const char *pszSeparator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#adf2c0e5051d8f5c7fc742e4be41e935a">CPLEscapeString</a> (const char *pszString, int nLength, int nScheme)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a74938e1e92b5847af925600af609f8d3">CPLUnescapeString</a> (const char *pszString, int *pnLength, int nScheme)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#ae683e10df83274c83aefc305cbcf4cba">CPLBinaryToHex</a> (int nBytes, const GByte *pabyData)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GByte *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#aababd56ea0317416780a1acc19aa61a3">CPLHexToBinary</a> (const char *pszHex, int *pnBytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CPLValueType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#aafb0188f43b0848407f5e6e7c3cfdbb8">CPLGetValueType</a> (const char *pszValue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a4dee6db43b3ce18912ee45fbfc83e747">CPLStrlcpy</a> (char *pszDest, const char *pszSrc, size_t nDestSize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a35417428994b5306ca08df7899f9703c">CPLStrlcat</a> (char *pszDest, const char *pszSrc, size_t nDestSize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a8d45dc0510e8e8f4e58f3cb70e341732">CPLStrnlen</a> (const char *pszStr, size_t nMaxLen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#aed4d78cf4a6db43d07129a89af6fd45d">CPLEncodingCharSize</a> (const char *pszEncoding)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a0a6b060ecc0f005f338029f825783fb7">CPLRecode</a> (const char *pszSource, const char *pszSrcEncoding, const char *pszDstEncoding)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a1717f249d1d23289b634e7cd9336a1ab">CPLRecodeFromWChar</a> (const wchar_t *pwszSource, const char *pszSrcEncoding, const char *pszDstEncoding)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">wchar_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#ad889c8d3eb7e71cefe15b7278b7798de">CPLRecodeToWChar</a> (const char *pszSource, const char *pszSrcEncoding, const char *pszDstEncoding)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a9b56be2f17e4c2300af2f0357d32baec">CPLIsUTF8</a> (const char *pabyData, int nLen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a31f919f48491735897d370cc2b8f167e">CPLForceToASCII</a> (const char *pabyData, int nLen, char chReplacementChar)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#acc8e4b09f4437d7ef0cc09b5e3ab93cb">CPLStrlenUTF8</a> (const char *pszUTF8Str)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCPLString.html">CPLString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#a49550245214ac079518c5fcd5084ecd0">CPLURLGetValue</a> (const char *pszURL, const char *pszKey)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCPLString.html">CPLString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__string_8h.html#ac45405998f4df728887be28a1a6d4b6e">CPLURLAddKVP</a> (const char *pszURL, const char *pszKey, const char *pszValue)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Various convenience functions for working with strings and string lists.</p>
<p>A StringList is just an array of strings with the last pointer being NULL. An empty StringList may be either a NULL pointer, or a pointer to a pointer memory location with a NULL value.</p>
<p>A common convention for StringLists is to use them to store name/value lists. In this case the contents are treated like a dictionary of name/value pairs. The actual data is formatted with each string having the format "&lt;name&gt;:&lt;value&gt;" (though "=" is also an acceptable separator). A number of the functions in the file operate on name/value style string lists (such as <a class="el" href="cpl__string_8h.html#a8dbce00a6e7fa4710613e3e4c963dd5d">CSLSetNameValue()</a>, and CSLFetchNameValue()).</p>
<p>To some extent the <a class="el" href="classCPLStringList.html" title="String list class designed around our use of C &quot;char**&quot; string lists.">CPLStringList</a> C++ class can be used to abstract managing string lists a bit but still be able to return them from C functions. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ae683e10df83274c83aefc305cbcf4cba"></a><!-- doxytag: member="cpl_string.h::CPLBinaryToHex" ref="ae683e10df83274c83aefc305cbcf4cba" args="(int nBytes, const GByte *pabyData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* CPLBinaryToHex </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GByte *&nbsp;</td>
          <td class="paramname"> <em>pabyData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Binary to hexadecimal translation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nBytes</em>&nbsp;</td><td>number of bytes of binary data in pabyData. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pabyData</em>&nbsp;</td><td>array of data bytes to translate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>hexadecimal translation, zero terminated. Free with CPLFree(). </dd></dl>

</div>
</div>
<a class="anchor" id="aed4d78cf4a6db43d07129a89af6fd45d"></a><!-- doxytag: member="cpl_string.h::CPLEncodingCharSize" ref="aed4d78cf4a6db43d07129a89af6fd45d" args="(const char *pszEncoding)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLEncodingCharSize </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszEncoding</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return bytes per character for encoding.</p>
<p>This function returns the size in bytes of the smallest character in this encoding. For fixed width encodings (ASCII, UCS-2, UCS-4) this is straight forward. For encodings like UTF8 and UTF16 which represent some characters as a sequence of atomic character sizes the function still returns the atomic character size (1 for UTF8, 2 for UTF16).</p>
<p>This function will return the correct value for well known encodings with corresponding CPL_ENC_ values. It may not return the correct value for other encodings even if they are supported by the underlying iconv or windows transliteration services. Hopefully it will improve over time.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszEncoding</em>&nbsp;</td><td>the name of the encoding.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the size of a minimal character in bytes or -1 if the size is unknown. </dd></dl>

</div>
</div>
<a class="anchor" id="adf2c0e5051d8f5c7fc742e4be41e935a"></a><!-- doxytag: member="cpl_string.h::CPLEscapeString" ref="adf2c0e5051d8f5c7fc742e4be41e935a" args="(const char *pszString, int nLength, int nScheme)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* CPLEscapeString </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nScheme</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Apply escaping to string to preserve special characters.</p>
<p>This function will "escape" a variety of special characters to make the string suitable to embed within a string constant or to write within a text stream but in a form that can be reconstitued to it's original form. The escaping will even preserve zero bytes allowing preservation of raw binary data.</p>
<p>CPLES_BackslashQuotable(0): This scheme turns a binary string into a form suitable to be placed within double quotes as a string constant. The backslash, quote, '\0' and newline characters are all escaped in the usual C style.</p>
<p>CPLES_XML(1): This scheme converts the '&lt;', '&gt;', '"' and '&amp;' characters into their XML/HTML equivelent (&lt;, &gt;, " and &amp;) making a string safe to embed as CDATA within an XML element. The '\0' is not escaped and should not be included in the input.</p>
<p>CPLES_URL(2): Everything except alphanumerics and the underscore are converted to a percent followed by a two digit hex encoding of the character (leading zero supplied if needed). This is the mechanism used for encoding values to be passed in URLs.</p>
<p>CPLES_SQL(3): All single quotes are replaced with two single quotes. Suitable for use when constructing literal values for SQL commands where the literal will be enclosed in single quotes.</p>
<p>CPLES_CSV(4): If the values contains commas, semicolons, tabs, double quotes, or newlines it placed in double quotes, and double quotes in the value are doubled. Suitable for use when constructing field values for .csv files. Note that <a class="el" href="cpl__string_8h.html#a74938e1e92b5847af925600af609f8d3">CPLUnescapeString()</a> currently does not support this format, only <a class="el" href="cpl__string_8h.html#adf2c0e5051d8f5c7fc742e4be41e935a">CPLEscapeString()</a>. See cpl_csv.cpp for csv parsing support.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszInput</em>&nbsp;</td><td>the string to escape. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nLength</em>&nbsp;</td><td>The number of bytes of data to preserve. If this is -1 the strlen(pszString) function will be used to compute the length. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nScheme</em>&nbsp;</td><td>the encoding scheme to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an escaped, zero terminated string that should be freed with CPLFree() when no longer needed. </dd></dl>

</div>
</div>
<a class="anchor" id="a31f919f48491735897d370cc2b8f167e"></a><!-- doxytag: member="cpl_string.h::CPLForceToASCII" ref="a31f919f48491735897d370cc2b8f167e" args="(const char *pabyData, int nLen, char chReplacementChar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* CPLForceToASCII </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pabyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>chReplacementChar</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a new string that is made only of ASCII characters. If non-ASCII characters are found in the input string, they will be replaced by the provided replacement character.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pabyData</em>&nbsp;</td><td>input string to test </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nLen</em>&nbsp;</td><td>length of the input string, or -1 if the function must compute the string length. In which case it must be null terminated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>chReplacementChar</em>&nbsp;</td><td>character which will be used when the input stream contains a non ASCII character. Must be valid ASCII !</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new string that must be freed with CPLFree().</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.7.0 </dd></dl>

</div>
</div>
<a class="anchor" id="aafb0188f43b0848407f5e6e7c3cfdbb8"></a><!-- doxytag: member="cpl_string.h::CPLGetValueType" ref="aafb0188f43b0848407f5e6e7c3cfdbb8" args="(const char *pszValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPLValueType CPLGetValueType </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszValue</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Detect the type of the value contained in a string, whether it is a real, an integer or a string Leading and trailing spaces are skipped in the analysis.</p>
<p>Note: in the context of this function, integer must be understood in a broad sense. It does not mean that the value can fit into a 32 bit integer for example. It might be larger.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszValue</em>&nbsp;</td><td>the string to analyze</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>returns the type of the value contained in the string. </dd></dl>

</div>
</div>
<a class="anchor" id="aababd56ea0317416780a1acc19aa61a3"></a><!-- doxytag: member="cpl_string.h::CPLHexToBinary" ref="aababd56ea0317416780a1acc19aa61a3" args="(const char *pszHex, int *pnBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GByte* CPLHexToBinary </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszHex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pnBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Hexadecimal to binary translation</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszHex</em>&nbsp;</td><td>the input hex encoded string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnBytes</em>&nbsp;</td><td>the returned count of decoded bytes placed here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>returns binary buffer of data - free with CPLFree(). </dd></dl>

</div>
</div>
<a class="anchor" id="a9b56be2f17e4c2300af2f0357d32baec"></a><!-- doxytag: member="cpl_string.h::CPLIsUTF8" ref="a9b56be2f17e4c2300af2f0357d32baec" args="(const char *pabyData, int nLen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLIsUTF8 </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pabyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nLen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Test if a string is encoded as UTF-8.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pabyData</em>&nbsp;</td><td>input string to test </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nLen</em>&nbsp;</td><td>length of the input string, or -1 if the function must compute the string length. In which case it must be null terminated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the string is encoded as UTF-8. FALSE otherwise</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.7.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a40ff577b83aca84a603414183e6903d3"></a><!-- doxytag: member="cpl_string.h::CPLParseNameValue" ref="a40ff577b83aca84a603414183e6903d3" args="(const char *pszNameValue, char **ppszKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* CPLParseNameValue </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszNameValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>ppszKey</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Parse NAME=VALUE string into name and value components.</p>
<p>Note that if ppszKey is non-NULL, the key (or name) portion will be allocated using VSIMalloc(), and returned in that pointer. It is the applications responsibility to free this string, but the application should not modify or free the returned value portion.</p>
<p>This function also support "NAME:VALUE" strings and will strip white space from around the delimeter when forming name and value strings.</p>
<p>Eventually CSLFetchNameValue() and friends may be modified to use <a class="el" href="cpl__string_8h.html#a40ff577b83aca84a603414183e6903d3">CPLParseNameValue()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszNameValue</em>&nbsp;</td><td>string in "NAME=VALUE" format. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ppszKey</em>&nbsp;</td><td>optional pointer though which to return the name portion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the value portion (pointing into original string). </dd></dl>

</div>
</div>
<a class="anchor" id="a0a6b060ecc0f005f338029f825783fb7"></a><!-- doxytag: member="cpl_string.h::CPLRecode" ref="a0a6b060ecc0f005f338029f825783fb7" args="(const char *pszSource, const char *pszSrcEncoding, const char *pszDstEncoding)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* CPLRecode </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszSrcEncoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszDstEncoding</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert a string from a source encoding to a destination encoding.</p>
<p>The only guaranteed supported encodings are CPL_ENC_UTF8, CPL_ENC_ASCII and CPL_ENC_ISO8859_1. Currently, the following conversions are supported : </p>
<ul>
<li>
CPL_ENC_ASCII -&gt; CPL_ENC_UTF8 or CPL_ENC_ISO8859_1 (no conversion in fact) </li>
<li>
CPL_ENC_ISO8859_1 -&gt; CPL_ENC_UTF8 </li>
<li>
CPL_ENC_UTF8 -&gt; CPL_ENC_ISO8859_1 </li>
</ul>
<p>If an error occurs an error may, or may not be posted with <a class="el" href="cpl__error_8h.html#aad2b98dd58e4de706a245faddac90403">CPLError()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszSource</em>&nbsp;</td><td>a NULL terminated string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszSrcEncoding</em>&nbsp;</td><td>the source encoding. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszDstEncoding</em>&nbsp;</td><td>the destination encoding.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a NULL terminated string which should be freed with CPLFree().</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.6.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a1717f249d1d23289b634e7cd9336a1ab"></a><!-- doxytag: member="cpl_string.h::CPLRecodeFromWChar" ref="a1717f249d1d23289b634e7cd9336a1ab" args="(const wchar_t *pwszSource, const char *pszSrcEncoding, const char *pszDstEncoding)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* CPLRecodeFromWChar </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&nbsp;</td>
          <td class="paramname"> <em>pwszSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszSrcEncoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszDstEncoding</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert wchar_t string to UTF-8.</p>
<p>Convert a wchar_t string into a multibyte utf-8 string. The only guaranteed supported source encoding is CPL_ENC_UCS2, and the only guaranteed supported destination encodings are CPL_ENC_UTF8, CPL_ENC_ASCII and CPL_ENC_ISO8859_1. In some cases (ie. using iconv()) other encodings may also be supported.</p>
<p>Note that the wchar_t type varies in size on different systems. On win32 it is normally 2 bytes, and on unix 4 bytes.</p>
<p>If an error occurs an error may, or may not be posted with <a class="el" href="cpl__error_8h.html#aad2b98dd58e4de706a245faddac90403">CPLError()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pwszSource</em>&nbsp;</td><td>the source wchar_t string, terminated with a 0 wchar_t. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszSrcEncoding</em>&nbsp;</td><td>the source encoding, typically CPL_ENC_UCS2. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszDstEncoding</em>&nbsp;</td><td>the destination encoding, typically CPL_ENC_UTF8.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a zero terminated multi-byte string which should be freed with CPLFree(), or NULL if an error occurs.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.6.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ad889c8d3eb7e71cefe15b7278b7798de"></a><!-- doxytag: member="cpl_string.h::CPLRecodeToWChar" ref="ad889c8d3eb7e71cefe15b7278b7798de" args="(const char *pszSource, const char *pszSrcEncoding, const char *pszDstEncoding)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wchar_t* CPLRecodeToWChar </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszSrcEncoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszDstEncoding</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert UTF-8 string to a wchar_t string.</p>
<p>Convert a 8bit, multi-byte per character input string into a wide character (wchar_t) string. The only guaranteed supported source encodings are CPL_ENC_UTF8, CPL_ENC_ASCII and CPL_ENC_ISO8869_1 (LATIN1). The only guaranteed supported destination encoding is CPL_ENC_UCS2. Other source and destination encodings may be supported depending on the underlying implementation.</p>
<p>Note that the wchar_t type varies in size on different systems. On win32 it is normally 2 bytes, and on unix 4 bytes.</p>
<p>If an error occurs an error may, or may not be posted with <a class="el" href="cpl__error_8h.html#aad2b98dd58e4de706a245faddac90403">CPLError()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszSource</em>&nbsp;</td><td>input multi-byte character string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszSrcEncoding</em>&nbsp;</td><td>source encoding, typically CPL_ENC_UTF8. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszDstEncoding</em>&nbsp;</td><td>destination encoding, typically CPL_ENC_UCS2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the zero terminated wchar_t string (to be freed with CPLFree()) or NULL on error.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.6.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a35417428994b5306ca08df7899f9703c"></a><!-- doxytag: member="cpl_string.h::CPLStrlcat" ref="a35417428994b5306ca08df7899f9703c" args="(char *pszDest, const char *pszSrc, size_t nDestSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t CPLStrlcat </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pszDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nDestSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Appends a source string to a destination buffer.</p>
<p>This function ensures that the destination buffer is always NUL terminated (provided that its length is at least 1 and that there is at least one byte free in pszDest, that is to say strlen(pszDest_before) &lt; nDestSize)</p>
<p>This function is designed to be a safer, more consistent, and less error prone replacement for strncat. Its contract is identical to libbsd's strlcat.</p>
<p>Truncation can be detected by testing if the return value of CPLStrlcat is greater or equal to nDestSize.</p>
<div class="fragment"><pre class="fragment">
char szDest[5];
CPLStrlcpy(szDest, "ab", sizeof(szDest));
if (CPLStrlcat(szDest, "cde", sizeof(szDest)) &gt;= sizeof(szDest))
    fprintf(stderr, "truncation occured !\n");
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszDest</em>&nbsp;</td><td>destination buffer. Must be NUL terminated before running CPLStrlcat </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszSrc</em>&nbsp;</td><td>source string. Must be NUL terminated </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nDestSize</em>&nbsp;</td><td>size of destination buffer (including space for the NUL terminator character)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the thoretical length of the destination string after concatenation (=strlen(pszDest_before) + strlen(pszSrc)). If strlen(pszDest_before) &gt;= nDestSize, then it returns nDestSize + strlen(pszSrc)</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.7.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a4dee6db43b3ce18912ee45fbfc83e747"></a><!-- doxytag: member="cpl_string.h::CPLStrlcpy" ref="a4dee6db43b3ce18912ee45fbfc83e747" args="(char *pszDest, const char *pszSrc, size_t nDestSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t CPLStrlcpy </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pszDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nDestSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy source string to a destination buffer.</p>
<p>This function ensures that the destination buffer is always NUL terminated (provided that its length is at least 1).</p>
<p>This function is designed to be a safer, more consistent, and less error prone replacement for strncpy. Its contract is identical to libbsd's strlcpy.</p>
<p>Truncation can be detected by testing if the return value of CPLStrlcpy is greater or equal to nDestSize.</p>
<div class="fragment"><pre class="fragment">
char szDest[5];
if (CPLStrlcpy(szDest, "abcde", sizeof(szDest)) &gt;= sizeof(szDest))
    fprintf(stderr, "truncation occured !\n");
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszDest</em>&nbsp;</td><td>destination buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszSrc</em>&nbsp;</td><td>source string. Must be NUL terminated </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nDestSize</em>&nbsp;</td><td>size of destination buffer (including space for the NUL terminator character)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the length of the source string (=strlen(pszSrc))</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.7.0 </dd></dl>

</div>
</div>
<a class="anchor" id="acc8e4b09f4437d7ef0cc09b5e3ab93cb"></a><!-- doxytag: member="cpl_string.h::CPLStrlenUTF8" ref="acc8e4b09f4437d7ef0cc09b5e3ab93cb" args="(const char *pszUTF8Str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLStrlenUTF8 </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszUTF8Str</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of UTF-8 characters of a nul-terminated string.</p>
<p>This is different from strlen() which returns the number of bytes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszUTF8Str</em>&nbsp;</td><td>a nul-terminated UTF-8 string</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of UTF-8 characters. </dd></dl>

</div>
</div>
<a class="anchor" id="a8d45dc0510e8e8f4e58f3cb70e341732"></a><!-- doxytag: member="cpl_string.h::CPLStrnlen" ref="a8d45dc0510e8e8f4e58f3cb70e341732" args="(const char *pszStr, size_t nMaxLen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t CPLStrnlen </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nMaxLen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the length of a NUL terminated string by reading at most the specified number of bytes.</p>
<p>The <a class="el" href="cpl__string_8h.html#a8d45dc0510e8e8f4e58f3cb70e341732">CPLStrnlen()</a> function returns MIN(strlen(pszStr), nMaxLen). Only the first nMaxLen bytes of the string will be read. Usefull to test if a string contains at least nMaxLen characters without reading the full string up to the NUL terminating character.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszStr</em>&nbsp;</td><td>a NUL terminated string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nMaxLen</em>&nbsp;</td><td>maximum number of bytes to read in pszStr</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>strlen(pszStr) if the length is lesser than nMaxLen, otherwise nMaxLen if the NUL character has not been found in the first nMaxLen bytes.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.7.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a74938e1e92b5847af925600af609f8d3"></a><!-- doxytag: member="cpl_string.h::CPLUnescapeString" ref="a74938e1e92b5847af925600af609f8d3" args="(const char *pszString, int *pnLength, int nScheme)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* CPLUnescapeString </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pnLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nScheme</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Unescape a string.</p>
<p>This function does the opposite of <a class="el" href="cpl__string_8h.html#adf2c0e5051d8f5c7fc742e4be41e935a">CPLEscapeString()</a>. Given a string with special values escaped according to some scheme, it will return a new copy of the string returned to it's original form.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszInput</em>&nbsp;</td><td>the input string. This is a zero terminated string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnLength</em>&nbsp;</td><td>location to return the length of the unescaped string, which may in some cases include embedded '\0' characters. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nScheme</em>&nbsp;</td><td>the escaped scheme to undo (see <a class="el" href="cpl__string_8h.html#adf2c0e5051d8f5c7fc742e4be41e935a">CPLEscapeString()</a> for a list).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a copy of the unescaped string that should be freed by the application using CPLFree() when no longer needed. </dd></dl>

</div>
</div>
<a class="anchor" id="ac45405998f4df728887be28a1a6d4b6e"></a><!-- doxytag: member="cpl_string.h::CPLURLAddKVP" ref="ac45405998f4df728887be28a1a6d4b6e" args="(const char *pszURL, const char *pszKey, const char *pszValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCPLString.html">CPLString</a> CPLURLAddKVP </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszURL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a new URL with a new key=value pair.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszURL</em>&nbsp;</td><td>the URL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszKey</em>&nbsp;</td><td>the key to find. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszValue</em>&nbsp;</td><td>the value of the key (may be NULL to unset an existing KVP). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the modified URL. </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.9.0 </dd></dl>

<p>References <a class="el" href="cpl__string_8h.html#ac45405998f4df728887be28a1a6d4b6e">CPLURLAddKVP()</a>, and <a class="el" href="classCPLString.html#a7d6295451382acec94098725445435f2">CPLString::ifind()</a>.</p>

<p>Referenced by <a class="el" href="cpl__string_8h.html#ac45405998f4df728887be28a1a6d4b6e">CPLURLAddKVP()</a>.</p>

</div>
</div>
<a class="anchor" id="a49550245214ac079518c5fcd5084ecd0"></a><!-- doxytag: member="cpl_string.h::CPLURLGetValue" ref="a49550245214ac079518c5fcd5084ecd0" args="(const char *pszURL, const char *pszKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCPLString.html">CPLString</a> CPLURLGetValue </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszURL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszKey</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the value matching a key from a key=value pair in a URL.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszURL</em>&nbsp;</td><td>the URL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszKey</em>&nbsp;</td><td>the key to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the value of empty string if not found. </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.9.0 </dd></dl>

<p>References <a class="el" href="cpl__string_8h.html#a49550245214ac079518c5fcd5084ecd0">CPLURLGetValue()</a>, and <a class="el" href="classCPLString.html#a7d6295451382acec94098725445435f2">CPLString::ifind()</a>.</p>

<p>Referenced by <a class="el" href="cpl__string_8h.html#a49550245214ac079518c5fcd5084ecd0">CPLURLGetValue()</a>.</p>

</div>
</div>
<a class="anchor" id="ac1ffd0e5baf9729f09388a38c07f5835"></a><!-- doxytag: member="cpl_string.h::CSLCount" ref="ac1ffd0e5baf9729f09388a38c07f5835" args="(char **papszStrList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CSLCount </td>
          <td>(</td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszStrList</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return number of items in a string list.</p>
<p>Returns the number of items in a string list, not counting the terminating NULL. Passing in NULL is safe, and will result in a count of zero.</p>
<p>Lists are counted by iterating through them so long lists will take more time than short lists. Care should be taken to avoid using <a class="el" href="cpl__string_8h.html#ac1ffd0e5baf9729f09388a38c07f5835">CSLCount()</a> as an end condition for loops as it will result in O(n^2) behavior.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>papszStrList</em>&nbsp;</td><td>the string list to count.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of entries. </dd></dl>

</div>
</div>
<a class="anchor" id="a5a39b9c5896a273cc6f06c1d5be93238"></a><!-- doxytag: member="cpl_string.h::CSLDestroy" ref="a5a39b9c5896a273cc6f06c1d5be93238" args="(char **papszStrList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSLDestroy </td>
          <td>(</td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszStrList</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Free string list.</p>
<p>Frees the passed string list (null terminated array of strings). It is safe to pass NULL.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>papszStrList</em>&nbsp;</td><td>the list to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8b9c9ad6c5a416c91f1fca55d9a91701"></a><!-- doxytag: member="cpl_string.h::CSLDuplicate" ref="a8b9c9ad6c5a416c91f1fca55d9a91701" args="(char **papszStrList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char** CSLDuplicate </td>
          <td>(</td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszStrList</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clone a string list.</p>
<p>Efficiently allocates a copy of a string list. The returned list is owned by the caller and should be freed with <a class="el" href="cpl__string_8h.html#a5a39b9c5896a273cc6f06c1d5be93238">CSLDestroy()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>papszStrList</em>&nbsp;</td><td>the input string list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>newly allocated copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a0901440811294a6a0d6762b6e64107e3"></a><!-- doxytag: member="cpl_string.h::CSLFindName" ref="a0901440811294a6a0d6762b6e64107e3" args="(char **papszStrList, const char *pszName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CSLFindName </td>
          <td>(</td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszStrList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find StringList entry with given key name.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>papszStrList</em>&nbsp;</td><td>the string list to search. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszName</em>&nbsp;</td><td>the key value to look for (case insensitive).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>-1 on failure or the list index of the first occurance matching the given key. </dd></dl>

</div>
</div>
<a class="anchor" id="aadb00ff49c2d9dc32c043ca58fd9d8cd"></a><!-- doxytag: member="cpl_string.h::CSLFindString" ref="aadb00ff49c2d9dc32c043ca58fd9d8cd" args="(char **, const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CSLFindString </td>
          <td>(</td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszTarget</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find a string within a string list.</p>
<p>Returns the index of the entry in the string list that contains the target string. The string in the string list must be a full match for the target, but the search is case insensitive.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>papszList</em>&nbsp;</td><td>the string list to be searched. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszTarget</em>&nbsp;</td><td>the string to be searched for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the index of the string within the list or -1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ad7af0a270dc019a17bf1326da8e6a970"></a><!-- doxytag: member="cpl_string.h::CSLLoad" ref="ad7af0a270dc019a17bf1326da8e6a970" args="(const char *pszFname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char** CSLLoad </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszFname</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load a text file into a string list.</p>
<p>The VSI*L API is used, so <a class="el" href="cpl__vsi_8h.html#ad487ad46f2841815f331292051192d5f" title="Open file.">VSIFOpenL()</a> supported objects that aren't physical files can also be accessed. Files are returned as a string list, with one item in the string list per line. End of line markers are stripped (by <a class="el" href="cpl__conv_8h.html#af049d0b413b82ac770d33cc76f525825">CPLReadLineL()</a>).</p>
<p>If reading the file fails a <a class="el" href="cpl__error_8h.html#aad2b98dd58e4de706a245faddac90403">CPLError()</a> will be issued and NULL returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszFname</em>&nbsp;</td><td>the name of the file to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a string list with the files lines, now owned by caller. To be freed with <a class="el" href="cpl__string_8h.html#a5a39b9c5896a273cc6f06c1d5be93238">CSLDestroy()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a52852635691b8ca3390ab98d000b5e45"></a><!-- doxytag: member="cpl_string.h::CSLLoad2" ref="a52852635691b8ca3390ab98d000b5e45" args="(const char *pszFname, int nMaxLines, int nMaxCols, char **papszOptions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char** CSLLoad2 </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszFname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nMaxLines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nMaxCols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszOptions</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load a text file into a string list.</p>
<p>The VSI*L API is used, so <a class="el" href="cpl__vsi_8h.html#ad487ad46f2841815f331292051192d5f" title="Open file.">VSIFOpenL()</a> supported objects that aren't physical files can also be accessed. Files are returned as a string list, with one item in the string list per line. End of line markers are stripped (by <a class="el" href="cpl__conv_8h.html#af049d0b413b82ac770d33cc76f525825">CPLReadLineL()</a>).</p>
<p>If reading the file fails a <a class="el" href="cpl__error_8h.html#aad2b98dd58e4de706a245faddac90403">CPLError()</a> will be issued and NULL returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszFname</em>&nbsp;</td><td>the name of the file to read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nMaxLines</em>&nbsp;</td><td>maximum number of lines to read before stopping, or -1 for no limit. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nMaxCols</em>&nbsp;</td><td>maximum number of characters in a line before stopping, or -1 for no limit. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>papszOptions</em>&nbsp;</td><td>NULL-terminated array of options. Unused for now.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a string list with the files lines, now owned by caller. To be freed with <a class="el" href="cpl__string_8h.html#a5a39b9c5896a273cc6f06c1d5be93238">CSLDestroy()</a></dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.7.0 </dd></dl>

<p>References <a class="el" href="cpl__vsi_8h.html#a82fe6612261c1948eee388e75b7d6db7">VSIFCloseL()</a>, <a class="el" href="cpl__vsi_8h.html#ab72b69150d9dd7adb6e756196867a9b2">VSIFEofL()</a>, and <a class="el" href="cpl__vsi_8h.html#ad487ad46f2841815f331292051192d5f">VSIFOpenL()</a>.</p>

</div>
</div>
<a class="anchor" id="ad2766cf9f275a413c46ac4f7fa749be7"></a><!-- doxytag: member="cpl_string.h::CSLMerge" ref="ad2766cf9f275a413c46ac4f7fa749be7" args="(char **papszOrig, char **papszOverride)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char** CSLMerge </td>
          <td>(</td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszOrig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszOverride</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Merge two lists. </p>
<p>The two lists are merged, ensuring that if any keys appear in both that the value from the second (papszOverride) list take precidence.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>papszOrig</em>&nbsp;</td><td>the original list, being modified. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>papszOverride</em>&nbsp;</td><td>the list of items being merged in. This list is unaltered and remains owned by the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>updated list. </dd></dl>

</div>
</div>
<a class="anchor" id="aa1211d7957346bdb49bd40a80475615a"></a><!-- doxytag: member="cpl_string.h::CSLPartialFindString" ref="aa1211d7957346bdb49bd40a80475615a" args="(char **papszHaystack, const char *pszNeedle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CSLPartialFindString </td>
          <td>(</td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszHaystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszNeedle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find a substring within a string list.</p>
<p>Returns the index of the entry in the string list that contains the target string as a substring. The search is case sensitive (unlike <a class="el" href="cpl__string_8h.html#aadb00ff49c2d9dc32c043ca58fd9d8cd">CSLFindString()</a>).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>papszHaystack</em>&nbsp;</td><td>the string list to be searched. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszNeedle</em>&nbsp;</td><td>the substring to be searched for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the index of the string within the list or -1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a8dbce00a6e7fa4710613e3e4c963dd5d"></a><!-- doxytag: member="cpl_string.h::CSLSetNameValue" ref="a8dbce00a6e7fa4710613e3e4c963dd5d" args="(char **papszStrList, const char *pszName, const char *pszValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char** CSLSetNameValue </td>
          <td>(</td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign value to name in StringList.</p>
<p>Set the value for a given name in a StringList of "Name=Value" pairs ("Name:Value" pairs are also supported for backward compatibility with older stuff.)</p>
<p>If there is already a value for that name in the list then the value is changed, otherwise a new "Name=Value" pair is added.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>papszList</em>&nbsp;</td><td>the original list, the modified version is returned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszName</em>&nbsp;</td><td>the name to be assigned a value. This should be a well formed token (no spaces or very special characters). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszValue</em>&nbsp;</td><td>the value to assign to the name. This should not contain any newlines (CR or LF) but is otherwise pretty much unconstrained. If NULL any corresponding value will be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>modified stringlist. </dd></dl>

</div>
</div>
<a class="anchor" id="a97b38f55a35f3c1d66ba343692ab9ec0"></a><!-- doxytag: member="cpl_string.h::CSLSetNameValueSeparator" ref="a97b38f55a35f3c1d66ba343692ab9ec0" args="(char **papszStrList, const char *pszSeparator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSLSetNameValueSeparator </td>
          <td>(</td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszSeparator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replace the default separator (":" or "=") with the passed separator in the given name/value list.</p>
<p>Note that if a separator other than ":" or "=" is used, the resulting list will not be manipulatable by the CSL name/value functions any more.</p>
<p>The <a class="el" href="cpl__string_8h.html#a40ff577b83aca84a603414183e6903d3">CPLParseNameValue()</a> function is used to break the existing lines, and it also strips white space from around the existing delimiter, thus the old separator, and any white space will be replaced by the new separator. For formatting purposes it may be desireable to include some white space in the new separator. eg. ": " or " = ".</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>papszList</em>&nbsp;</td><td>the list to update. Component strings may be freed but the list array will remain at the same location.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszSeparator</em>&nbsp;</td><td>the new separator string to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ada798bb0fafd08c7908d0f3716f341b3"></a><!-- doxytag: member="cpl_string.h::CSLTestBoolean" ref="ada798bb0fafd08c7908d0f3716f341b3" args="(const char *pszValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CSLTestBoolean </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszValue</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Test what boolean value contained in the string.</p>
<p>If pszValue is "NO", "FALSE", "OFF" or "0" will be returned FALSE. Otherwise, TRUE will be returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszValue</em>&nbsp;</td><td>the string should be tested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE or FALSE. </dd></dl>

</div>
</div>
<a class="anchor" id="a36f1e4efb0da65e3d900d3a0ce8cbaab"></a><!-- doxytag: member="cpl_string.h::CSLTokenizeString2" ref="a36f1e4efb0da65e3d900d3a0ce8cbaab" args="(const char *pszString, const char *pszDelimeter, int nCSLTFlags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char** CSLTokenizeString2 </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszDelimiters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nCSLTFlags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Tokenize a string.</p>
<p>This function will split a string into tokens based on specified' delimeter(s) with a variety of options. The returned result is a string list that should be freed with <a class="el" href="cpl__string_8h.html#a5a39b9c5896a273cc6f06c1d5be93238">CSLDestroy()</a> when no longer needed.</p>
<p>The available parsing options are:</p>
<ul>
<li>CSLT_ALLOWEMPTYTOKENS: allow the return of empty tokens when two delimiters in a row occur with no other text between them. If not set, empty tokens will be discarded;</li>
<li>CSLT_STRIPLEADSPACES: strip leading space characters from the token (as reported by isspace());</li>
<li>CSLT_STRIPENDSPACES: strip ending space characters from the token (as reported by isspace());</li>
<li>CSLT_HONOURSTRINGS: double quotes can be used to hold values that should not be broken into multiple tokens;</li>
<li>CSLT_PRESERVEQUOTES: string quotes are carried into the tokens when this is set, otherwise they are removed;</li>
<li>CSLT_PRESERVEESCAPES: if set backslash escapes (for backslash itself, and for literal double quotes) will be preserved in the tokens, otherwise the backslashes will be removed in processing.</li>
</ul>
<p><b>Example:</b> </p>
<p>Parse a string into tokens based on various white space (space, newline, tab) and then print out results and cleanup. Quotes may be used to hold white space in tokens.</p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">char</span> **papszTokens;
    <span class="keywordtype">int</span> i;

    papszTokens = 
        CSLTokenizeString2( pszCommand, <span class="stringliteral">&quot; \t\n&quot;</span>, 
                            CSLT_HONOURSTRINGS | CSLT_ALLOWEMPTYTOKENS );

    <span class="keywordflow">for</span>( i = 0; papszTokens != NULL &amp;&amp; papszTokens[i] != NULL; i++ )
        printf( <span class="stringliteral">&quot;arg %d: &#39;%s&#39;&quot;</span>, papszTokens[i] );
    CSLDestroy( papszTokens );
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszString</em>&nbsp;</td><td>the string to be split into tokens. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszDelimiters</em>&nbsp;</td><td>one or more characters to be used as token delimeters. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nCSLTFlags</em>&nbsp;</td><td>an ORing of one or more of the CSLT_ flag values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a string list of tokens owned by the caller. </dd></dl>

<p>References <a class="el" href="classCPLStringList.html#afb284d82f71198fa175f6656cd8ca328">CPLStringList::AddString()</a>, <a class="el" href="classCPLStringList.html#a3d9b7a3005cbc15883200040622def0a">CPLStringList::Assign()</a>, <a class="el" href="classCPLStringList.html#ab6b0f51c08d8989a0966be64a1a596b9">CPLStringList::Count()</a>, and <a class="el" href="classCPLStringList.html#a4784adc3ae6ad4dbb479496baa90d293">CPLStringList::StealList()</a>.</p>

</div>
</div>
</div>
<hr>

Generated for GDAL by 
<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.7.1.
</body>
</html>

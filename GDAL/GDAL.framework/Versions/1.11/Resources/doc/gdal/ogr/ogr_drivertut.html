<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OGR: OGR Driver Implementation Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>OGR Driver Implementation Tutorial </h1>  </div>
</div>
<div class="contents">
<h2><a class="anchor" id="odt_overall"></a>
Overall Approach</h2>
<p>In general new formats are added to OGR by implementing format specific drivers with subclasses of <a class="el" href="classOGRSFDriver.html">OGRSFDriver</a>, <a class="el" href="classOGRDataSource.html">OGRDataSource</a> and <a class="el" href="classOGRLayer.html">OGRLayer</a>. The <a class="el" href="classOGRSFDriver.html">OGRSFDriver</a> subclass is registered with the <a class="el" href="classOGRSFDriverRegistrar.html">OGRSFDriverRegistrar</a> at runtime.</p>
<p>Before following this tutorial to implement an OGR driver, please review the <a href="ogr_arch.html">OGR Architecture</a> document carefully.</p>
<p>The tutorial will be based on implementing a simple ascii point format.</p>
<h2><a class="anchor" id="odt_toc"></a>
Contents</h2>
<ol>
<li>
<a class="el" href="ogr_drivertut.html#odt_driver_ro">Implementing OGRSFDriver</a> </li>
<li>
<a class="el" href="ogr_drivertut.html#odt_datasource_bro">Basic Read Only Data Source</a> </li>
<li>
<a class="el" href="ogr_drivertut.html#odt_layer_bro">Read Only Layer</a> </li>
</ol>
<h2><a class="anchor" id="odt_driver_ro"></a>
Implementing OGRSFDriver</h2>
<p>The format specific driver class is implemented as a subclass of <a class="el" href="classOGRSFDriver.html">OGRSFDriver</a>. One instance of the driver will normally be created, and registered with the OGRSFDriverRegistrar(). The instantiation of the driver is normally handled by a global C callable registration function, similar to the following placed in the same file as the driver class.</p>
<div class="fragment"><pre class="fragment">
void RegisterOGRSPF()

{
    OGRSFDriverRegistrar::GetRegistrar()-&gt;RegisterDriver( new OGRSPFDriver );
}
</pre></div><p>The driver class declaration generally looks something like this for a format with read or read and update access (the Open() method), creation support (the CreateDataSource() method), and the ability to delete a datasource (the DeleteDataSource() method).</p>
<div class="fragment"><pre class="fragment">
class OGRSPFDriver : public OGRSFDriver
{
  public:
                ~OGRSPFDriver();
                
    const char    *GetName();
    OGRDataSource *Open( const char *, int );
    OGRDataSource *CreateDataSource( const char *, char ** );
    OGRErr         DeleteDataSource( const char *pszName );
    int            TestCapability( const char * );
};
</pre></div><p>The constructor generally does nothing. The <a class="el" href="classOGRSFDriver.html#a0e7f90e5c390bccc9e708b75235a2735" title="Fetch name of driver (file format). This name should be relatively short (10-40 characters), and should reflect the underlying file format. For instance &quot;ESRI Shapefile&quot;.">OGRSFDriver::GetName()</a> method returns a static string with the name of the driver. This name is specified on the commandline when creating datasources so it is generally good to keep it short and without any special characters or spaces.</p>
<div class="fragment"><pre class="fragment">
OGRSPFDriver::~OGRSPFDriver()

{
}

const char *OGRSPFDriver::GetName()
{
    return "SPF";
}
</pre></div><p>The Open() method is called by <a class="el" href="classOGRSFDriverRegistrar.html#a5ee13e09d55d146f45bb5417fa524f54" title="Open a file / data source with one of the registered drivers.">OGRSFDriverRegistrar::Open()</a>, or from the C API <a class="el" href="ogr__api_8h.html#a2da3630231780d519543d1679c83e62f" title="Open a file / data source with one of the registered drivers.">OGROpen()</a>. The <a class="el" href="classOGRSFDriver.html#aee265c3b0a3d4fa3572020d255bb4564" title="Attempt to open file with this driver.">OGRSFDriver::Open()</a> method should quietly return NULL if the passed filename is not of the format supported by the driver. If it is the target format, then a new <a class="el" href="classOGRDataSource.html">OGRDataSource</a> object for the datasource should be returned.</p>
<p>It is common for the Open() method to be delegated to an Open() method on the actual format's <a class="el" href="classOGRDataSource.html">OGRDataSource</a> class.</p>
<div class="fragment"><pre class="fragment">
OGRDataSource *OGRSPFDriver::Open( const char * pszFilename, int bUpdate )
{
    OGRSPFDataSource   *poDS = new OGRSPFDataSource();

    if( !poDS-&gt;Open( pszFilename, bUpdate ) )
    {
        delete poDS;
	return NULL;
    }
    else
        return poDS;
}
</pre></div><p>In OGR the capabilities of drivers, datasources and layers are determined by calling TestCapability() on the various objects with names strings representing specific optional capabilities. For the driver the only two capabilities currently tested for are the ability to create datasources and to delete them. In our first pass as a read only SPF driver, these are both disabled. The default return value for unrecognised capabilities should always be FALSE, and the symbolic defines for capability names (defined in <a class="el" href="ogr__core_8h.html">ogr_core.h</a>) should be used instead of the literal strings to avoid typos.</p>
<div class="fragment"><pre class="fragment">
int OGRSPFDriver::TestCapability( const char * pszCap )

{
    if( EQUAL(pszCap,ODrCCreateDataSource) )
        return FALSE;
    else if( EQUAL(pszCap,ODrCDeleteDataSource) )
        return FALSE;
    else
        return FALSE;
}
</pre></div><p>Examples of the CreateDataSource() and DeleteDataSource() methods are left for the section on creation and update.</p>
<h2><a class="anchor" id="odt_datasource_bro"></a>
Basic Read Only Data Source</h2>
<p>We will start implementing a minimal read-only datasource. No attempt is made to optimize operations, and default implementations of many methods inherited from <a class="el" href="classOGRDataSource.html">OGRDataSource</a> are used.</p>
<p>The primary responsibility of the datasource is to manage the list of layers. In the case of the SPF format a datasource is a single file representing one layer so there is at most one layer. The "name" of a datasource should generally be the name passed to the Open() method.</p>
<p>The Open() method below is not overriding a base class method, but we have it to implement the open operation delegated by the driver class.</p>
<p>For this simple case we provide a stub TestCapability() that returns FALSE for all extended capabilities. The TestCapability() method is pure virtual, so it does need to be implemented.</p>
<div class="fragment"><pre class="fragment">
class OGRSPFDataSource : public OGRDataSource
{
    char                *pszName;
    
    OGRSPFLayer       **papoLayers;
    int                 nLayers;

  public:
                        OGRSPFDataSource();
                        ~OGRSPFDataSource();

    int                 Open( const char * pszFilename, int bUpdate );
    
    const char          *GetName() { return pszName; }

    int                 GetLayerCount() { return nLayers; }
    OGRLayer            *GetLayer( int );

    int                 TestCapability( const char * ) { return FALSE; }
};
</pre></div><p>The constructor is a simple initializer to a default state. The Open() will take care of actually attaching it to a file. The destructor is responsible for orderly cleanup of layers.</p>
<div class="fragment"><pre class="fragment">
OGRSPFDataSource::OGRSPFDataSource()

{
    papoLayers = NULL;
    nLayers = 0;

    pszName = NULL;
}

OGRSPFDataSource::~OGRSPFDataSource()

{
    for( int i = 0; i &lt; nLayers; i++ )
        delete papoLayers[i];
    CPLFree( papoLayers );

    CPLFree( pszName );
}
</pre></div><p>The Open() method is the most important one on the datasource, though in this particular instance it passes most of it's work off to the OGRSPFLayer constructor if it believes the file is of the desired format.</p>
<p>Note that Open() methods should try and determine that a file isn't of the identified format as efficiently as possible, since many drivers may be invoked with files of the wrong format before the correct driver is reached. In this particular Open() we just test the file extension but this is generally a poor way of identifying a file format. If available, checking "magic header values" or something similar is preferrable.</p>
<p>In the case of the SPF format, update in place is not supported, so we always fail if bUpdate is FALSE.</p>
<div class="fragment"><pre class="fragment">
int  OGRSPFDataSource::Open( const char *pszFilename, int bUpdate )

{
// -------------------------------------------------------------------- 
//      Does this appear to be an .spf file?                           
// --------------------------------------------------------------------
    if( !EQUAL( CPLGetExtension(pszFilename), "spf" ) )
        return FALSE;

    if( bUpdate )
    {
	CPLError( CE_Failure, CPLE_OpenFailed, 
                  "Update access not supported by the SPF driver." );
        return FALSE;
    }

// -------------------------------------------------------------------- 
//      Create a corresponding layer.
// --------------------------------------------------------------------
    nLayers = 1;
    papoLayers = (OGRSPFLayer **) CPLMalloc(sizeof(void*));
    
    papoLayers[0] = new OGRSPFLayer( pszFilename );

    pszName = CPLStrdup( pszFilename );

    return TRUE;
}
</pre></div><p>A GetLayer() method also needs to be implemented. Since the layer list is created in the Open() this is just a lookup with some safety testing.</p>
<div class="fragment"><pre class="fragment">
OGRLayer *OGRSPFDataSource::GetLayer( int iLayer )

{
    if( iLayer &lt; 0 || iLayer &gt;= nLayers )
        return NULL;
    else
        return papoLayers[iLayer];
}
</pre></div><h2><a class="anchor" id="odt_layer_bro"></a>
Read Only Layer</h2>
<p>The OGRSPFLayer is implements layer semantics for an .spf file. It provides access to a set of feature objects in a consistent coordinate system with a particular set of attribute columns. Our class definition looks like this:</p>
<div class="fragment"><pre class="fragment">
class OGRSPFLayer : public OGRLayer
{
    OGRFeatureDefn     *poFeatureDefn;

    FILE               *fp;

    int                 nNextFID;

  public:
    OGRSPFLayer( const char *pszFilename );
   ~OGRSPFLayer();

    void                ResetReading();
    OGRFeature *        GetNextFeature();

    OGRFeatureDefn *    GetLayerDefn() { return poFeatureDefn; }

    int                 TestCapability( const char * ) { return FALSE; }
};
</pre></div><p>The layer constructor is responsible for initialization. The most important initialization is setting up the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> for the layer. This defines the list of fields and their types, the geometry type and the coordinate system for the layer. In the SPF format the set of fields is fixed - a single string field and we have no coordinate system info to set.</p>
<p>Pay particular attention to the reference counting of the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a>. As OGRFeature's for this layer will also take a reference to this definition it is important that we also establish a reference on behalf of the layer itself.</p>
<div class="fragment"><pre class="fragment">
OGRSPFLayer::OGRSPFLayer( const char *pszFilename )

{
    nNextFID = 0;

    poFeatureDefn = new OGRFeatureDefn( CPLGetBasename( pszFilename ) );
    poFeatureDefn-&gt;Reference();
    poFeatureDefn-&gt;SetGeomType( wkbPoint );
   
    OGRFieldDefn oFieldTemplate( "Name", OFTString );

    poFeatureDefn-&gt;AddFieldDefn( &amp;oFieldTemplate );

    fp = VSIFOpenL( pszFilename, "r" );
    if( fp == NULL )
        return;
}
</pre></div><p>Note that the destructor uses Release() on the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a>. This will destroy the feature definition if the reference count drops to zero, but if the application is still holding onto a feature from this layer, then that feature will hold a reference to the feature definition and it will not be destroyed here (which is good!).</p>
<div class="fragment"><pre class="fragment">
OGRSPFLayer::~OGRSPFLayer()

{
    poFeatureDefn-&gt;Release();
    if( fp != NULL )
        VSIFCloseL( fp );
}
</pre></div><p>The GetNextFeature() method is usually the work horse of <a class="el" href="classOGRLayer.html">OGRLayer</a> implementations. It is responsible for reading the next feature according to the current spatial and attribute filters installed.</p>
<p>The while() loop is present to loop until we find a satisfactory feature. The first section of code is for parsing a single line of the SPF text file and establishing the x, y and name for the line.</p>
<div class="fragment"><pre class="fragment">
OGRFeature *OGRSPFLayer::GetNextFeature()

{
    // --------------------------------------------------------------------
    //	Loop till we find a feature matching our requirements.
    // --------------------------------------------------------------------
    while( TRUE )
    {
        const char *pszLine;
        const char *pszName;
    
        pszLine = CPLReadLineL( fp );

        // Are we at end of file (out of features)? 
        if( pszLine == NULL )
            return NULL;

        double dfX;
        double dfY;

        dfX = atof(pszLine);
    
        pszLine = strstr(pszLine,"|");
        if( pszLine == NULL )
            continue; // we should issue an error!
        else
            pszLine++;

        dfY = atof(pszLine);
    
        pszLine = strstr(pszLine,"|");
        if( pszLine == NULL )
            continue; // we should issue an error!
        else
            pszName = pszLine+1;

</pre></div><p>The next section turns the x, y and name into a feature. Also note that we assign a linearly incremented feature id. In our case we started at zero for the first feature, though some drivers start at 1.</p>
<div class="fragment"><pre class="fragment">
        OGRFeature *poFeature = new OGRFeature( poFeatureDefn );
        
        poFeature-&gt;SetGeometryDirectly( new OGRPoint( dfX, dfY ) );
        poFeature-&gt;SetField( 0, pszName );
        poFeature-&gt;SetFID( nNextFID++ );
</pre></div><p>Next we check if the feature matches our current attribute or spatial filter if we have them. Methods on the <a class="el" href="classOGRLayer.html">OGRLayer</a> base class support maintain filters in the <a class="el" href="classOGRLayer.html">OGRLayer</a> member fields m_poFilterGeom (spatial filter) and m_poAttrQuery (attribute filter) so we can just use these values here if they are non-NULL. The following test is essentially "stock" and done the same in all formats. Some formats also do some spatial filtering ahead of time using a spatial index.</p>
<p>If the feature meets our criteria we return it. Otherwise we destroy it, and return to the top of the loop to fetch another to try.</p>
<div class="fragment"><pre class="fragment">
        if( (m_poFilterGeom == NULL
             || FilterGeometry( poFeature-&gt;GetGeometryRef() ) )
            &amp;&amp; (m_poAttrQuery == NULL
                || m_poAttrQuery-&gt;Evaluate( poFeature )) )
            return poFeature;

        delete poFeature;
    }
}
</pre></div><p>While in the middle of reading a feature set from a layer, or at any other time the application can call ResetReading() which is intended to restart reading at the beginning of the feature set. We implement this by seeking back to the beginning of the file, and resetting our feature id counter.</p>
<div class="fragment"><pre class="fragment">
void OGRSPFLayer::ResetReading()

{
    VSIFSeekL( fp, 0, SEEK_SET );
    nNextFID = 0;
}
</pre></div><p>In this implementation we do not provide a custom implementation for the GetFeature() method. This means an attempt to read a particular feature by it's feature id will result in many calls to GetNextFeature() till the desired feature is found. However, in a sequential text format like spf there is little else we could do anyway.</p>
<p>There! We have completed a simple read-only feature file format driver. </p>
</div>
<hr>

Generated for GDAL by 
<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.7.1.
</body>
</html>

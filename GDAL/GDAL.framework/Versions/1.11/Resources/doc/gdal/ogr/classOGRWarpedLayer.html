<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OGR: OGRWarpedLayer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>OGRWarpedLayer Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="OGRWarpedLayer" --><!-- doxytag: inherits="OGRLayerDecorator" --><div class="dynheader">
Inheritance diagram for OGRWarpedLayer:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classOGRWarpedLayer.png" usemap="#OGRWarpedLayer_map" alt=""/>
  <map id="OGRWarpedLayer_map" name="OGRWarpedLayer_map">
<area href="classOGRLayerDecorator.html" alt="OGRLayerDecorator" shape="rect" coords="0,56,129,80"/>
<area href="classOGRLayer.html" alt="OGRLayer" shape="rect" coords="0,0,129,24"/>
</map>
</div>

<p><a href="classOGRWarpedLayer-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRWarpedLayer.html#a8f41d20ca38cfb431a54fecd4f1c858b">SetSpatialFilter</a> (<a class="el" href="classOGRGeometry.html">OGRGeometry</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a new spatial filter.  <a href="#a8f41d20ca38cfb431a54fecd4f1c858b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRWarpedLayer.html#a159b1aafced966dbbd35535d3ecc18ac">SetSpatialFilterRect</a> (double dfMinX, double dfMinY, double dfMaxX, double dfMaxY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a new rectangular spatial filter.  <a href="#a159b1aafced966dbbd35535d3ecc18ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRWarpedLayer.html#a50e1332a6d2bd495422e1ef83ca6a246">SetSpatialFilter</a> (int iGeomField, <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a new spatial filter.  <a href="#a50e1332a6d2bd495422e1ef83ca6a246"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRWarpedLayer.html#afc940600931d49fce93c0f770079aadd">SetSpatialFilterRect</a> (int iGeomField, double dfMinX, double dfMinY, double dfMaxX, double dfMaxY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a new rectangular spatial filter.  <a href="#afc940600931d49fce93c0f770079aadd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRFeature.html">OGRFeature</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRWarpedLayer.html#a7d55012a49484e77ef06246597736c09">GetNextFeature</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the next available feature from this layer.  <a href="#a7d55012a49484e77ef06246597736c09"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRFeature.html">OGRFeature</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRWarpedLayer.html#a12521ca826b27601a09f1882f5b7595c">GetFeature</a> (long nFID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch a feature by its identifier.  <a href="#a12521ca826b27601a09f1882f5b7595c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRWarpedLayer.html#a675128117d059eee968fcf9d42b68acd">SetFeature</a> (<a class="el" href="classOGRFeature.html">OGRFeature</a> *poFeature)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rewrite an existing feature.  <a href="#a675128117d059eee968fcf9d42b68acd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRWarpedLayer.html#ad1208b597aca9b8b5e90816dc2998ff8">CreateFeature</a> (<a class="el" href="classOGRFeature.html">OGRFeature</a> *poFeature)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create and write a new feature within a layer.  <a href="#ad1208b597aca9b8b5e90816dc2998ff8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRWarpedLayer.html#aba232ed7807f305b9ed4e56af9e370ec">GetLayerDefn</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the schema information for this layer.  <a href="#aba232ed7807f305b9ed4e56af9e370ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRWarpedLayer.html#a1bf0ab0345277bbf37fe0aba15582164">GetSpatialRef</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the spatial reference system for this layer.  <a href="#a1bf0ab0345277bbf37fe0aba15582164"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRWarpedLayer.html#a33fd195fa410c173fe4d04f65deddac0">GetFeatureCount</a> (int bForce=TRUE)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the feature count in this layer.  <a href="#a33fd195fa410c173fe4d04f65deddac0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRWarpedLayer.html#ad8e9852587d5a152d7459e8dc5eb86e5">GetExtent</a> (int iGeomField, <a class="el" href="classOGREnvelope.html">OGREnvelope</a> *psExtent, int bForce=TRUE)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the extent of this layer, on the specified geometry field.  <a href="#ad8e9852587d5a152d7459e8dc5eb86e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRWarpedLayer.html#aec43822af12dba6874618c493da11fd0">GetExtent</a> (<a class="el" href="classOGREnvelope.html">OGREnvelope</a> *psExtent, int bForce=TRUE)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the extent of this layer.  <a href="#aec43822af12dba6874618c493da11fd0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRWarpedLayer.html#a9f186b0f0898d1a4a0af9ada5dc319bd">TestCapability</a> (const char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this layer supported the named capability.  <a href="#a9f186b0f0898d1a4a0af9ada5dc319bd"></a><br/></td></tr>
</table>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ad1208b597aca9b8b5e90816dc2998ff8"></a><!-- doxytag: member="OGRWarpedLayer::CreateFeature" ref="ad1208b597aca9b8b5e90816dc2998ff8" args="(OGRFeature *poFeature)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRWarpedLayer::CreateFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRFeature.html">OGRFeature</a> *&nbsp;</td>
          <td class="paramname"> <em>poFeature</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create and write a new feature within a layer. </p>
<p>The passed feature is written to the layer as a new feature, rather than overwriting an existing one. If the feature has a feature id other than OGRNullFID, then the native implementation may use that as the feature id of the new feature, but not necessarily. Upon successful return the passed feature will have been updated with the new feature id.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a301d319111285a47fe6cda6e079214f8" title="Create and write a new feature within a layer.">OGR_L_CreateFeature()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poFeature</em>&nbsp;</td><td>the feature to write to disk.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE on success. </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRLayerDecorator.html#a096e5988e4b10966417a3753662c6171">OGRLayerDecorator</a>.</p>

<p>References <a class="el" href="classOGRLayer.html#aaa1e32016f481596a55e1d988a15a067">OGRLayer::CreateFeature()</a>.</p>

</div>
</div>
<a class="anchor" id="ad8e9852587d5a152d7459e8dc5eb86e5"></a><!-- doxytag: member="OGRWarpedLayer::GetExtent" ref="ad8e9852587d5a152d7459e8dc5eb86e5" args="(int iGeomField, OGREnvelope *psExtent, int bForce=TRUE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRWarpedLayer::GetExtent </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iGeomField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGREnvelope.html">OGREnvelope</a> *&nbsp;</td>
          <td class="paramname"> <em>psExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bForce</em> = <code>TRUE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch the extent of this layer, on the specified geometry field. </p>
<p>Returns the extent (MBR) of the data in the layer. If bForce is FALSE, and it would be expensive to establish the extent then OGRERR_FAILURE will be returned indicating that the extent isn't know. If bForce is TRUE then some implementations will actually scan the entire layer once to compute the MBR of all the features in the layer.</p>
<p>Depending on the drivers, the returned extent may or may not take the spatial filter into account. So it is safer to call <a class="el" href="classOGRWarpedLayer.html#ad8e9852587d5a152d7459e8dc5eb86e5" title="Fetch the extent of this layer, on the specified geometry field.">GetExtent()</a> without setting a spatial filter.</p>
<p>Layers without any geometry may return OGRERR_FAILURE just indicating that no meaningful extents could be collected.</p>
<p>Note that some implementations of this method may alter the read cursor of the layer.</p>
<p>Note to driver implementators: if you implement <a class="el" href="classOGRWarpedLayer.html#ad8e9852587d5a152d7459e8dc5eb86e5" title="Fetch the extent of this layer, on the specified geometry field.">GetExtent(int,OGREnvelope*,int)</a>, you must also implement <a class="el" href="classOGRWarpedLayer.html#aec43822af12dba6874618c493da11fd0" title="Fetch the extent of this layer.">GetExtent(OGREnvelope*, int)</a> to make it call GetExtent(0,OGREnvelope*,int).</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ac3dbfd4443c80dca0d93574f0c00d376" title="Fetch the extent of this layer, on the specified geometry field.">OGR_L_GetExtentEx()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iGeomField</em>&nbsp;</td><td>the index of the geometry field on which to compute the extent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>psExtent</em>&nbsp;</td><td>the structure in which the extent value will be returned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bForce</em>&nbsp;</td><td>Flag indicating whether the extent should be computed even if it is expensive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE on success, OGRERR_FAILURE if extent not known. </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRLayerDecorator.html#a6e3e29276855a7bd0d7f72c0c0dae38f">OGRLayerDecorator</a>.</p>

<p>References <a class="el" href="classOGRLayer.html#a3be658ddb5b33d1ed95c31286774bbd2">OGRLayer::GetExtent()</a>.</p>

<p>Referenced by <a class="el" href="classOGRWarpedLayer.html#aec43822af12dba6874618c493da11fd0">GetExtent()</a>.</p>

</div>
</div>
<a class="anchor" id="aec43822af12dba6874618c493da11fd0"></a><!-- doxytag: member="OGRWarpedLayer::GetExtent" ref="aec43822af12dba6874618c493da11fd0" args="(OGREnvelope *psExtent, int bForce=TRUE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRWarpedLayer::GetExtent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGREnvelope.html">OGREnvelope</a> *&nbsp;</td>
          <td class="paramname"> <em>psExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bForce</em> = <code>TRUE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch the extent of this layer. </p>
<p>Returns the extent (MBR) of the data in the layer. If bForce is FALSE, and it would be expensive to establish the extent then OGRERR_FAILURE will be returned indicating that the extent isn't know. If bForce is TRUE then some implementations will actually scan the entire layer once to compute the MBR of all the features in the layer.</p>
<p>Depending on the drivers, the returned extent may or may not take the spatial filter into account. So it is safer to call <a class="el" href="classOGRWarpedLayer.html#ad8e9852587d5a152d7459e8dc5eb86e5" title="Fetch the extent of this layer, on the specified geometry field.">GetExtent()</a> without setting a spatial filter.</p>
<p>Layers without any geometry may return OGRERR_FAILURE just indicating that no meaningful extents could be collected.</p>
<p>Note that some implementations of this method may alter the read cursor of the layer.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#aa6c495581900c8301dff91d8cd3ee12f" title="Fetch the extent of this layer.">OGR_L_GetExtent()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psExtent</em>&nbsp;</td><td>the structure in which the extent value will be returned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bForce</em>&nbsp;</td><td>Flag indicating whether the extent should be computed even if it is expensive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE on success, OGRERR_FAILURE if extent not known. </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRLayerDecorator.html#a69c5f6f2aea9cace5d50ef26b34447ad">OGRLayerDecorator</a>.</p>

<p>References <a class="el" href="classOGRWarpedLayer.html#ad8e9852587d5a152d7459e8dc5eb86e5">GetExtent()</a>.</p>

</div>
</div>
<a class="anchor" id="a12521ca826b27601a09f1882f5b7595c"></a><!-- doxytag: member="OGRWarpedLayer::GetFeature" ref="a12521ca826b27601a09f1882f5b7595c" args="(long nFID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRFeature.html">OGRFeature</a> * OGRWarpedLayer::GetFeature </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nFID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch a feature by its identifier. </p>
<p>This function will attempt to read the identified feature. The nFID value cannot be OGRNullFID. Success or failure of this operation is unaffected by the spatial or attribute filters (and specialized implementations in drivers should make sure that they do not take into account spatial or attribute filters).</p>
<p>If this method returns a non-NULL feature, it is guaranteed that its feature id (<a class="el" href="classOGRFeature.html#a23506b436ea8e88e65aaa6b57bbaa326" title="Get feature identifier.">OGRFeature::GetFID()</a>) will be the same as nFID.</p>
<p>Use OGRLayer::TestCapability(OLCRandomRead) to establish if this layer supports efficient random access reading via <a class="el" href="classOGRWarpedLayer.html#a12521ca826b27601a09f1882f5b7595c" title="Fetch a feature by its identifier.">GetFeature()</a>; however, the call should always work if the feature exists as a fallback implementation just scans all the features in the layer looking for the desired feature.</p>
<p>Sequential reads (with <a class="el" href="classOGRWarpedLayer.html#a7d55012a49484e77ef06246597736c09" title="Fetch the next available feature from this layer.">GetNextFeature()</a>) are generally considered interrupted by a <a class="el" href="classOGRWarpedLayer.html#a12521ca826b27601a09f1882f5b7595c" title="Fetch a feature by its identifier.">GetFeature()</a> call.</p>
<p>The returned feature should be free with <a class="el" href="classOGRFeature.html#a5d2602d11f21567119da0ca6b6c5ad45" title="Destroy feature.">OGRFeature::DestroyFeature()</a>.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a7c628dce8939904154b50365306b06f9" title="Fetch a feature by its identifier.">OGR_L_GetFeature()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nFID</em>&nbsp;</td><td>the feature id of the feature to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a feature now owned by the caller, or NULL on failure. </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRLayerDecorator.html#a008d916daf97c3f189160e0f7bff14d5">OGRLayerDecorator</a>.</p>

<p>References <a class="el" href="classOGRLayer.html#acb7625383f161e5a04aeea2173dce411">OGRLayer::GetFeature()</a>.</p>

</div>
</div>
<a class="anchor" id="a33fd195fa410c173fe4d04f65deddac0"></a><!-- doxytag: member="OGRWarpedLayer::GetFeatureCount" ref="a33fd195fa410c173fe4d04f65deddac0" args="(int bForce=TRUE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRWarpedLayer::GetFeatureCount </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bForce</em> = <code>TRUE</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch the feature count in this layer. </p>
<p>Returns the number of features in the layer. For dynamic databases the count may not be exact. If bForce is FALSE, and it would be expensive to establish the feature count a value of -1 may be returned indicating that the count isn't know. If bForce is TRUE some implementations will actually scan the entire layer once to count objects.</p>
<p>The returned count takes the spatial filter into account.</p>
<p>Note that some implementations of this method may alter the read cursor of the layer.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#abfbba8f45edd5dc44ced91f9228f9124" title="Fetch the feature count in this layer.">OGR_L_GetFeatureCount()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bForce</em>&nbsp;</td><td>Flag indicating whether the count should be computed even if it is expensive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>feature count, -1 if count not known. </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRLayerDecorator.html#aef9e1920c4733164e5ba053ca08cb8cb">OGRLayerDecorator</a>.</p>

<p>References <a class="el" href="classOGRLayer.html#a74c796d4ce712e9a78df6042eeb8a91a">OGRLayer::GetFeatureCount()</a>.</p>

</div>
</div>
<a class="anchor" id="aba232ed7807f305b9ed4e56af9e370ec"></a><!-- doxytag: member="OGRWarpedLayer::GetLayerDefn" ref="aba232ed7807f305b9ed4e56af9e370ec" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> * OGRWarpedLayer::GetLayerDefn </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch the schema information for this layer. </p>
<p>The returned <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> is owned by the <a class="el" href="classOGRLayer.html">OGRLayer</a>, and should not be modified or freed by the application. It encapsulates the attribute schema of the features of the layer.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a7b67ea4ab5892c6720460dc7f66eca2d" title="Fetch the schema information for this layer.">OGR_L_GetLayerDefn()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>feature definition. </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRLayerDecorator.html#a6cb57d19416c9eb4d9c1615282b498d1">OGRLayerDecorator</a>.</p>

<p>References <a class="el" href="classOGRFeatureDefn.html#adbe115a21fb8d247f452ba9d7f00a400">OGRFeatureDefn::Clone()</a>, <a class="el" href="classOGRFeatureDefn.html#aa4a41bcd09868d325d214c28e17717eb">OGRFeatureDefn::GetGeomFieldCount()</a>, <a class="el" href="classOGRFeatureDefn.html#acacca3de3718ae525565e5130b5474dc">OGRFeatureDefn::GetGeomFieldDefn()</a>, <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf">OGRLayer::GetLayerDefn()</a>, <a class="el" href="classOGRFeatureDefn.html#a2c58c6238242dff3d472faf5e3803922">OGRFeatureDefn::Reference()</a>, and <a class="el" href="classOGRGeomFieldDefn.html#aeae0b00cc5a55b49aa51262d0a736bae">OGRGeomFieldDefn::SetSpatialRef()</a>.</p>

<p>Referenced by <a class="el" href="classOGRWarpedLayer.html#a50e1332a6d2bd495422e1ef83ca6a246">SetSpatialFilter()</a>.</p>

</div>
</div>
<a class="anchor" id="a7d55012a49484e77ef06246597736c09"></a><!-- doxytag: member="OGRWarpedLayer::GetNextFeature" ref="a7d55012a49484e77ef06246597736c09" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRFeature.html">OGRFeature</a> * OGRWarpedLayer::GetNextFeature </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch the next available feature from this layer. </p>
<p>The returned feature becomes the responsiblity of the caller to delete with <a class="el" href="classOGRFeature.html#a5d2602d11f21567119da0ca6b6c5ad45" title="Destroy feature.">OGRFeature::DestroyFeature()</a>. It is critical that all features associated with an <a class="el" href="classOGRLayer.html">OGRLayer</a> (more specifically an <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a>) be deleted before that layer/datasource is deleted.</p>
<p>Only features matching the current spatial filter (set with <a class="el" href="classOGRWarpedLayer.html#a8f41d20ca38cfb431a54fecd4f1c858b" title="Set a new spatial filter.">SetSpatialFilter()</a>) will be returned.</p>
<p>This method implements sequential access to the features of a layer. The <a class="el" href="classOGRLayerDecorator.html#aa430e840e443235b9aa72e1baac86b18" title="Reset feature reading to start on the first feature.">ResetReading()</a> method can be used to start at the beginning again.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a6708c067521ab7b7f9c4ec0ebe221b5b" title="Fetch the next available feature from this layer.">OGR_L_GetNextFeature()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a feature, or NULL if no more features are available. </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRLayerDecorator.html#a5d1edbecca464827511bd7a34b862529">OGRLayerDecorator</a>.</p>

<p>References <a class="el" href="classOGRFeature.html#ae54d999d4649730d5c7b37de731e4f69">OGRFeature::GetGeomFieldRef()</a>, and <a class="el" href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6">OGRLayer::GetNextFeature()</a>.</p>

</div>
</div>
<a class="anchor" id="a1bf0ab0345277bbf37fe0aba15582164"></a><!-- doxytag: member="OGRWarpedLayer::GetSpatialRef" ref="a1bf0ab0345277bbf37fe0aba15582164" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> * OGRWarpedLayer::GetSpatialRef </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch the spatial reference system for this layer. </p>
<p>The returned object is owned by the <a class="el" href="classOGRLayer.html">OGRLayer</a> and should not be modified or freed by the application.</p>
<p>Starting with OGR 1.11, several geometry fields can be associated to a feature definition. Each geometry field can have its own spatial reference system, which is returned by <a class="el" href="classOGRGeomFieldDefn.html#ae043691f36413950ea2ec0c3495ac959" title="Fetch spatial reference system of this field.">OGRGeomFieldDefn::GetSpatialRef()</a>. <a class="el" href="classOGRLayer.html#a75c06b4993f8eb76b569f37365cd19ab" title="Fetch the spatial reference system for this layer.">OGRLayer::GetSpatialRef()</a> is equivalent to <a class="el" href="classOGRWarpedLayer.html#aba232ed7807f305b9ed4e56af9e370ec" title="Fetch the schema information for this layer.">GetLayerDefn()</a>-&gt;GetGeomFieldDefn(0)-&gt;<a class="el" href="classOGRWarpedLayer.html#a1bf0ab0345277bbf37fe0aba15582164" title="Fetch the spatial reference system for this layer.">GetSpatialRef()</a></p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a8b2a10085f410aa84172eba413408c39" title="Fetch the spatial reference system for this layer.">OGR_L_GetSpatialRef()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>spatial reference, or NULL if there isn't one. </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRLayerDecorator.html#ac9a72ec894519baa3b3e709713cb665f">OGRLayerDecorator</a>.</p>

</div>
</div>
<a class="anchor" id="a675128117d059eee968fcf9d42b68acd"></a><!-- doxytag: member="OGRWarpedLayer::SetFeature" ref="a675128117d059eee968fcf9d42b68acd" args="(OGRFeature *poFeature)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRWarpedLayer::SetFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRFeature.html">OGRFeature</a> *&nbsp;</td>
          <td class="paramname"> <em>poFeature</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rewrite an existing feature. </p>
<p>This method will write a feature to the layer, based on the feature id within the <a class="el" href="classOGRFeature.html">OGRFeature</a>.</p>
<p>Use OGRLayer::TestCapability(OLCRandomWrite) to establish if this layer supports random access writing via <a class="el" href="classOGRWarpedLayer.html#a675128117d059eee968fcf9d42b68acd" title="Rewrite an existing feature.">SetFeature()</a>.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a5b380520d0999422987f06b6e31b9b00" title="Rewrite an existing feature.">OGR_L_SetFeature()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poFeature</em>&nbsp;</td><td>the feature to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE if the operation works, otherwise an appropriate error code. </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRLayerDecorator.html#af42a6e262dd2c788d77643a7388564ca">OGRLayerDecorator</a>.</p>

<p>References <a class="el" href="classOGRLayer.html#a681139bfd585b74d7218e51a32144283">OGRLayer::SetFeature()</a>.</p>

</div>
</div>
<a class="anchor" id="a8f41d20ca38cfb431a54fecd4f1c858b"></a><!-- doxytag: member="OGRWarpedLayer::SetSpatialFilter" ref="a8f41d20ca38cfb431a54fecd4f1c858b" args="(OGRGeometry *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRWarpedLayer::SetSpatialFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td>
          <td class="paramname"> <em>poFilter</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a new spatial filter. </p>
<p>This method set the geometry to be used as a spatial filter when fetching features via the <a class="el" href="classOGRWarpedLayer.html#a7d55012a49484e77ef06246597736c09" title="Fetch the next available feature from this layer.">GetNextFeature()</a> method. Only features that geometrically intersect the filter geometry will be returned.</p>
<p>Currently this test is may be inaccurately implemented, but it is guaranteed that all features who's envelope (as returned by <a class="el" href="classOGRGeometry.html#aa3d42b06ae6f7bbef6d1a2886da8d398" title="Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure...">OGRGeometry::getEnvelope()</a>) overlaps the envelope of the spatial filter will be returned. This can result in more shapes being returned that should strictly be the case.</p>
<p>This method makes an internal copy of the passed geometry. The passed geometry remains the responsibility of the caller, and may be safely destroyed.</p>
<p>For the time being the passed filter geometry should be in the same SRS as the layer (as returned by <a class="el" href="classOGRLayer.html#a75c06b4993f8eb76b569f37365cd19ab" title="Fetch the spatial reference system for this layer.">OGRLayer::GetSpatialRef()</a>). In the future this may be generalized.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a678d1735bc82533614ac005691d1138c" title="Set a new spatial filter.">OGR_L_SetSpatialFilter()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poFilter</em>&nbsp;</td><td>the geometry to use as a filtering region. NULL may be passed indicating that the current spatial filter should be cleared, but no new one instituted. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classOGRLayerDecorator.html#ab113a978272fe2eb060cafa8bf13f8b9">OGRLayerDecorator</a>.</p>

</div>
</div>
<a class="anchor" id="a50e1332a6d2bd495422e1ef83ca6a246"></a><!-- doxytag: member="OGRWarpedLayer::SetSpatialFilter" ref="a50e1332a6d2bd495422e1ef83ca6a246" args="(int iGeomField, OGRGeometry *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRWarpedLayer::SetSpatialFilter </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iGeomField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td>
          <td class="paramname"> <em>poFilter</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a new spatial filter. </p>
<p>This method set the geometry to be used as a spatial filter when fetching features via the <a class="el" href="classOGRWarpedLayer.html#a7d55012a49484e77ef06246597736c09" title="Fetch the next available feature from this layer.">GetNextFeature()</a> method. Only features that geometrically intersect the filter geometry will be returned.</p>
<p>Currently this test is may be inaccurately implemented, but it is guaranteed that all features who's envelope (as returned by <a class="el" href="classOGRGeometry.html#aa3d42b06ae6f7bbef6d1a2886da8d398" title="Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure...">OGRGeometry::getEnvelope()</a>) overlaps the envelope of the spatial filter will be returned. This can result in more shapes being returned that should strictly be the case.</p>
<p>This method makes an internal copy of the passed geometry. The passed geometry remains the responsibility of the caller, and may be safely destroyed.</p>
<p>For the time being the passed filter geometry should be in the same SRS as the geometry field definition it corresponds to (as returned by <a class="el" href="classOGRWarpedLayer.html#aba232ed7807f305b9ed4e56af9e370ec" title="Fetch the schema information for this layer.">GetLayerDefn()</a>-&gt;GetGeomFieldDefn(iGeomField)-&gt;<a class="el" href="classOGRWarpedLayer.html#a1bf0ab0345277bbf37fe0aba15582164" title="Fetch the spatial reference system for this layer.">GetSpatialRef()</a>). In the future this may be generalized.</p>
<p>Note that only the last spatial filter set is applied, even if several successive calls are done with different iGeomField values.</p>
<p>Note to driver implementators: if you implement <a class="el" href="classOGRWarpedLayer.html#a50e1332a6d2bd495422e1ef83ca6a246" title="Set a new spatial filter.">SetSpatialFilter(int,OGRGeometry*)</a>, you must also implement <a class="el" href="classOGRWarpedLayer.html#a8f41d20ca38cfb431a54fecd4f1c858b" title="Set a new spatial filter.">SetSpatialFilter(OGRGeometry*)</a> to make it call SetSpatialFilter(0,OGRGeometry*).</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a00c8a1a968542d389f86ed1b4edd5823" title="Set a new spatial filter.">OGR_L_SetSpatialFilterEx()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iGeomField</em>&nbsp;</td><td>index of the geometry field on which the spatial filter operates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>poFilter</em>&nbsp;</td><td>the geometry to use as a filtering region. NULL may be passed indicating that the current spatial filter should be cleared, but no new one instituted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.11 </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRLayerDecorator.html#ab5f573a61c192099ced0e83825a36aef">OGRLayerDecorator</a>.</p>

<p>References <a class="el" href="classOGRGeometry.html#aa3d42b06ae6f7bbef6d1a2886da8d398">OGRGeometry::getEnvelope()</a>, <a class="el" href="classOGRWarpedLayer.html#aba232ed7807f305b9ed4e56af9e370ec">GetLayerDefn()</a>, <a class="el" href="classOGRLayerDecorator.html#aa430e840e443235b9aa72e1baac86b18">OGRLayerDecorator::ResetReading()</a>, <a class="el" href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169">OGRLayer::SetSpatialFilter()</a>, and <a class="el" href="classOGRLayer.html#acd16bcdb3e8f720003fb24cd68f25460">OGRLayer::SetSpatialFilterRect()</a>.</p>

</div>
</div>
<a class="anchor" id="afc940600931d49fce93c0f770079aadd"></a><!-- doxytag: member="OGRWarpedLayer::SetSpatialFilterRect" ref="afc940600931d49fce93c0f770079aadd" args="(int iGeomField, double dfMinX, double dfMinY, double dfMaxX, double dfMaxY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRWarpedLayer::SetSpatialFilterRect </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iGeomField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfMinX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfMinY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfMaxX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfMaxY</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a new rectangular spatial filter. </p>
<p>This method set rectangle to be used as a spatial filter when fetching features via the <a class="el" href="classOGRWarpedLayer.html#a7d55012a49484e77ef06246597736c09" title="Fetch the next available feature from this layer.">GetNextFeature()</a> method. Only features that geometrically intersect the given rectangle will be returned.</p>
<p>The x/y values should be in the same coordinate system as as the geometry field definition it corresponds to (as returned by <a class="el" href="classOGRWarpedLayer.html#aba232ed7807f305b9ed4e56af9e370ec" title="Fetch the schema information for this layer.">GetLayerDefn()</a>-&gt;GetGeomFieldDefn(iGeomField)-&gt;<a class="el" href="classOGRWarpedLayer.html#a1bf0ab0345277bbf37fe0aba15582164" title="Fetch the spatial reference system for this layer.">GetSpatialRef()</a>). Internally this method is normally implemented as creating a 5 vertex closed rectangular polygon and passing it to <a class="el" href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169" title="Set a new spatial filter.">OGRLayer::SetSpatialFilter()</a>. It exists as a convenience.</p>
<p>The only way to clear a spatial filter set with this method is to call OGRLayer::SetSpatialFilter(NULL).</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a489241dfe65d6e089809d3258c4f79f5" title="Set a new rectangular spatial filter.">OGR_L_SetSpatialFilterRectEx()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iGeomField</em>&nbsp;</td><td>index of the geometry field on which the spatial filter operates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfMinX</em>&nbsp;</td><td>the minimum X coordinate for the rectangular region. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfMinY</em>&nbsp;</td><td>the minimum Y coordinate for the rectangular region. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfMaxX</em>&nbsp;</td><td>the maximum X coordinate for the rectangular region. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfMaxY</em>&nbsp;</td><td>the maximum Y coordinate for the rectangular region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.11 </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRLayerDecorator.html#a52231526e17e03d1849a59f1231d5036">OGRLayerDecorator</a>.</p>

<p>References <a class="el" href="classOGRWarpedLayer.html#a159b1aafced966dbbd35535d3ecc18ac">SetSpatialFilterRect()</a>.</p>

</div>
</div>
<a class="anchor" id="a159b1aafced966dbbd35535d3ecc18ac"></a><!-- doxytag: member="OGRWarpedLayer::SetSpatialFilterRect" ref="a159b1aafced966dbbd35535d3ecc18ac" args="(double dfMinX, double dfMinY, double dfMaxX, double dfMaxY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRWarpedLayer::SetSpatialFilterRect </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfMinX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfMinY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfMaxX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfMaxY</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a new rectangular spatial filter. </p>
<p>This method set rectangle to be used as a spatial filter when fetching features via the <a class="el" href="classOGRWarpedLayer.html#a7d55012a49484e77ef06246597736c09" title="Fetch the next available feature from this layer.">GetNextFeature()</a> method. Only features that geometrically intersect the given rectangle will be returned.</p>
<p>The x/y values should be in the same coordinate system as the layer as a whole (as returned by <a class="el" href="classOGRLayer.html#a75c06b4993f8eb76b569f37365cd19ab" title="Fetch the spatial reference system for this layer.">OGRLayer::GetSpatialRef()</a>). Internally this method is normally implemented as creating a 5 vertex closed rectangular polygon and passing it to <a class="el" href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169" title="Set a new spatial filter.">OGRLayer::SetSpatialFilter()</a>. It exists as a convenience.</p>
<p>The only way to clear a spatial filter set with this method is to call OGRLayer::SetSpatialFilter(NULL).</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a5cba569e0779a02a95327f041d9f7a13" title="Set a new rectangular spatial filter.">OGR_L_SetSpatialFilterRect()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dfMinX</em>&nbsp;</td><td>the minimum X coordinate for the rectangular region. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfMinY</em>&nbsp;</td><td>the minimum Y coordinate for the rectangular region. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfMaxX</em>&nbsp;</td><td>the maximum X coordinate for the rectangular region. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfMaxY</em>&nbsp;</td><td>the maximum Y coordinate for the rectangular region. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classOGRLayerDecorator.html#a5182e0e702fb3598bfcd556901c2191e">OGRLayerDecorator</a>.</p>

<p>Referenced by <a class="el" href="classOGRWarpedLayer.html#afc940600931d49fce93c0f770079aadd">SetSpatialFilterRect()</a>.</p>

</div>
</div>
<a class="anchor" id="a9f186b0f0898d1a4a0af9ada5dc319bd"></a><!-- doxytag: member="OGRWarpedLayer::TestCapability" ref="a9f186b0f0898d1a4a0af9ada5dc319bd" args="(const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRWarpedLayer::TestCapability </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszCap</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if this layer supported the named capability. </p>
<p>The capability codes that can be tested are represented as strings, but #defined constants exists to ensure correct spelling. Specific layer types may implement class specific capabilities, but this can't generally be discovered by the caller. </p>
<ul>
<li>
<p class="startli"><b>OLCRandomRead</b> / "RandomRead": TRUE if the <a class="el" href="classOGRWarpedLayer.html#a12521ca826b27601a09f1882f5b7595c" title="Fetch a feature by its identifier.">GetFeature()</a> method is implemented in an optimized way for this layer, as opposed to the default implementation using <a class="el" href="classOGRLayerDecorator.html#aa430e840e443235b9aa72e1baac86b18" title="Reset feature reading to start on the first feature.">ResetReading()</a> and <a class="el" href="classOGRWarpedLayer.html#a7d55012a49484e77ef06246597736c09" title="Fetch the next available feature from this layer.">GetNextFeature()</a> to find the requested feature id.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCSequentialWrite</b> / "SequentialWrite": TRUE if the <a class="el" href="classOGRWarpedLayer.html#ad1208b597aca9b8b5e90816dc2998ff8" title="Create and write a new feature within a layer.">CreateFeature()</a> method works for this layer. Note this means that this particular layer is writable. The same <a class="el" href="classOGRLayer.html">OGRLayer</a> class may returned FALSE for other layer instances that are effectively read-only.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCRandomWrite</b> / "RandomWrite": TRUE if the <a class="el" href="classOGRWarpedLayer.html#a675128117d059eee968fcf9d42b68acd" title="Rewrite an existing feature.">SetFeature()</a> method is operational on this layer. Note this means that this particular layer is writable. The same <a class="el" href="classOGRLayer.html">OGRLayer</a> class may returned FALSE for other layer instances that are effectively read-only.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCFastSpatialFilter</b> / "FastSpatialFilter": TRUE if this layer implements spatial filtering efficiently. Layers that effectively read all features, and test them with the <a class="el" href="classOGRFeature.html">OGRFeature</a> intersection methods should return FALSE. This can be used as a clue by the application whether it should build and maintain its own spatial index for features in this layer.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCFastFeatureCount</b> / "FastFeatureCount": TRUE if this layer can return a feature count (via <a class="el" href="classOGRWarpedLayer.html#a33fd195fa410c173fe4d04f65deddac0" title="Fetch the feature count in this layer.">GetFeatureCount()</a>) efficiently ... ie. without counting the features. In some cases this will return TRUE until a spatial filter is installed after which it will return FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCFastGetExtent</b> / "FastGetExtent": TRUE if this layer can return its data extent (via <a class="el" href="classOGRWarpedLayer.html#ad8e9852587d5a152d7459e8dc5eb86e5" title="Fetch the extent of this layer, on the specified geometry field.">GetExtent()</a>) efficiently ... ie. without scanning all the features. In some cases this will return TRUE until a spatial filter is installed after which it will return FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCFastSetNextByIndex</b> / "FastSetNextByIndex": TRUE if this layer can perform the <a class="el" href="classOGRLayerDecorator.html#afdecea758d3bcc6f4b251a90b59138c3" title="Move read cursor to the nIndex&#39;th feature in the current resultset.">SetNextByIndex()</a> call efficiently, otherwise FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCCreateField</b> / "CreateField": TRUE if this layer can create new fields on the current layer using <a class="el" href="classOGRLayerDecorator.html#a8ebcd0484d1c1415876986e3eef5ffeb" title="Create a new field on a layer.">CreateField()</a>, otherwise FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCCreateGeomField</b> / "CreateGeomField": (GDAL &gt;= 1.11) TRUE if this layer can create new geometry fields on the current layer using <a class="el" href="classOGRLayer.html#af3c68cad279ad80a476c6fb307cf5e48" title="Create a new geometry field on a layer.">CreateGeomField()</a>, otherwise FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCDeleteField</b> / "DeleteField": TRUE if this layer can delete existing fields on the current layer using <a class="el" href="classOGRLayerDecorator.html#a588e4099ae87e9afd94d014a6964aecf" title="Delete an existing field on a layer.">DeleteField()</a>, otherwise FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCReorderFields</b> / "ReorderFields": TRUE if this layer can reorder existing fields on the current layer using <a class="el" href="classOGRLayer.html#ab4c02b991bfa78552eeb0cbcdcf1aed8" title="Reorder an existing field on a layer.">ReorderField()</a> or <a class="el" href="classOGRLayerDecorator.html#aca079c71a7cda466c46203d1cecdac45" title="Reorder all the fields of a layer.">ReorderFields()</a>, otherwise FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCAlterFieldDefn</b> / "AlterFieldDefn": TRUE if this layer can alter the definition of an existing field on the current layer using <a class="el" href="classOGRLayerDecorator.html#a9ede09c21d142c0fe9725b422b833f3f" title="Alter the definition of an existing field on a layer.">AlterFieldDefn()</a>, otherwise FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCDeleteFeature</b> / "DeleteFeature": TRUE if the <a class="el" href="classOGRLayerDecorator.html#ae39211b0650811eb8353d4d9bc69dea2" title="Delete feature from layer.">DeleteFeature()</a> method is supported on this layer, otherwise FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCStringsAsUTF8</b> / "StringsAsUTF8": TRUE if values of OFTString fields are assured to be in UTF-8 format. If FALSE the encoding of fields is uncertain, though it might still be UTF-8.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCTransactions</b> / "Transactions": TRUE if the StartTransaction(), CommitTransaction() and RollbackTransaction() methods work in a meaningful way, otherwise FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCIgnoreFields</b> / "IgnoreFields": TRUE if fields, geometry and style will be omitted when fetching features as set by <a class="el" href="classOGRLayerDecorator.html#adc1b3ec7fe99335be403646123636800" title="Set which fields can be omitted when retrieving features from the layer.">SetIgnoredFields()</a> method.</p>
<p></p>
<p></p>
<p class="endli"></p>
</li>
</ul>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a480adc8b839b04597f49583371d366fd" title="Test if this layer supported the named capability.">OGR_L_TestCapability()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszCap</em>&nbsp;</td><td>the name of the capability to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the layer has the requested capability, or FALSE otherwise. OGRLayers will return FALSE for any unrecognised capabilities.</dd></dl>

<p>Reimplemented from <a class="el" href="classOGRLayerDecorator.html#a6dfcc85af021e5e4095b520692761226">OGRLayerDecorator</a>.</p>

<p>References <a class="el" href="classOGRLayer.html#aeedbda1a62f9b89b8e5f24332cf22286">OGRLayer::TestCapability()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="ogrwarpedlayer_8h_source.html">ogrwarpedlayer.h</a></li>
<li>ogrwarpedlayer.cpp</li>
</ul>
</div>
<hr>

Generated for GDAL by 
<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.7.1.
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OGR: SQLite SQL dialect</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>SQLite SQL dialect </h1>  </div>
</div>
<div class="contents">
<p>Since GDAL/OGR 1.10, the SQLite "dialect" can be used as an alternate SQL dialect to the <b><a href="ogr_sql.html">OGR SQL dialect</a></b>. This assumes that GDAL/OGR is built with support for SQLite (&gt;= 3.6), and preferably with <a href="http://www.gaia-gis.it/spatialite/">Spatialite</a> support too to benefit from spatial functions.</p>
<p>The SQLite dialect may be used with any OGR datasource, like the OGR SQL dialect. It is available through the <a class="el" href="classOGRDataSource.html#aa6acc228db6513784a56ce12334a8c33" title="Execute an SQL statement against the data store.">OGRDataSource::ExecuteSQL()</a> method by specifying the pszDialect to "SQLITE". For the <a href="../ogrinfo.html">ogrinfo</a> or <a href="../ogr2ogr.html">ogr2ogr</a> utility, you must specify the "-dialect SQLITE" option.</p>
<p>This is mainly aimed to execute SELECT statements, but, for datasources that support update, INSERT/UPDATE/DELETE statements can also be run.</p>
<p>The syntax of the SQL statements is fully the one of the SQLite SQL engine. You can refer to the following pages: </p>
<ul>
<li>
<a href="http://www.sqlite.org/lang_select.html">SELECT</a> documentation </li>
<li>
<a href="http://www.sqlite.org/lang_insert.html">INSERT</a> documentation </li>
<li>
<a href="http://www.sqlite.org/lang_update.html">UPDATE</a> documentation </li>
<li>
<a href="http://www.sqlite.org/lang_delete.html">DELETE</a> documentation </li>
</ul>
<h2><a class="anchor" id="ogr_sql_sqlite_select"></a>
SELECT statement</h2>
<p>The SELECT statement is used to fetch layer features (analogous to table rows in an RDBMS) with the result of the query represented as a temporary layer of features. The layers of the datasource are analogous to tables in an RDBMS and feature attributes are analogous to column values. The simplest form of OGR SQLITE SELECT statement looks like this:</p>
<div class="fragment"><pre class="fragment">SELECT * FROM polylayer
</pre></div><p>More complex statements can of course be used, including WHERE, JOIN, USING, GROUP BY, ORDER BY, sub SELECT, ...</p>
<p>The table names that can be used are the layer names available in the datasource on which the ExecuteSQL() method is called.</p>
<p>Similarly to OGRSQL, it is also possible to refer to layers of other datasources with the following syntax : "other_datasource_name"."layer_name".</p>
<div class="fragment"><pre class="fragment">SELECT p.*, NAME FROM poly p JOIN <span class="stringliteral">&quot;idlink.dbf&quot;</span>.<span class="stringliteral">&quot;idlink&quot;</span> il USING (eas_id)
</pre></div><p>The column names that can be used in the result column list, in WHERE, JOIN, ... clauses are the field names of the layers. Expressions, SQLite functions can also be used, spatial functions, etc...</p>
<p>The conditions on fields expressed in WHERE clauses, or in JOINs are translated, as far as possible, as attribute filters that are applied on the underlying OGR layers. Joins can be very expensive operations if the secondary table is not indexed on the key field being used.</p>
<h3><a class="anchor" id="ogr_sql_sqlite_geometry"></a>
Geometry field</h3>
<p>The <b>GEOMETRY</b> special field represents the geometry of the feature returned by <a class="el" href="classOGRFeature.html#acc966ce8c10ae3ddf9f14c2736fdce9a" title="Fetch pointer to feature geometry.">OGRFeature::GetGeometryRef()</a>. It can be explicitly specified in the result column list of a SELECT, and is automatically selected if the wildcard is used.</p>
<p>For OGR layers that have a non-empty geometry column name (generally for RDBMS datasources), as returned by <a class="el" href="classOGRLayer.html#af68036c23622c954ce3a91861f22b724" title="This method returns the name of the underlying database column being used as the geometry column...">OGRLayer::GetGeometryColumn()</a>, the name of the geometry special field in the SQL statement will be the name of the geometry column of the underlying OGR layer.</p>
<div class="fragment"><pre class="fragment">SELECT EAS_ID, GEOMETRY FROM poly

returns:

<a class="code" href="classOGRFeature.html">OGRFeature</a>(SELECT):0
  EAS_ID (Real) = 168
  POLYGON ((479819.84375 4765180.5,479690.1875 4765259.5,[...],479819.84375 4765180.5))
</pre></div><div class="fragment"><pre class="fragment">SELECT * FROM poly

returns:

<a class="code" href="classOGRFeature.html">OGRFeature</a>(SELECT):0
  AREA (Real) = 215229.266
  EAS_ID (Real) = 168
  PRFEDEA (String) = 35043411
  POLYGON ((479819.84375 4765180.5,479690.1875 4765259.5,[...],479819.84375 4765180.5))
</pre></div><h3><a class="anchor" id="ogr_sql_sqlite_style"></a>
OGR_STYLE special field</h3>
<p>The <b>OGR_STYLE</b> special field represents the style string of the feature returned by <a class="el" href="classOGRFeature.html#a54c179e53eb6eddb657dd392a87cccab" title="Fetch style string for this feature.">OGRFeature::GetStyleString()</a>. By using this field and the <b>LIKE</b> operator the result of the query can be filtered by the style. For example we can select the annotation features as:</p>
<div class="fragment"><pre class="fragment">SELECT * FROM nation WHERE OGR_STYLE LIKE <span class="stringliteral">&#39;LABEL%&#39;</span>
</pre></div><h3><a class="anchor" id="ogr_sql_sqlite_spatialite"></a>
Spatialite SQL functions</h3>
<p>When GDAL/OGR is build with support for the <a href="http://www.gaia-gis.it/spatialite/">Spatialite</a> library, a lot of <a href="http://www.gaia-gis.it/gaia-sins/spatialite-sql-3.0.0.html">extra SQL functions</a>, in particular spatial functions, can be used in results column fields, WHERE clauses, etc....</p>
<div class="fragment"><pre class="fragment">SELECT EAS_ID, ST_Area(GEOMETRY) AS area FROM poly WHERE
    ST_Intersects(GEOMETRY, BuildCircleMbr(479750.6875,4764702.0,100))

returns:

<a class="code" href="classOGRFeature.html">OGRFeature</a>(SELECT):0
  EAS_ID (Real) = 169
  area (Real) = 101429.9765625

<a class="code" href="classOGRFeature.html">OGRFeature</a>(SELECT):1
  EAS_ID (Real) = 165
  area (Real) = 596610.3359375

<a class="code" href="classOGRFeature.html">OGRFeature</a>(SELECT):2
  EAS_ID (Real) = 170
  area (Real) = 5268.8125
</pre></div><h3><a class="anchor" id="ogr_sql_sqlite_datasource_function"></a>
OGR datasource SQL functions</h3>
<p>The <b>ogr_datasource_load_layers(datasource_name[, update_mode[, prefix]])</b> function can be used to automatically load all the layers of a datasource as <a href="http://gdal.org/ogr/drv_sqlite.html">VirtualOGR tables</a>.</p>
<div class="fragment"><pre class="fragment">sqlite&gt; SELECT load_extension(<span class="stringliteral">&#39;libgdal.so&#39;</span>);

sqlite&gt; SELECT load_extension(<span class="stringliteral">&#39;libspatialite.so&#39;</span>);

sqlite&gt; SELECT ogr_datasource_load_layers(<span class="stringliteral">&#39;poly.shp&#39;</span>);
1
sqlite&gt; SELECT * FROM sqlite_master;
table|poly|poly|0|CREATE VIRTUAL TABLE <span class="stringliteral">&quot;poly&quot;</span> USING VirtualOGR(<span class="stringliteral">&#39;poly.shp&#39;</span>, 0, <span class="stringliteral">&#39;poly&#39;</span>)
</pre></div><h3><a class="anchor" id="ogr_sql_sqlite_layer_function"></a>
OGR layer SQL functions</h3>
<p>The following SQL functions are available and operate on a layer name : <b>ogr_layer_Extent()</b>, <b>ogr_layer_SRID()</b>, <b>ogr_layer_GeometryType()</b> and <b>ogr_layer_FeatureCount()</b></p>
<div class="fragment"><pre class="fragment">SELECT ogr_layer_Extent(<span class="stringliteral">&#39;poly&#39;</span>), ogr_layer_SRID(<span class="stringliteral">&#39;poly&#39;</span>) AS srid,
       ogr_layer_GeometryType(&#39;poly&#39;) AS geomtype, ogr_layer_FeatureCount(&#39;poly&#39;) AS count

returns:

<a class="code" href="classOGRFeature.html">OGRFeature</a>(SELECT):0
  srid (Integer) = 40004
  geomtype (String) = POLYGON
  count (Integer) = 10
  POLYGON ((478315.53125 4762880.5,481645.3125 4762880.5,481645.3125 4765610.5,478315.53125 4765610.5,478315.53125 4762880.5))
</pre></div><h3><a class="anchor" id="ogr_sql_sqlite_compression_functions"></a>
OGR compression functions</h3>
<p><b>ogr_deflate(text_or_blob[, compression_level])</b> returns a binary blob compressed with the ZLib deflate algorithm. See <a class="el" href="cpl__conv_8h.html#a09f1dd41a8fa1ebc36bc6c34c7c224a3" title="Compress a buffer with ZLib DEFLATE compression.">CPLZLibDeflate()</a></p>
<p><b>ogr_inflate(compressed_blob)</b> returns the decompressed binary blob, from a blob compressed with the ZLib deflate algorithm. If the decompressed binary is a string, use CAST(ogr_inflate(compressed_blob) AS VARCHAR). See <a class="el" href="cpl__conv_8h.html#a066abbb8471f29f521d19f2252e9959a" title="Uncompress a buffer compressed with ZLib DEFLATE compression.">CPLZLibInflate()</a>.</p>
<h3><a class="anchor" id="ogr_sql_sqlite_ogr_geocode_function"></a>
OGR geocoding functions</h3>
<p>The following SQL functions are available : <b>ogr_geocode(...)</b> and <b>ogr_geocode_reverse(...)</b>.</p>
<p><b>ogr_geocode(name_to_geocode [, field_to_return [, option1 [, option2, ...]]])</b> where name_to_geocode is a literal or a column name that must be geocoded. field_to_return if specified can be "geometry" for the geometry (default), or a field name of the layer returned by <a class="el" href="ogr__geocoding_8h.html#a2b0382ceb7e3935d7fe1da2adada564e" title="Runs a geocoding request.">OGRGeocode()</a>. The special field "raw" can also be used to return the raw response (XML string) of the geocoding service. option1, option2, etc.. must be of the key=value format, and are options understood by <a class="el" href="ogr__geocoding_8h.html#ac3e12320a8046248b992fd0ce4731903" title="Creates a session handle for geocoding requests.">OGRGeocodeCreateSession()</a> or <a class="el" href="ogr__geocoding_8h.html#a2b0382ceb7e3935d7fe1da2adada564e" title="Runs a geocoding request.">OGRGeocode()</a>.</p>
<p>This function internally uses the <a class="el" href="ogr__geocoding_8h.html#a2b0382ceb7e3935d7fe1da2adada564e" title="Runs a geocoding request.">OGRGeocode()</a> API. Refer to it for more details.</p>
<div class="fragment"><pre class="fragment">SELECT ST_Centroid(ogr_geocode(<span class="stringliteral">&#39;Paris&#39;</span>))

returns:

<a class="code" href="classOGRFeature.html">OGRFeature</a>(SELECT):0
  POINT (2.342878767069653 48.85661793020374)
</pre></div><div class="fragment"><pre class="fragment">ogrinfo cities.csv -dialect sqlite -sql <span class="stringliteral">&quot;SELECT *, ogr_geocode(city, &#39;country&#39;) AS country, ST_Centroid(ogr_geocode(city)) FROM cities&quot;</span>

returns:

<a class="code" href="classOGRFeature.html">OGRFeature</a>(SELECT):0
  id (Real) = 1
  city (String) = Paris
  country (String) = France métropolitaine
  POINT (2.342878767069653 48.85661793020374)

<a class="code" href="classOGRFeature.html">OGRFeature</a>(SELECT):1
  id (Real) = 2
  city (String) = London
  country (String) = United Kingdom
  POINT (-0.109369427546499 51.500506667319407)

<a class="code" href="classOGRFeature.html">OGRFeature</a>(SELECT):2
  id (Real) = 3
  city (String) = Rennes
  country (String) = France métropolitaine
  POINT (-1.68185153381778 48.111663929761093)

<a class="code" href="classOGRFeature.html">OGRFeature</a>(SELECT):3
  id (Real) = 4
  city (String) = Strasbourg
  country (String) = France métropolitaine
  POINT (7.767762859150757 48.571233274141846)

<a class="code" href="classOGRFeature.html">OGRFeature</a>(SELECT):4
  id (Real) = 5
  city (String) = New York
  country (String) = United States of America
  POINT (-73.938140243499049 40.663799577449979)

<a class="code" href="classOGRFeature.html">OGRFeature</a>(SELECT):5
  id (Real) = 6
  city (String) = Berlin
  country (String) = Deutschland
  POINT (13.402306623451983 52.501470321410636)

<a class="code" href="classOGRFeature.html">OGRFeature</a>(SELECT):6
  id (Real) = 7
  city (String) = Beijing
  country (String) = 中华人民共和国
  POINT (116.391195 39.9064702)

<a class="code" href="classOGRFeature.html">OGRFeature</a>(SELECT):7
  id (Real) = 8
  city (String) = Brasilia
  country (String) = Brasil
  POINT (-52.830435216371839 -10.828214867369699)

<a class="code" href="classOGRFeature.html">OGRFeature</a>(SELECT):8
  id (Real) = 9
  city (String) = Moscow
  country (String) = Российская Федерация
  POINT (37.367988106866868 55.556208255649558)
</pre></div><p><b>ogr_geocode_reverse(longitude, latitude, field_to_return [, option1 [, option2, ...]])</b> where longitude, latitude is the coordinate to query. field_to_return must be a field name of the layer returned by <a class="el" href="ogr__geocoding_8h.html#abd49f38501af49461928469495861617" title="Runs a reverse geocoding request.">OGRGeocodeReverse()</a> (for example 'display_name'). The special field "raw" can also be used to return the raw response (XML string) of the geocoding service. option1, option2, etc.. must be of the key=value format, and are options understood by <a class="el" href="ogr__geocoding_8h.html#ac3e12320a8046248b992fd0ce4731903" title="Creates a session handle for geocoding requests.">OGRGeocodeCreateSession()</a> or <a class="el" href="ogr__geocoding_8h.html#abd49f38501af49461928469495861617" title="Runs a reverse geocoding request.">OGRGeocodeReverse()</a>.</p>
<p><b>ogr_geocode_reverse(geometry, field_to_return [, option1 [, option2, ...]])</b> is also accepted as an alternate syntax where geometry is a (Spatialite) point geometry.</p>
<p>This function internally uses the <a class="el" href="ogr__geocoding_8h.html#abd49f38501af49461928469495861617" title="Runs a reverse geocoding request.">OGRGeocodeReverse()</a> API. Refer to it for more details.</p>
<h3><a class="anchor" id="ogr_sql_sqlite_spatial_index"></a>
Spatialite spatial index</h3>
<p>Spatialite spatial index mechanism can be triggered by making sure a spatial index virtual table is mentioned in the SQL (of the form idx_layername_geometrycolumn), or by using the more recent SpatialIndex from the VirtualSpatialIndex extension. In which case, a in-memory RTree will be built to be used to speed up the spatial queries.</p>
<p>For example, a spatial intersection between 2 layers, by using a spatial index on one of the layers to limit the number of actual geometry intersection computations :</p>
<div class="fragment"><pre class="fragment">SELECT city_name, region_name FROM cities, regions WHERE
    ST_Area(ST_Intersection(cities.geometry, regions.geometry)) &gt; 0 AND
    regions.rowid IN (
        SELECT pkid FROM idx_regions_geometry WHERE 
            xmax &gt;= MbrMinX(cities.geometry) AND xmin &lt;= MbrMaxX(cities.geometry) AND
            ymax &gt;= MbrMinY(cities.geometry) AND ymin &lt;= MbrMaxY(cities.geometry))
</pre></div><p>or more elegantly :</p>
<div class="fragment"><pre class="fragment">SELECT city_name, region_name FROM cities, regions WHERE
    ST_Area(ST_Intersection(cities.geometry, regions.geometry)) &gt; 0 AND
    regions.rowid IN (
        SELECT rowid FROM SpatialIndex WHERE
            f_table_name = <span class="stringliteral">&#39;regions&#39;</span> AND search_frame = cities.geometry)
</pre></div> </div>
<hr>

Generated for GDAL by 
<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.7.1.
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OGR: cpl_http.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="dir_9f99e07d1011014ac11448b6dc0b7a3e.html">port</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>cpl_http.h File Reference</h1>  </div>
</div>
<div class="contents">
<code>#include &quot;<a class="el" href="cpl__conv_8h_source.html">cpl_conv.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="cpl__string_8h_source.html">cpl_string.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="cpl__vsi_8h_source.html">cpl_vsi.h</a>&quot;</code><br/>

<p><a href="cpl__http_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCPLMimePart.html">CPLMimePart</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCPLHTTPResult.html">CPLHTTPResult</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__http_8h.html#aa024615adc5369c42efc07dbd05596a9">CPLHTTPEnabled</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return if CPLHTTP services can be usefull.  <a href="#aa024615adc5369c42efc07dbd05596a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCPLHTTPResult.html">CPLHTTPResult</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__http_8h.html#aee8368b7821300f4b81ef4da8a9c6a29">CPLHTTPFetch</a> (const char *pszURL, char **papszOptions)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch a document from an url and return in a string.  <a href="#aee8368b7821300f4b81ef4da8a9c6a29"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a6f247c254d96cc4e3bf0357b6f475b"></a><!-- doxytag: member="cpl_http.h::CPLHTTPCleanup" ref="a3a6f247c254d96cc4e3bf0357b6f475b" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__http_8h.html#a3a6f247c254d96cc4e3bf0357b6f475b">CPLHTTPCleanup</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cleanup function to call at application termination. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__http_8h.html#ab9a9077d09a1ebd94fb2bf4c80efb240">CPLHTTPDestroyResult</a> (<a class="el" href="structCPLHTTPResult.html">CPLHTTPResult</a> *psResult)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clean the memory associated with the return value of <a class="el" href="cpl__http_8h.html#aee8368b7821300f4b81ef4da8a9c6a29" title="Fetch a document from an url and return in a string.">CPLHTTPFetch()</a>.  <a href="#ab9a9077d09a1ebd94fb2bf4c80efb240"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__http_8h.html#aea965c9ff390520fa3b6c99971b8bef2">CPLHTTPParseMultipartMime</a> (<a class="el" href="structCPLHTTPResult.html">CPLHTTPResult</a> *psResult)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parses a a MIME multipart message.  <a href="#aea965c9ff390520fa3b6c99971b8bef2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__http_8h.html#a8793ce5fc5402ad4d353a713703995c6">GOA2GetAuthorizationURL</a> (const char *pszScope)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__http_8h.html#aa75528c90727da832400f0b9c88e77ab">GOA2GetRefreshToken</a> (const char *pszAuthToken, const char *pszScope)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__http_8h.html#aa97c9ff3bd3ad4d0d0f8a68bff4f30e9">GOA2GetAccessToken</a> (const char *pszRefreshToken, const char *pszScope)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Interface for downloading HTTP, FTP documents </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ab9a9077d09a1ebd94fb2bf4c80efb240"></a><!-- doxytag: member="cpl_http.h::CPLHTTPDestroyResult" ref="ab9a9077d09a1ebd94fb2bf4c80efb240" args="(CPLHTTPResult *psResult)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CPLHTTPDestroyResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCPLHTTPResult.html">CPLHTTPResult</a> *&nbsp;</td>
          <td class="paramname"> <em>psResult</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clean the memory associated with the return value of <a class="el" href="cpl__http_8h.html#aee8368b7821300f4b81ef4da8a9c6a29" title="Fetch a document from an url and return in a string.">CPLHTTPFetch()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psResult</em>&nbsp;</td><td>pointer to the return value of <a class="el" href="cpl__http_8h.html#aee8368b7821300f4b81ef4da8a9c6a29" title="Fetch a document from an url and return in a string.">CPLHTTPFetch()</a> </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structCPLHTTPResult.html#abfc73d0ee8dcecafbc6e146c3de35e20">CPLHTTPResult::nMimePartCount</a>, <a class="el" href="structCPLHTTPResult.html#a036fe44623bd4fbfb0d745e3d8061dd3">CPLHTTPResult::pabyData</a>, <a class="el" href="structCPLMimePart.html#a0367a54d84f5164d542a4afc71414819">CPLMimePart::papszHeaders</a>, <a class="el" href="structCPLHTTPResult.html#a9e4030d7c1fc15ed3a16e5d81657b04a">CPLHTTPResult::papszHeaders</a>, <a class="el" href="structCPLHTTPResult.html#a6f2a684692f0d76f12b87e1c74e1122a">CPLHTTPResult::pasMimePart</a>, <a class="el" href="structCPLHTTPResult.html#a990bea42d93cdd41391e44d21f5547d2">CPLHTTPResult::pszContentType</a>, and <a class="el" href="structCPLHTTPResult.html#ab12ef4fe5ff02f4ba459bd09e3481996">CPLHTTPResult::pszErrBuf</a>.</p>

</div>
</div>
<a class="anchor" id="aa024615adc5369c42efc07dbd05596a9"></a><!-- doxytag: member="cpl_http.h::CPLHTTPEnabled" ref="aa024615adc5369c42efc07dbd05596a9" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLHTTPEnabled </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return if CPLHTTP services can be usefull. </p>
<p>Those services depend on GDAL being build with libcurl support.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if libcurl support is enabled </dd></dl>

</div>
</div>
<a class="anchor" id="aee8368b7821300f4b81ef4da8a9c6a29"></a><!-- doxytag: member="cpl_http.h::CPLHTTPFetch" ref="aee8368b7821300f4b81ef4da8a9c6a29" args="(const char *pszURL, char **papszOptions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCPLHTTPResult.html">CPLHTTPResult</a>* CPLHTTPFetch </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszURL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszOptions</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch a document from an url and return in a string. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszURL</em>&nbsp;</td><td>valid URL recognized by underlying download library (libcurl) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>papszOptions</em>&nbsp;</td><td>option list as a NULL-terminated array of strings. May be NULL. The following options are handled : </p>
<ul>
<li>
TIMEOUT=val, where val is in seconds </li>
<li>
HEADERS=val, where val is an extra header to use when getting a web page. For example "Accept: application/x-ogcwkt" </li>
<li>
HTTPAUTH=[BASIC/NTLM/GSSNEGOTIATE/ANY] to specify an authentication scheme to use. </li>
<li>
USERPWD=userid:password to specify a user and password for authentication </li>
<li>
POSTFIELDS=val, where val is a nul-terminated string to be passed to the server with a POST request. </li>
<li>
PROXY=val, to make requests go through a proxy server, where val is of the form proxy.server.com:port_number </li>
<li>
PROXYUSERPWD=val, where val is of the form username:password </li>
<li>
PROXYAUTH=[BASIC/NTLM/DIGEST/ANY] to specify an proxy authentication scheme to use. </li>
<li>
NETRC=[YES/NO] to enable or disable use of $HOME/.netrc, default YES. </li>
<li>
CUSTOMREQUEST=val, where val is GET, PUT, POST, DELETE, etc.. (GDAL &gt;= 1.9.0) </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Alternatively, if not defined in the papszOptions arguments, the PROXY, PROXYUSERPWD, PROXYAUTH and NETRC values are searched in the configuration options named GDAL_HTTP_PROXY, GDAL_HTTP_PROXYUSERPWD, GDAL_PROXY_AUTH and GDAL_HTTP_NETRC, as proxy configuration belongs to networking setup and makes more sense at the configuration option level than at the connection level.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a CPLHTTPResult* structure that must be freed by <a class="el" href="cpl__http_8h.html#ab9a9077d09a1ebd94fb2bf4c80efb240" title="Clean the memory associated with the return value of CPLHTTPFetch().">CPLHTTPDestroyResult()</a>, or NULL if libcurl support is disabled </dd></dl>

<p>References <a class="el" href="structCPLHTTPResult.html#adc164db6153c5e4b7e5ae831abe17cdd">CPLHTTPResult::nDataLen</a>, <a class="el" href="structCPLHTTPResult.html#a166662b7a348b3e009669a7bef9277f7">CPLHTTPResult::nStatus</a>, <a class="el" href="structCPLHTTPResult.html#a9e4030d7c1fc15ed3a16e5d81657b04a">CPLHTTPResult::papszHeaders</a>, <a class="el" href="structCPLHTTPResult.html#a990bea42d93cdd41391e44d21f5547d2">CPLHTTPResult::pszContentType</a>, and <a class="el" href="structCPLHTTPResult.html#ab12ef4fe5ff02f4ba459bd09e3481996">CPLHTTPResult::pszErrBuf</a>.</p>

</div>
</div>
<a class="anchor" id="aea965c9ff390520fa3b6c99971b8bef2"></a><!-- doxytag: member="cpl_http.h::CPLHTTPParseMultipartMime" ref="aea965c9ff390520fa3b6c99971b8bef2" args="(CPLHTTPResult *psResult)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLHTTPParseMultipartMime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCPLHTTPResult.html">CPLHTTPResult</a> *&nbsp;</td>
          <td class="paramname"> <em>psResult</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Parses a a MIME multipart message. </p>
<p>This function will iterate over each part and put it in a separate element of the pasMimePart array of the provided psResult structure.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psResult</em>&nbsp;</td><td>pointer to the return value of <a class="el" href="cpl__http_8h.html#aee8368b7821300f4b81ef4da8a9c6a29" title="Fetch a document from an url and return in a string.">CPLHTTPFetch()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the message contains MIME multipart message. </dd></dl>

<p>References <a class="el" href="structCPLMimePart.html#a57e3cadf6df58d374b6721273d6810ab">CPLMimePart::nDataLen</a>, <a class="el" href="structCPLHTTPResult.html#adc164db6153c5e4b7e5ae831abe17cdd">CPLHTTPResult::nDataLen</a>, <a class="el" href="structCPLHTTPResult.html#abfc73d0ee8dcecafbc6e146c3de35e20">CPLHTTPResult::nMimePartCount</a>, <a class="el" href="structCPLMimePart.html#a6e934c417190b093d1f5547dd315ca83">CPLMimePart::pabyData</a>, <a class="el" href="structCPLHTTPResult.html#a036fe44623bd4fbfb0d745e3d8061dd3">CPLHTTPResult::pabyData</a>, <a class="el" href="structCPLMimePart.html#a0367a54d84f5164d542a4afc71414819">CPLMimePart::papszHeaders</a>, <a class="el" href="structCPLHTTPResult.html#a6f2a684692f0d76f12b87e1c74e1122a">CPLHTTPResult::pasMimePart</a>, and <a class="el" href="structCPLHTTPResult.html#a990bea42d93cdd41391e44d21f5547d2">CPLHTTPResult::pszContentType</a>.</p>

</div>
</div>
<a class="anchor" id="aa97c9ff3bd3ad4d0d0f8a68bff4f30e9"></a><!-- doxytag: member="cpl_http.h::GOA2GetAccessToken" ref="aa97c9ff3bd3ad4d0d0f8a68bff4f30e9" args="(const char *pszRefreshToken, const char *pszScope)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* GOA2GetAccessToken </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszRefreshToken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszScope</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch access token using refresh token.</p>
<p>The permanent refresh token is used to fetch a temporary (usually one hour) access token using Google OAuth2 web services.</p>
<p>A CPLError will be reported if the request fails for some reason. Common reasons include the refresh token having been revoked by the user or http connection problems.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszRefreshToken</em>&nbsp;</td><td>the refresh token from <a class="el" href="cpl__http_8h.html#aa75528c90727da832400f0b9c88e77ab">GOA2GetRefreshToken()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszScope</em>&nbsp;</td><td>the scope for which it is valid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>access token, to be freed with CPLFree(), null on failure. </dd></dl>

<p>References <a class="el" href="classCPLStringList.html#afb284d82f71198fa175f6656cd8ca328">CPLStringList::AddString()</a>, <a class="el" href="classCPLStringList.html#a136e202c6a040a9b424275e09f8c6120">CPLStringList::FetchNameValueDef()</a>, <a class="el" href="structCPLHTTPResult.html#a036fe44623bd4fbfb0d745e3d8061dd3">CPLHTTPResult::pabyData</a>, and <a class="el" href="structCPLHTTPResult.html#ab12ef4fe5ff02f4ba459bd09e3481996">CPLHTTPResult::pszErrBuf</a>.</p>

</div>
</div>
<a class="anchor" id="a8793ce5fc5402ad4d353a713703995c6"></a><!-- doxytag: member="cpl_http.h::GOA2GetAuthorizationURL" ref="a8793ce5fc5402ad4d353a713703995c6" args="(const char *pszScope)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* GOA2GetAuthorizationURL </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszScope</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return authorization url for a given scope.</p>
<p>Returns the URL that a user should visit, and use for authentication in order to get an "auth token" indicating their willingness to use a service.</p>
<p>Note that when the user visits this url they will be asked to login (using a google/gmail/etc) account, and to authorize use of the requested scope for the application "GDAL/OGR". Once they have done so, they will be presented with a lengthy string they should "enter
 into their application". This is the "auth token" to be passed to <a class="el" href="cpl__http_8h.html#aa75528c90727da832400f0b9c88e77ab">GOA2GetRefreshToken()</a>. The "auth token" can only be used once.</p>
<p>This function should never fail.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszScope</em>&nbsp;</td><td>the service being requested, not yet URL encoded, such as "https://www.googleapis.com/auth/fusiontables".</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the URL to visit - should be freed with CPLFree(). </dd></dl>

</div>
</div>
<a class="anchor" id="aa75528c90727da832400f0b9c88e77ab"></a><!-- doxytag: member="cpl_http.h::GOA2GetRefreshToken" ref="aa75528c90727da832400f0b9c88e77ab" args="(const char *pszAuthToken, const char *pszScope)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* GOA2GetRefreshToken </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszAuthToken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszScope</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Turn Auth Token into a Refresh Token.</p>
<p>A one time "auth token" provided by the user is turned into a reusable "refresh token" using a google oauth2 web service.</p>
<p>A CPLError will be reported if the translation fails for some reason. Common reasons include the auth token already having been used before, it not being appropriate for the passed scope and configured client api or http connection problems. NULL is returned on error.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszAuthToken</em>&nbsp;</td><td>the authorization token from the user. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszScope</em>&nbsp;</td><td>the scope for which it is valid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>refresh token, to be freed with CPLFree(), null on failure. </dd></dl>

<p>References <a class="el" href="classCPLStringList.html#afb284d82f71198fa175f6656cd8ca328">CPLStringList::AddString()</a>, <a class="el" href="classCPLStringList.html#a136e202c6a040a9b424275e09f8c6120">CPLStringList::FetchNameValueDef()</a>, <a class="el" href="structCPLHTTPResult.html#a036fe44623bd4fbfb0d745e3d8061dd3">CPLHTTPResult::pabyData</a>, and <a class="el" href="structCPLHTTPResult.html#ab12ef4fe5ff02f4ba459bd09e3481996">CPLHTTPResult::pszErrBuf</a>.</p>

</div>
</div>
</div>
<hr>

Generated for GDAL by 
<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.7.1.
</body>
</html>

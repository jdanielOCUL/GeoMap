<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OGR: OGRLayer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>OGRLayer Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="OGRLayer" -->
<p><code>#include &lt;<a class="el" href="ogrsf__frmts_8h_source.html">ogrsf_frmts.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for OGRLayer:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classOGRLayer.png" usemap="#OGRLayer_map" alt=""/>
  <map id="OGRLayer_map" name="OGRLayer_map">
<area href="classOGRAbstractProxiedLayer.html" alt="OGRAbstractProxiedLayer" shape="rect" coords="0,56,162,80"/>
<area href="classOGRGenSQLResultsLayer.html" alt="OGRGenSQLResultsLayer" shape="rect" coords="172,56,334,80"/>
<area href="classOGRLayerDecorator.html" alt="OGRLayerDecorator" shape="rect" coords="344,56,506,80"/>
<area href="classOGRUnionLayer.html" alt="OGRUnionLayer" shape="rect" coords="516,56,678,80"/>
<area href="classOGRProxiedLayer.html" alt="OGRProxiedLayer" shape="rect" coords="0,112,162,136"/>
<area href="classOGRMutexedLayer.html" alt="OGRMutexedLayer" shape="rect" coords="258,112,420,136"/>
<area href="classOGRWarpedLayer.html" alt="OGRWarpedLayer" shape="rect" coords="430,112,592,136"/>
</map>
</div>

<p><a href="classOGRLayer-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#adc3735e444204d46f517eec251712f4d">GetSpatialFilter</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method returns the current spatial filter for this layer.  <a href="#adc3735e444204d46f517eec251712f4d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169">SetSpatialFilter</a> (<a class="el" href="classOGRGeometry.html">OGRGeometry</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a new spatial filter.  <a href="#a0b4ab45cf97cbc470f0d60474d3e4169"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#acd16bcdb3e8f720003fb24cd68f25460">SetSpatialFilterRect</a> (double dfMinX, double dfMinY, double dfMaxX, double dfMaxY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a new rectangular spatial filter.  <a href="#acd16bcdb3e8f720003fb24cd68f25460"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#aebac60fb86ee178be016655532070ee3">SetSpatialFilter</a> (int iGeomField, <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a new spatial filter.  <a href="#aebac60fb86ee178be016655532070ee3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a5cd4ceb8f4ec20594be63280c8e4498a">SetSpatialFilterRect</a> (int iGeomField, double dfMinX, double dfMinY, double dfMaxX, double dfMaxY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a new rectangular spatial filter.  <a href="#a5cd4ceb8f4ec20594be63280c8e4498a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#acb2c6cc5fa3577df5be538284c1b0dde">SetAttributeFilter</a> (const char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a new attribute query.  <a href="#acb2c6cc5fa3577df5be538284c1b0dde"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#aad0f2cd7f0587584b8f382c6a913583c">ResetReading</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset feature reading to start on the first feature.  <a href="#aad0f2cd7f0587584b8f382c6a913583c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRFeature.html">OGRFeature</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6">GetNextFeature</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the next available feature from this layer.  <a href="#a47d21ff33b32d14fa4e9885b9edecad6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#ae3b6234d6077a18a19eddaf7e75ff5e1">SetNextByIndex</a> (long nIndex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move read cursor to the nIndex'th feature in the current resultset.  <a href="#ae3b6234d6077a18a19eddaf7e75ff5e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRFeature.html">OGRFeature</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#acb7625383f161e5a04aeea2173dce411">GetFeature</a> (long nFID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch a feature by its identifier.  <a href="#acb7625383f161e5a04aeea2173dce411"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a681139bfd585b74d7218e51a32144283">SetFeature</a> (<a class="el" href="classOGRFeature.html">OGRFeature</a> *poFeature)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rewrite an existing feature.  <a href="#a681139bfd585b74d7218e51a32144283"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#aaa1e32016f481596a55e1d988a15a067">CreateFeature</a> (<a class="el" href="classOGRFeature.html">OGRFeature</a> *poFeature)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create and write a new feature within a layer.  <a href="#aaa1e32016f481596a55e1d988a15a067"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a7e3d454d54a615a1b4359628bb6e7674">DeleteFeature</a> (long nFID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete feature from layer.  <a href="#a7e3d454d54a615a1b4359628bb6e7674"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a287f5ec7728cacc2f7d94882a9f1a22e">GetName</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the layer name.  <a href="#a287f5ec7728cacc2f7d94882a9f1a22e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a818a25520ce08d5a681443348e930604">GetGeomType</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the layer geometry type.  <a href="#a818a25520ce08d5a681443348e930604"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf">GetLayerDefn</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the schema information for this layer.  <a href="#a80473bcfd11341e70dd35bebe94026cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#aef41bcd7adad1ac5ddcef54d6b38713c">FindFieldIndex</a> (const char *pszFieldName, int bExactMatch)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the index of field in the layer.  <a href="#aef41bcd7adad1ac5ddcef54d6b38713c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a75c06b4993f8eb76b569f37365cd19ab">GetSpatialRef</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the spatial reference system for this layer.  <a href="#a75c06b4993f8eb76b569f37365cd19ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a74c796d4ce712e9a78df6042eeb8a91a">GetFeatureCount</a> (int bForce=TRUE)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the feature count in this layer.  <a href="#a74c796d4ce712e9a78df6042eeb8a91a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a3be658ddb5b33d1ed95c31286774bbd2">GetExtent</a> (<a class="el" href="classOGREnvelope.html">OGREnvelope</a> *psExtent, int bForce=TRUE)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the extent of this layer.  <a href="#a3be658ddb5b33d1ed95c31286774bbd2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a47a3cc550866eee1668bea2315f9df9c">GetExtent</a> (int iGeomField, <a class="el" href="classOGREnvelope.html">OGREnvelope</a> *psExtent, int bForce=TRUE)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the extent of this layer, on the specified geometry field.  <a href="#a47a3cc550866eee1668bea2315f9df9c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#aeedbda1a62f9b89b8e5f24332cf22286">TestCapability</a> (const char *)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this layer supported the named capability.  <a href="#aeedbda1a62f9b89b8e5f24332cf22286"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a143b0d2c48bc0adf3a19d1f51e76b8ba">GetInfo</a> (const char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch metadata from layer.  <a href="#a143b0d2c48bc0adf3a19d1f51e76b8ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a00b1376a1eabb1298ef278f92f6d84be">CreateField</a> (<a class="el" href="classOGRFieldDefn.html">OGRFieldDefn</a> *poField, int bApproxOK=TRUE)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new field on a layer.  <a href="#a00b1376a1eabb1298ef278f92f6d84be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#aaebe7c671dca995549543eecf0f7a76a">DeleteField</a> (int iField)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete an existing field on a layer.  <a href="#aaebe7c671dca995549543eecf0f7a76a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#aebd364a150d91f8d65d967646e0f92d3">ReorderFields</a> (int *panMap)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reorder all the fields of a layer.  <a href="#aebd364a150d91f8d65d967646e0f92d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a71e69a665e93001d48a4339695f33c1a">AlterFieldDefn</a> (int iField, <a class="el" href="classOGRFieldDefn.html">OGRFieldDefn</a> *poNewFieldDefn, int nFlags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Alter the definition of an existing field on a layer.  <a href="#a71e69a665e93001d48a4339695f33c1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#af3c68cad279ad80a476c6fb307cf5e48">CreateGeomField</a> (<a class="el" href="classOGRGeomFieldDefn.html">OGRGeomFieldDefn</a> *poField, int bApproxOK=TRUE)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new geometry field on a layer.  <a href="#af3c68cad279ad80a476c6fb307cf5e48"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#aebb07284c734e485d8611b7c8599254f">SyncToDisk</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flush pending changes to disk.  <a href="#aebb07284c734e485d8611b7c8599254f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRStyleTable.html">OGRStyleTable</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#ac65f762d5b3c6fc4ca0f0cc4aafcdcbe">GetStyleTable</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns layer style table.  <a href="#ac65f762d5b3c6fc4ca0f0cc4aafcdcbe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a2687d4312c044bb3a20bd13974ba8905">SetStyleTableDirectly</a> (<a class="el" href="classOGRStyleTable.html">OGRStyleTable</a> *poStyleTable)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set layer style table.  <a href="#a2687d4312c044bb3a20bd13974ba8905"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a33fa0802c0686fb0e6ca6337e11cd7d5">SetStyleTable</a> (<a class="el" href="classOGRStyleTable.html">OGRStyleTable</a> *poStyleTable)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set layer style table.  <a href="#a33fa0802c0686fb0e6ca6337e11cd7d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#af0cb9a05310d7b17d9dfec9e83a18e61">GetFIDColumn</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method returns the name of the underlying database column being used as the FID column, or "" if not supported.  <a href="#af0cb9a05310d7b17d9dfec9e83a18e61"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#af68036c23622c954ce3a91861f22b724">GetGeometryColumn</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method returns the name of the underlying database column being used as the geometry column, or "" if not supported.  <a href="#af68036c23622c954ce3a91861f22b724"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a5e0c3427f64249d1c35cefb487546b10">SetIgnoredFields</a> (const char **papszFields)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set which fields can be omitted when retrieving features from the layer.  <a href="#a5e0c3427f64249d1c35cefb487546b10"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#ac189f54996c2d6fd769889ec99e0f48a">Intersection</a> (<a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerMethod, <a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerResult, char **papszOptions=NULL, GDALProgressFunc pfnProgress=NULL, void *pProgressArg=NULL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Intersection of two layers.  <a href="#ac189f54996c2d6fd769889ec99e0f48a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#aeb8ab475561f2aca2c0e605cfb810b22">Union</a> (<a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerMethod, <a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerResult, char **papszOptions=NULL, GDALProgressFunc pfnProgress=NULL, void *pProgressArg=NULL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Union of two layers.  <a href="#aeb8ab475561f2aca2c0e605cfb810b22"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a781aa76c6b44b19de09f61816e32245b">SymDifference</a> (<a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerMethod, <a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerResult, char **papszOptions, GDALProgressFunc pfnProgress, void *pProgressArg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Symmetrical difference of two layers.  <a href="#a781aa76c6b44b19de09f61816e32245b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#acac6a0bde9737555b22c6ac7fa967431">Identity</a> (<a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerMethod, <a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerResult, char **papszOptions=NULL, GDALProgressFunc pfnProgress=NULL, void *pProgressArg=NULL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Identify the features of this layer with the ones from the identity layer.  <a href="#acac6a0bde9737555b22c6ac7fa967431"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#aa1c5dc5ca195956c46d35a85b0b21d9b">Update</a> (<a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerMethod, <a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerResult, char **papszOptions=NULL, GDALProgressFunc pfnProgress=NULL, void *pProgressArg=NULL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update this layer with features from the update layer.  <a href="#aa1c5dc5ca195956c46d35a85b0b21d9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a56d7ee3b2020e53c730d67ee4f1e2fb6">Clip</a> (<a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerMethod, <a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerResult, char **papszOptions=NULL, GDALProgressFunc pfnProgress=NULL, void *pProgressArg=NULL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clip off areas that are not covered by the method layer.  <a href="#a56d7ee3b2020e53c730d67ee4f1e2fb6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#ae8fcf55ffa259f32df35edcb05274439">Erase</a> (<a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerMethod, <a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerResult, char **papszOptions=NULL, GDALProgressFunc pfnProgress=NULL, void *pProgressArg=NULL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove areas that are covered by the method layer.  <a href="#ae8fcf55ffa259f32df35edcb05274439"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#ae783de2e9ee2629e6bf27fd3b8622fb5">Reference</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increment layer reference count.  <a href="#ae783de2e9ee2629e6bf27fd3b8622fb5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a2271d53f75d4f6ff2f4a8aeb71e825d6">Dereference</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decrement layer reference count.  <a href="#a2271d53f75d4f6ff2f4a8aeb71e825d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a2fc393bc9962a73e94478b72d9fc4954">GetRefCount</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch reference count.  <a href="#a2fc393bc9962a73e94478b72d9fc4954"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#ab4c02b991bfa78552eeb0cbcdcf1aed8">ReorderField</a> (int iOldFieldPos, int iNewFieldPos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reorder an existing field on a layer.  <a href="#ab4c02b991bfa78552eeb0cbcdcf1aed8"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class represents a layer of simple features, with access methods. </p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a71e69a665e93001d48a4339695f33c1a"></a><!-- doxytag: member="OGRLayer::AlterFieldDefn" ref="a71e69a665e93001d48a4339695f33c1a" args="(int iField, OGRFieldDefn *poNewFieldDefn, int nFlags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRLayer::AlterFieldDefn </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRFieldDefn.html">OGRFieldDefn</a> *&nbsp;</td>
          <td class="paramname"> <em>poNewFieldDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nFlags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Alter the definition of an existing field on a layer. </p>
<p>You must use this to alter the definition of an existing field of a real layer. Internally the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> for the layer will be updated to reflect the altered field. Applications should never modify the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> used by a layer directly.</p>
<p>This method should not be called while there are feature objects in existance that were obtained or created with the previous layer definition.</p>
<p>Not all drivers support this method. You can query a layer to check if it supports it with the OLCAlterFieldDefn capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existings features of the backing file/database should be updated accordingly. Some drivers might also not support all update flags.</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#a679904d97c1084f309706ac3c6228cec" title="Alter the definition of an existing field on a layer.">OGR_L_AlterFieldDefn()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iField</em>&nbsp;</td><td>index of the field whose definition must be altered. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>poNewFieldDefn</em>&nbsp;</td><td>new field definition </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nFlags</em>&nbsp;</td><td>combination of ALTER_NAME_FLAG, ALTER_TYPE_FLAG and ALTER_WIDTH_PRECISION_FLAG to indicate which of the name and/or type and/or width and precision fields from the new field definition must be taken into account.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE on success.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.9.0 </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRLayerDecorator.html#a9ede09c21d142c0fe9725b422b833f3f">OGRLayerDecorator</a>, <a class="el" href="classOGRProxiedLayer.html#a2878154f067de4088ef000b9d5bcd76a">OGRProxiedLayer</a>, and <a class="el" href="classOGRMutexedLayer.html#a2a75d65d01ede43cf930675fa44da283">OGRMutexedLayer</a>.</p>

<p>Referenced by <a class="el" href="classOGRProxiedLayer.html#a2878154f067de4088ef000b9d5bcd76a">OGRProxiedLayer::AlterFieldDefn()</a>, and <a class="el" href="classOGRLayerDecorator.html#a9ede09c21d142c0fe9725b422b833f3f">OGRLayerDecorator::AlterFieldDefn()</a>.</p>

</div>
</div>
<a class="anchor" id="a56d7ee3b2020e53c730d67ee4f1e2fb6"></a><!-- doxytag: member="OGRLayer::Clip" ref="a56d7ee3b2020e53c730d67ee4f1e2fb6" args="(OGRLayer *pLayerMethod, OGRLayer *pLayerResult, char **papszOptions=NULL, GDALProgressFunc pfnProgress=NULL, void *pProgressArg=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRLayer::Clip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRLayer.html">OGRLayer</a> *&nbsp;</td>
          <td class="paramname"> <em>pLayerMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRLayer.html">OGRLayer</a> *&nbsp;</td>
          <td class="paramname"> <em>pLayerResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszOptions</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&nbsp;</td>
          <td class="paramname"> <em>pfnProgress</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pProgressArg</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clip off areas that are not covered by the method layer. </p>
<p>The result layer contains features whose geometries represent areas that are in the input layer and in the method layer. The features in the result layer have the (possibly clipped) areas of features in the input layer and the attributes from the same features. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in the input layer.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</dd>
<dd>
This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</dd></dl>
<p>The recognized list of options is : </p>
<ul>
<li>
SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted. </li>
<li>
PROMOTE_TO_MULTI=YES/NO. Set it to YES to convert Polygons into MultiPolygons, or LineStrings to MultiLineStrings. </li>
<li>
INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer. </li>
<li>
METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer. </li>
</ul>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ae12dcd5dc6dc5f930218573658f1b5c2" title="Clip off areas that are not covered by the method layer.">OGR_L_Clip()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pLayerMethod</em>&nbsp;</td><td>the method layer. Should not be NULL.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pLayerResult</em>&nbsp;</td><td>the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>papszOptions</em>&nbsp;</td><td>NULL terminated list of options (may be NULL).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnProgress</em>&nbsp;</td><td>a GDALProgressFunc() compatible callback function for reporting progress or NULL.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pProgressArg</em>&nbsp;</td><td>argument to be passed to pfnProgress. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.10 </dd></dl>

<p>References <a class="el" href="classOGRGeometry.html#af4cf9f6eee1997268a481b39401c3161">OGRGeometry::clone()</a>, <a class="el" href="classOGRLayer.html#aaa1e32016f481596a55e1d988a15a067">CreateFeature()</a>, <a class="el" href="classOGRLayer.html#a74c796d4ce712e9a78df6042eeb8a91a">GetFeatureCount()</a>, <a class="el" href="classOGRFeature.html#acc966ce8c10ae3ddf9f14c2736fdce9a">OGRFeature::GetGeometryRef()</a>, <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf">GetLayerDefn()</a>, <a class="el" href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6">GetNextFeature()</a>, <a class="el" href="classOGRGeometryFactory.html#a04998dcdbb37aa37871891593c048544">OGRGeometryFactory::haveGEOS()</a>, <a class="el" href="classOGRGeometry.html#a202ad4c29487ca046c4a2b055042cb6a">OGRGeometry::Intersection()</a>, <a class="el" href="classOGRGeometry.html#ac8653ba97e53f3e3b041946ca2acc111">OGRGeometry::IsEmpty()</a>, <a class="el" href="classOGRLayer.html#aad0f2cd7f0587584b8f382c6a913583c">ResetReading()</a>, <a class="el" href="classOGRFeature.html#a6705e5ff8b1012ce4a687b973ecddf73">OGRFeature::SetFieldsFrom()</a>, <a class="el" href="classOGRFeature.html#a40a4ddb33f09a5f340b9139be72e277d">OGRFeature::SetGeometryDirectly()</a>, <a class="el" href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169">SetSpatialFilter()</a>, and <a class="el" href="classOGRGeometry.html#a15fb98d101f5887f7c3af40b6da5a3c4">OGRGeometry::Union()</a>.</p>

</div>
</div>
<a class="anchor" id="aaa1e32016f481596a55e1d988a15a067"></a><!-- doxytag: member="OGRLayer::CreateFeature" ref="aaa1e32016f481596a55e1d988a15a067" args="(OGRFeature *poFeature)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRLayer::CreateFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRFeature.html">OGRFeature</a> *&nbsp;</td>
          <td class="paramname"> <em>poFeature</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create and write a new feature within a layer. </p>
<p>The passed feature is written to the layer as a new feature, rather than overwriting an existing one. If the feature has a feature id other than OGRNullFID, then the native implementation may use that as the feature id of the new feature, but not necessarily. Upon successful return the passed feature will have been updated with the new feature id.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a301d319111285a47fe6cda6e079214f8" title="Create and write a new feature within a layer.">OGR_L_CreateFeature()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poFeature</em>&nbsp;</td><td>the feature to write to disk.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE on success. </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRLayerDecorator.html#a096e5988e4b10966417a3753662c6171">OGRLayerDecorator</a>, <a class="el" href="classOGRProxiedLayer.html#ad8d178d54705aefef9f0ab088e567a46">OGRProxiedLayer</a>, <a class="el" href="classOGRMutexedLayer.html#a47882f9c1e1aca67afce06a033789540">OGRMutexedLayer</a>, <a class="el" href="classOGRUnionLayer.html#a094a2f13809f0b2eaabbc572ddfc19ed">OGRUnionLayer</a>, and <a class="el" href="classOGRWarpedLayer.html#ad1208b597aca9b8b5e90816dc2998ff8">OGRWarpedLayer</a>.</p>

<p>Referenced by <a class="el" href="classOGRLayer.html#a56d7ee3b2020e53c730d67ee4f1e2fb6">Clip()</a>, <a class="el" href="classOGRDataSource.html#a42dc7f7f538cd4f083af350722fe53ae">OGRDataSource::CopyLayer()</a>, <a class="el" href="classOGRWarpedLayer.html#ad1208b597aca9b8b5e90816dc2998ff8">OGRWarpedLayer::CreateFeature()</a>, <a class="el" href="classOGRUnionLayer.html#a094a2f13809f0b2eaabbc572ddfc19ed">OGRUnionLayer::CreateFeature()</a>, <a class="el" href="classOGRProxiedLayer.html#ad8d178d54705aefef9f0ab088e567a46">OGRProxiedLayer::CreateFeature()</a>, <a class="el" href="classOGRLayerDecorator.html#a096e5988e4b10966417a3753662c6171">OGRLayerDecorator::CreateFeature()</a>, <a class="el" href="classOGRLayer.html#ae8fcf55ffa259f32df35edcb05274439">Erase()</a>, <a class="el" href="classOGRLayer.html#acac6a0bde9737555b22c6ac7fa967431">Identity()</a>, <a class="el" href="classOGRLayer.html#ac189f54996c2d6fd769889ec99e0f48a">Intersection()</a>, <a class="el" href="classOGRLayer.html#a781aa76c6b44b19de09f61816e32245b">SymDifference()</a>, <a class="el" href="classOGRLayer.html#aeb8ab475561f2aca2c0e605cfb810b22">Union()</a>, and <a class="el" href="classOGRLayer.html#aa1c5dc5ca195956c46d35a85b0b21d9b">Update()</a>.</p>

</div>
</div>
<a class="anchor" id="a00b1376a1eabb1298ef278f92f6d84be"></a><!-- doxytag: member="OGRLayer::CreateField" ref="a00b1376a1eabb1298ef278f92f6d84be" args="(OGRFieldDefn *poField, int bApproxOK=TRUE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRLayer::CreateField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRFieldDefn.html">OGRFieldDefn</a> *&nbsp;</td>
          <td class="paramname"> <em>poField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bApproxOK</em> = <code>TRUE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new field on a layer. </p>
<p>You must use this to create new fields on a real layer. Internally the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> for the layer will be updated to reflect the new field. Applications should never modify the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> used by a layer directly.</p>
<p>This method should not be called while there are feature objects in existance that were obtained or created with the previous layer definition.</p>
<p>Not all drivers support this method. You can query a layer to check if it supports it with the OLCCreateField capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existings features of the backing file/database should be updated accordingly.</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#aab585ef1166c61c4819f7fd46ee4a275" title="Create a new field on a layer.">OGR_L_CreateField()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poField</em>&nbsp;</td><td>field definition to write to disk. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bApproxOK</em>&nbsp;</td><td>If TRUE, the field may be created in a slightly different form depending on the limitations of the format driver.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE on success. </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRLayerDecorator.html#a8ebcd0484d1c1415876986e3eef5ffeb">OGRLayerDecorator</a>, <a class="el" href="classOGRProxiedLayer.html#a32442182b76b9370663537bd940e0e91">OGRProxiedLayer</a>, and <a class="el" href="classOGRMutexedLayer.html#a92f1c6ac2e088c93056a2916b145957d">OGRMutexedLayer</a>.</p>

<p>Referenced by <a class="el" href="classOGRDataSource.html#a42dc7f7f538cd4f083af350722fe53ae">OGRDataSource::CopyLayer()</a>, <a class="el" href="classOGRProxiedLayer.html#a32442182b76b9370663537bd940e0e91">OGRProxiedLayer::CreateField()</a>, and <a class="el" href="classOGRLayerDecorator.html#a8ebcd0484d1c1415876986e3eef5ffeb">OGRLayerDecorator::CreateField()</a>.</p>

</div>
</div>
<a class="anchor" id="af3c68cad279ad80a476c6fb307cf5e48"></a><!-- doxytag: member="OGRLayer::CreateGeomField" ref="af3c68cad279ad80a476c6fb307cf5e48" args="(OGRGeomFieldDefn *poField, int bApproxOK=TRUE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRLayer::CreateGeomField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRGeomFieldDefn.html">OGRGeomFieldDefn</a> *&nbsp;</td>
          <td class="paramname"> <em>poField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bApproxOK</em> = <code>TRUE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new geometry field on a layer. </p>
<p>You must use this to create new geometry fields on a real layer. Internally the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> for the layer will be updated to reflect the new field. Applications should never modify the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> used by a layer directly.</p>
<p>This method should not be called while there are feature objects in existance that were obtained or created with the previous layer definition.</p>
<p>Not all drivers support this method. You can query a layer to check if it supports it with the OLCCreateGeomField capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existings features of the backing file/database should be updated accordingly.</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#af6908931c4f3ad364fef8d6e831363bc" title="Create a new geometry field on a layer.">OGR_L_CreateGeomField()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poField</em>&nbsp;</td><td>geometry field definition to write to disk. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bApproxOK</em>&nbsp;</td><td>If TRUE, the field may be created in a slightly different form depending on the limitations of the format driver.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE on success.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.11 </dd></dl>

<p>Referenced by <a class="el" href="classOGRDataSource.html#a42dc7f7f538cd4f083af350722fe53ae">OGRDataSource::CopyLayer()</a>.</p>

</div>
</div>
<a class="anchor" id="a7e3d454d54a615a1b4359628bb6e7674"></a><!-- doxytag: member="OGRLayer::DeleteFeature" ref="a7e3d454d54a615a1b4359628bb6e7674" args="(long nFID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRLayer::DeleteFeature </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nFID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete feature from layer. </p>
<p>The feature with the indicated feature id is deleted from the layer if supported by the driver. Most drivers do not support feature deletion, and will return OGRERR_UNSUPPORTED_OPERATION. The <a class="el" href="classOGRLayer.html#aeedbda1a62f9b89b8e5f24332cf22286" title="Test if this layer supported the named capability.">TestCapability()</a> layer method may be called with OLCDeleteFeature to check if the driver supports feature deletion.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a3525cc8e47db48f8968605d3f2d9a41a" title="Delete feature from layer.">OGR_L_DeleteFeature()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nFID</em>&nbsp;</td><td>the feature id to be deleted from the layer</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE on success. </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRLayerDecorator.html#ae39211b0650811eb8353d4d9bc69dea2">OGRLayerDecorator</a>, <a class="el" href="classOGRProxiedLayer.html#ac4c61439ed83f002efd36226a07ee703">OGRProxiedLayer</a>, and <a class="el" href="classOGRMutexedLayer.html#a39ad2cb471f07a7644f398521fc43e20">OGRMutexedLayer</a>.</p>

<p>Referenced by <a class="el" href="classOGRProxiedLayer.html#ac4c61439ed83f002efd36226a07ee703">OGRProxiedLayer::DeleteFeature()</a>, and <a class="el" href="classOGRLayerDecorator.html#ae39211b0650811eb8353d4d9bc69dea2">OGRLayerDecorator::DeleteFeature()</a>.</p>

</div>
</div>
<a class="anchor" id="aaebe7c671dca995549543eecf0f7a76a"></a><!-- doxytag: member="OGRLayer::DeleteField" ref="aaebe7c671dca995549543eecf0f7a76a" args="(int iField)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRLayer::DeleteField </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iField</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete an existing field on a layer. </p>
<p>You must use this to delete existing fields on a real layer. Internally the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> for the layer will be updated to reflect the deleted field. Applications should never modify the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> used by a layer directly.</p>
<p>This method should not be called while there are feature objects in existance that were obtained or created with the previous layer definition.</p>
<p>Not all drivers support this method. You can query a layer to check if it supports it with the OLCDeleteField capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existings features of the backing file/database should be updated accordingly.</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#afc861413683418eba5d31e487da2f9e2" title="Create a new field on a layer.">OGR_L_DeleteField()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iField</em>&nbsp;</td><td>index of the field to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE on success.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.9.0 </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRLayerDecorator.html#a588e4099ae87e9afd94d014a6964aecf">OGRLayerDecorator</a>, <a class="el" href="classOGRProxiedLayer.html#aa3bf00a32cfffc9ebd481fec553ab769">OGRProxiedLayer</a>, and <a class="el" href="classOGRMutexedLayer.html#a3c80f872eeeb5ee8e6e516221c55c4bb">OGRMutexedLayer</a>.</p>

<p>Referenced by <a class="el" href="classOGRProxiedLayer.html#aa3bf00a32cfffc9ebd481fec553ab769">OGRProxiedLayer::DeleteField()</a>, and <a class="el" href="classOGRLayerDecorator.html#a588e4099ae87e9afd94d014a6964aecf">OGRLayerDecorator::DeleteField()</a>.</p>

</div>
</div>
<a class="anchor" id="a2271d53f75d4f6ff2f4a8aeb71e825d6"></a><!-- doxytag: member="OGRLayer::Dereference" ref="a2271d53f75d4f6ff2f4a8aeb71e825d6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRLayer::Dereference </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decrement layer reference count. </p>
<p>This method is the same as the C function OGR_L_Dereference().</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the reference count after decrementing. </dd></dl>

</div>
</div>
<a class="anchor" id="ae8fcf55ffa259f32df35edcb05274439"></a><!-- doxytag: member="OGRLayer::Erase" ref="ae8fcf55ffa259f32df35edcb05274439" args="(OGRLayer *pLayerMethod, OGRLayer *pLayerResult, char **papszOptions=NULL, GDALProgressFunc pfnProgress=NULL, void *pProgressArg=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRLayer::Erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRLayer.html">OGRLayer</a> *&nbsp;</td>
          <td class="paramname"> <em>pLayerMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRLayer.html">OGRLayer</a> *&nbsp;</td>
          <td class="paramname"> <em>pLayerResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszOptions</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&nbsp;</td>
          <td class="paramname"> <em>pfnProgress</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pProgressArg</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove areas that are covered by the method layer. </p>
<p>The result layer contains features whose geometries represent areas that are in the input layer but not in the method layer. The features in the result layer have attributes from the input layer. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in the input layer.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</dd>
<dd>
This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</dd></dl>
<p>The recognized list of options is : </p>
<ul>
<li>
SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted. </li>
<li>
PROMOTE_TO_MULTI=YES/NO. Set it to YES to convert Polygons into MultiPolygons, or LineStrings to MultiLineStrings. </li>
<li>
INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer. </li>
<li>
METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer. </li>
</ul>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a0f8c47bbeae70e609f4e51a239784285" title="Remove areas that are covered by the method layer.">OGR_L_Erase()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pLayerMethod</em>&nbsp;</td><td>the method layer. Should not be NULL.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pLayerResult</em>&nbsp;</td><td>the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>papszOptions</em>&nbsp;</td><td>NULL terminated list of options (may be NULL).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnProgress</em>&nbsp;</td><td>a GDALProgressFunc() compatible callback function for reporting progress or NULL.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pProgressArg</em>&nbsp;</td><td>argument to be passed to pfnProgress. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.10 </dd></dl>

<p>References <a class="el" href="classOGRGeometry.html#af4cf9f6eee1997268a481b39401c3161">OGRGeometry::clone()</a>, <a class="el" href="classOGRLayer.html#aaa1e32016f481596a55e1d988a15a067">CreateFeature()</a>, <a class="el" href="classOGRGeometry.html#ac92e1ca0e8b108ee920147d4894bde3a">OGRGeometry::Difference()</a>, <a class="el" href="classOGRLayer.html#a74c796d4ce712e9a78df6042eeb8a91a">GetFeatureCount()</a>, <a class="el" href="classOGRFeature.html#acc966ce8c10ae3ddf9f14c2736fdce9a">OGRFeature::GetGeometryRef()</a>, <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf">GetLayerDefn()</a>, <a class="el" href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6">GetNextFeature()</a>, <a class="el" href="classOGRGeometryFactory.html#a04998dcdbb37aa37871891593c048544">OGRGeometryFactory::haveGEOS()</a>, <a class="el" href="classOGRGeometry.html#ac8653ba97e53f3e3b041946ca2acc111">OGRGeometry::IsEmpty()</a>, <a class="el" href="classOGRLayer.html#aad0f2cd7f0587584b8f382c6a913583c">ResetReading()</a>, <a class="el" href="classOGRFeature.html#a6705e5ff8b1012ce4a687b973ecddf73">OGRFeature::SetFieldsFrom()</a>, <a class="el" href="classOGRFeature.html#a40a4ddb33f09a5f340b9139be72e277d">OGRFeature::SetGeometryDirectly()</a>, <a class="el" href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169">SetSpatialFilter()</a>, and <a class="el" href="classOGRGeometry.html#a15fb98d101f5887f7c3af40b6da5a3c4">OGRGeometry::Union()</a>.</p>

</div>
</div>
<a class="anchor" id="aef41bcd7adad1ac5ddcef54d6b38713c"></a><!-- doxytag: member="OGRLayer::FindFieldIndex" ref="aef41bcd7adad1ac5ddcef54d6b38713c" args="(const char *pszFieldName, int bExactMatch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRLayer::FindFieldIndex </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszFieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bExactMatch</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the index of field in the layer. </p>
<p>The returned number is the index of the field in the layers, or -1 if the field doesn't exist.</p>
<p>If bExactMatch is set to FALSE and the field doesn't exists in the given form the driver might apply some changes to make it match, like those it might do if the layer was created (eg. like LAUNDER in the OCI driver).</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#affc3cef62be82ec4f811a89b1855cbd5" title="Find the index of field in a layer.">OGR_L_FindFieldIndex()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>field index, or -1 if the field doesn't exist </dd></dl>

<p>References <a class="el" href="classOGRFeatureDefn.html#a4f7111e4c818f194932795e9c9593258">OGRFeatureDefn::GetFieldIndex()</a>, and <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf">GetLayerDefn()</a>.</p>

</div>
</div>
<a class="anchor" id="a3be658ddb5b33d1ed95c31286774bbd2"></a><!-- doxytag: member="OGRLayer::GetExtent" ref="a3be658ddb5b33d1ed95c31286774bbd2" args="(OGREnvelope *psExtent, int bForce=TRUE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRLayer::GetExtent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGREnvelope.html">OGREnvelope</a> *&nbsp;</td>
          <td class="paramname"> <em>psExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bForce</em> = <code>TRUE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch the extent of this layer. </p>
<p>Returns the extent (MBR) of the data in the layer. If bForce is FALSE, and it would be expensive to establish the extent then OGRERR_FAILURE will be returned indicating that the extent isn't know. If bForce is TRUE then some implementations will actually scan the entire layer once to compute the MBR of all the features in the layer.</p>
<p>Depending on the drivers, the returned extent may or may not take the spatial filter into account. So it is safer to call <a class="el" href="classOGRLayer.html#a3be658ddb5b33d1ed95c31286774bbd2" title="Fetch the extent of this layer.">GetExtent()</a> without setting a spatial filter.</p>
<p>Layers without any geometry may return OGRERR_FAILURE just indicating that no meaningful extents could be collected.</p>
<p>Note that some implementations of this method may alter the read cursor of the layer.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#aa6c495581900c8301dff91d8cd3ee12f" title="Fetch the extent of this layer.">OGR_L_GetExtent()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psExtent</em>&nbsp;</td><td>the structure in which the extent value will be returned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bForce</em>&nbsp;</td><td>Flag indicating whether the extent should be computed even if it is expensive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE on success, OGRERR_FAILURE if extent not known. </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRGenSQLResultsLayer.html#a06a5154cb72668f0617b7c256e260058">OGRGenSQLResultsLayer</a>, <a class="el" href="classOGRLayerDecorator.html#a69c5f6f2aea9cace5d50ef26b34447ad">OGRLayerDecorator</a>, <a class="el" href="classOGRProxiedLayer.html#ae9c4c498bf23d215610f7ef3ec1c7512">OGRProxiedLayer</a>, <a class="el" href="classOGRMutexedLayer.html#a69d4d90ea1ebcfb919cf238e273b6599">OGRMutexedLayer</a>, <a class="el" href="classOGRUnionLayer.html#a3c80b4bddf35c4951b307929fa17228e">OGRUnionLayer</a>, and <a class="el" href="classOGRWarpedLayer.html#aec43822af12dba6874618c493da11fd0">OGRWarpedLayer</a>.</p>

<p>Referenced by <a class="el" href="classOGRWarpedLayer.html#ad8e9852587d5a152d7459e8dc5eb86e5">OGRWarpedLayer::GetExtent()</a>, <a class="el" href="classOGRProxiedLayer.html#a87f961455ded9bf56618d1cf441bcec2">OGRProxiedLayer::GetExtent()</a>, <a class="el" href="classOGRLayerDecorator.html#a69c5f6f2aea9cace5d50ef26b34447ad">OGRLayerDecorator::GetExtent()</a>, <a class="el" href="classOGRLayer.html#a47a3cc550866eee1668bea2315f9df9c">GetExtent()</a>, <a class="el" href="classOGRGenSQLResultsLayer.html#ae87f2d161fbaf14f684a3baeef95e187">OGRGenSQLResultsLayer::GetExtent()</a>, and <a class="el" href="classOGRLayer.html#ac189f54996c2d6fd769889ec99e0f48a">Intersection()</a>.</p>

</div>
</div>
<a class="anchor" id="a47a3cc550866eee1668bea2315f9df9c"></a><!-- doxytag: member="OGRLayer::GetExtent" ref="a47a3cc550866eee1668bea2315f9df9c" args="(int iGeomField, OGREnvelope *psExtent, int bForce=TRUE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRLayer::GetExtent </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iGeomField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGREnvelope.html">OGREnvelope</a> *&nbsp;</td>
          <td class="paramname"> <em>psExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bForce</em> = <code>TRUE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch the extent of this layer, on the specified geometry field. </p>
<p>Returns the extent (MBR) of the data in the layer. If bForce is FALSE, and it would be expensive to establish the extent then OGRERR_FAILURE will be returned indicating that the extent isn't know. If bForce is TRUE then some implementations will actually scan the entire layer once to compute the MBR of all the features in the layer.</p>
<p>Depending on the drivers, the returned extent may or may not take the spatial filter into account. So it is safer to call <a class="el" href="classOGRLayer.html#a3be658ddb5b33d1ed95c31286774bbd2" title="Fetch the extent of this layer.">GetExtent()</a> without setting a spatial filter.</p>
<p>Layers without any geometry may return OGRERR_FAILURE just indicating that no meaningful extents could be collected.</p>
<p>Note that some implementations of this method may alter the read cursor of the layer.</p>
<p>Note to driver implementators: if you implement <a class="el" href="classOGRLayer.html#a47a3cc550866eee1668bea2315f9df9c" title="Fetch the extent of this layer, on the specified geometry field.">GetExtent(int,OGREnvelope*,int)</a>, you must also implement <a class="el" href="classOGRLayer.html#a3be658ddb5b33d1ed95c31286774bbd2" title="Fetch the extent of this layer.">GetExtent(OGREnvelope*, int)</a> to make it call GetExtent(0,OGREnvelope*,int).</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ac3dbfd4443c80dca0d93574f0c00d376" title="Fetch the extent of this layer, on the specified geometry field.">OGR_L_GetExtentEx()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iGeomField</em>&nbsp;</td><td>the index of the geometry field on which to compute the extent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>psExtent</em>&nbsp;</td><td>the structure in which the extent value will be returned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bForce</em>&nbsp;</td><td>Flag indicating whether the extent should be computed even if it is expensive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE on success, OGRERR_FAILURE if extent not known. </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRGenSQLResultsLayer.html#ae87f2d161fbaf14f684a3baeef95e187">OGRGenSQLResultsLayer</a>, <a class="el" href="classOGRLayerDecorator.html#a6e3e29276855a7bd0d7f72c0c0dae38f">OGRLayerDecorator</a>, <a class="el" href="classOGRProxiedLayer.html#a87f961455ded9bf56618d1cf441bcec2">OGRProxiedLayer</a>, <a class="el" href="classOGRMutexedLayer.html#ad7fe1ffa98644c88c04fa8988d1a9044">OGRMutexedLayer</a>, <a class="el" href="classOGRUnionLayer.html#a36e1634fb7f68fae343179a6007960c4">OGRUnionLayer</a>, and <a class="el" href="classOGRWarpedLayer.html#ad8e9852587d5a152d7459e8dc5eb86e5">OGRWarpedLayer</a>.</p>

<p>References <a class="el" href="classOGRLayer.html#a3be658ddb5b33d1ed95c31286774bbd2">GetExtent()</a>.</p>

</div>
</div>
<a class="anchor" id="acb7625383f161e5a04aeea2173dce411"></a><!-- doxytag: member="OGRLayer::GetFeature" ref="acb7625383f161e5a04aeea2173dce411" args="(long nFID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRFeature.html">OGRFeature</a> * OGRLayer::GetFeature </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nFID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch a feature by its identifier. </p>
<p>This function will attempt to read the identified feature. The nFID value cannot be OGRNullFID. Success or failure of this operation is unaffected by the spatial or attribute filters (and specialized implementations in drivers should make sure that they do not take into account spatial or attribute filters).</p>
<p>If this method returns a non-NULL feature, it is guaranteed that its feature id (<a class="el" href="classOGRFeature.html#a23506b436ea8e88e65aaa6b57bbaa326" title="Get feature identifier.">OGRFeature::GetFID()</a>) will be the same as nFID.</p>
<p>Use OGRLayer::TestCapability(OLCRandomRead) to establish if this layer supports efficient random access reading via <a class="el" href="classOGRLayer.html#acb7625383f161e5a04aeea2173dce411" title="Fetch a feature by its identifier.">GetFeature()</a>; however, the call should always work if the feature exists as a fallback implementation just scans all the features in the layer looking for the desired feature.</p>
<p>Sequential reads (with <a class="el" href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6" title="Fetch the next available feature from this layer.">GetNextFeature()</a>) are generally considered interrupted by a <a class="el" href="classOGRLayer.html#acb7625383f161e5a04aeea2173dce411" title="Fetch a feature by its identifier.">GetFeature()</a> call.</p>
<p>The returned feature should be free with <a class="el" href="classOGRFeature.html#a5d2602d11f21567119da0ca6b6c5ad45" title="Destroy feature.">OGRFeature::DestroyFeature()</a>.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a7c628dce8939904154b50365306b06f9" title="Fetch a feature by its identifier.">OGR_L_GetFeature()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nFID</em>&nbsp;</td><td>the feature id of the feature to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a feature now owned by the caller, or NULL on failure. </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRGenSQLResultsLayer.html#a6c318023a60caf1b681e6519c2e33ba3">OGRGenSQLResultsLayer</a>, <a class="el" href="classOGRLayerDecorator.html#a008d916daf97c3f189160e0f7bff14d5">OGRLayerDecorator</a>, <a class="el" href="classOGRProxiedLayer.html#ab01789462c830d68fab1ac77b4bc47f1">OGRProxiedLayer</a>, <a class="el" href="classOGRMutexedLayer.html#a17ecbcc2d4d31e99629ed325a5bca72b">OGRMutexedLayer</a>, <a class="el" href="classOGRUnionLayer.html#a58427b11107fee76162055092e2364d2">OGRUnionLayer</a>, and <a class="el" href="classOGRWarpedLayer.html#a12521ca826b27601a09f1882f5b7595c">OGRWarpedLayer</a>.</p>

<p>References <a class="el" href="classOGRGeometry.html#af4cf9f6eee1997268a481b39401c3161">OGRGeometry::clone()</a>, <a class="el" href="classOGRFeature.html#a23506b436ea8e88e65aaa6b57bbaa326">OGRFeature::GetFID()</a>, <a class="el" href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6">GetNextFeature()</a>, <a class="el" href="classOGRLayer.html#aad0f2cd7f0587584b8f382c6a913583c">ResetReading()</a>, <a class="el" href="classOGRLayer.html#acb2c6cc5fa3577df5be538284c1b0dde">SetAttributeFilter()</a>, and <a class="el" href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169">SetSpatialFilter()</a>.</p>

<p>Referenced by <a class="el" href="classOGRWarpedLayer.html#a12521ca826b27601a09f1882f5b7595c">OGRWarpedLayer::GetFeature()</a>, <a class="el" href="classOGRUnionLayer.html#a58427b11107fee76162055092e2364d2">OGRUnionLayer::GetFeature()</a>, <a class="el" href="classOGRProxiedLayer.html#ab01789462c830d68fab1ac77b4bc47f1">OGRProxiedLayer::GetFeature()</a>, <a class="el" href="classOGRLayerDecorator.html#a008d916daf97c3f189160e0f7bff14d5">OGRLayerDecorator::GetFeature()</a>, and <a class="el" href="classOGRGenSQLResultsLayer.html#a6c318023a60caf1b681e6519c2e33ba3">OGRGenSQLResultsLayer::GetFeature()</a>.</p>

</div>
</div>
<a class="anchor" id="a74c796d4ce712e9a78df6042eeb8a91a"></a><!-- doxytag: member="OGRLayer::GetFeatureCount" ref="a74c796d4ce712e9a78df6042eeb8a91a" args="(int bForce=TRUE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRLayer::GetFeatureCount </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bForce</em> = <code>TRUE</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch the feature count in this layer. </p>
<p>Returns the number of features in the layer. For dynamic databases the count may not be exact. If bForce is FALSE, and it would be expensive to establish the feature count a value of -1 may be returned indicating that the count isn't know. If bForce is TRUE some implementations will actually scan the entire layer once to count objects.</p>
<p>The returned count takes the spatial filter into account.</p>
<p>Note that some implementations of this method may alter the read cursor of the layer.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#abfbba8f45edd5dc44ced91f9228f9124" title="Fetch the feature count in this layer.">OGR_L_GetFeatureCount()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bForce</em>&nbsp;</td><td>Flag indicating whether the count should be computed even if it is expensive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>feature count, -1 if count not known. </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRGenSQLResultsLayer.html#a2c4e8ba237574531b8ccd6c2348f89ff">OGRGenSQLResultsLayer</a>, <a class="el" href="classOGRLayerDecorator.html#aef9e1920c4733164e5ba053ca08cb8cb">OGRLayerDecorator</a>, <a class="el" href="classOGRProxiedLayer.html#a7ab6742363ee651f9249665a79b486f2">OGRProxiedLayer</a>, <a class="el" href="classOGRMutexedLayer.html#abd804a230e77a945a578d56775afdb50">OGRMutexedLayer</a>, <a class="el" href="classOGRUnionLayer.html#a6f9c4f51181cb7db75b08a6b81182e67">OGRUnionLayer</a>, and <a class="el" href="classOGRWarpedLayer.html#a33fd195fa410c173fe4d04f65deddac0">OGRWarpedLayer</a>.</p>

<p>References <a class="el" href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6">GetNextFeature()</a>, and <a class="el" href="classOGRLayer.html#aad0f2cd7f0587584b8f382c6a913583c">ResetReading()</a>.</p>

<p>Referenced by <a class="el" href="classOGRLayer.html#a56d7ee3b2020e53c730d67ee4f1e2fb6">Clip()</a>, <a class="el" href="classOGRLayer.html#ae8fcf55ffa259f32df35edcb05274439">Erase()</a>, <a class="el" href="classOGRWarpedLayer.html#a33fd195fa410c173fe4d04f65deddac0">OGRWarpedLayer::GetFeatureCount()</a>, <a class="el" href="classOGRUnionLayer.html#a6f9c4f51181cb7db75b08a6b81182e67">OGRUnionLayer::GetFeatureCount()</a>, <a class="el" href="classOGRProxiedLayer.html#a7ab6742363ee651f9249665a79b486f2">OGRProxiedLayer::GetFeatureCount()</a>, <a class="el" href="classOGRLayerDecorator.html#aef9e1920c4733164e5ba053ca08cb8cb">OGRLayerDecorator::GetFeatureCount()</a>, <a class="el" href="classOGRGenSQLResultsLayer.html#a2c4e8ba237574531b8ccd6c2348f89ff">OGRGenSQLResultsLayer::GetFeatureCount()</a>, <a class="el" href="classOGRLayer.html#acac6a0bde9737555b22c6ac7fa967431">Identity()</a>, <a class="el" href="classOGRLayer.html#ac189f54996c2d6fd769889ec99e0f48a">Intersection()</a>, <a class="el" href="classOGRLayer.html#a781aa76c6b44b19de09f61816e32245b">SymDifference()</a>, <a class="el" href="classOGRLayer.html#aeb8ab475561f2aca2c0e605cfb810b22">Union()</a>, and <a class="el" href="classOGRLayer.html#aa1c5dc5ca195956c46d35a85b0b21d9b">Update()</a>.</p>

</div>
</div>
<a class="anchor" id="af0cb9a05310d7b17d9dfec9e83a18e61"></a><!-- doxytag: member="OGRLayer::GetFIDColumn" ref="af0cb9a05310d7b17d9dfec9e83a18e61" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * OGRLayer::GetFIDColumn </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method returns the name of the underlying database column being used as the FID column, or "" if not supported. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#abfeb6e1258f113c6c45c8d6a43c8cfa5" title="This method returns the name of the underlying database column being used as the FID column...">OGR_L_GetFIDColumn()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>fid column name. </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRLayerDecorator.html#aa6844a664eb25e384b792665158691bb">OGRLayerDecorator</a>, <a class="el" href="classOGRProxiedLayer.html#a3aba9058916b6d177b7a2be95c81811c">OGRProxiedLayer</a>, and <a class="el" href="classOGRMutexedLayer.html#a51c6f151a8bbde1521e723fcdc521197">OGRMutexedLayer</a>.</p>

<p>Referenced by <a class="el" href="classOGRProxiedLayer.html#a3aba9058916b6d177b7a2be95c81811c">OGRProxiedLayer::GetFIDColumn()</a>, and <a class="el" href="classOGRLayerDecorator.html#aa6844a664eb25e384b792665158691bb">OGRLayerDecorator::GetFIDColumn()</a>.</p>

</div>
</div>
<a class="anchor" id="af68036c23622c954ce3a91861f22b724"></a><!-- doxytag: member="OGRLayer::GetGeometryColumn" ref="af68036c23622c954ce3a91861f22b724" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * OGRLayer::GetGeometryColumn </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method returns the name of the underlying database column being used as the geometry column, or "" if not supported. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ab060e07e277cebd1d8504c449d97b29f" title="This method returns the name of the underlying database column being used as the geometry column...">OGR_L_GetGeometryColumn()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>geometry column name. </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRLayerDecorator.html#a2a0c4fb535bf4d6bbf31f6370e18274d">OGRLayerDecorator</a>, <a class="el" href="classOGRProxiedLayer.html#ad1113d8b08e5ff2194593daabfdf5497">OGRProxiedLayer</a>, and <a class="el" href="classOGRMutexedLayer.html#aab0f7af29c53c51a1d13c5d676dbe8ed">OGRMutexedLayer</a>.</p>

<p>References <a class="el" href="classOGRFeatureDefn.html#acacca3de3718ae525565e5130b5474dc">OGRFeatureDefn::GetGeomFieldDefn()</a>, <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf">GetLayerDefn()</a>, and <a class="el" href="classOGRGeomFieldDefn.html#a8dbbb2a2630752eda8702cd4196ed4c6">OGRGeomFieldDefn::GetNameRef()</a>.</p>

<p>Referenced by <a class="el" href="classOGRProxiedLayer.html#ad1113d8b08e5ff2194593daabfdf5497">OGRProxiedLayer::GetGeometryColumn()</a>, and <a class="el" href="classOGRLayerDecorator.html#a2a0c4fb535bf4d6bbf31f6370e18274d">OGRLayerDecorator::GetGeometryColumn()</a>.</p>

</div>
</div>
<a class="anchor" id="a818a25520ce08d5a681443348e930604"></a><!-- doxytag: member="OGRLayer::GetGeomType" ref="a818a25520ce08d5a681443348e930604" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a> OGRLayer::GetGeomType </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the layer geometry type. </p>
<p>This returns the same result as <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">GetLayerDefn()</a>-&gt;<a class="el" href="classOGRLayer.html#a818a25520ce08d5a681443348e930604" title="Return the layer geometry type.">GetGeomType()</a>, but for a few drivers, calling <a class="el" href="classOGRLayer.html#a818a25520ce08d5a681443348e930604" title="Return the layer geometry type.">GetGeomType()</a> directly can avoid lengthy layer definition initialization.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a0adea8ce1ca795ce0a6a76505f90f078" title="Return the layer geometry type.">OGR_L_GetGeomType()</a>.</p>
<p>If this method is derived in a driver, it must be done such that it returns the same content as <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">GetLayerDefn()</a>-&gt;<a class="el" href="classOGRLayer.html#a818a25520ce08d5a681443348e930604" title="Return the layer geometry type.">GetGeomType()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the geometry type </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.8.0 </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRLayerDecorator.html#ab1cec0e60127cafffbbfca7c969081ac">OGRLayerDecorator</a>, <a class="el" href="classOGRProxiedLayer.html#ab6b86557544c5336ec1d408187a4db1f">OGRProxiedLayer</a>, <a class="el" href="classOGRMutexedLayer.html#a235b670a8457d48002ab88e10e403f9a">OGRMutexedLayer</a>, and <a class="el" href="classOGRUnionLayer.html#a11d7365a8f7264b0cc0bfc3cd371aac7">OGRUnionLayer</a>.</p>

<p>References <a class="el" href="classOGRFeatureDefn.html#a81a7dc7ed24fe9f2634bf447d1799e84">OGRFeatureDefn::GetGeomType()</a>, and <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf">GetLayerDefn()</a>.</p>

<p>Referenced by <a class="el" href="classOGRProxiedLayer.html#ab6b86557544c5336ec1d408187a4db1f">OGRProxiedLayer::GetGeomType()</a>, and <a class="el" href="classOGRLayerDecorator.html#ab1cec0e60127cafffbbfca7c969081ac">OGRLayerDecorator::GetGeomType()</a>.</p>

</div>
</div>
<a class="anchor" id="a143b0d2c48bc0adf3a19d1f51e76b8ba"></a><!-- doxytag: member="OGRLayer::GetInfo" ref="a143b0d2c48bc0adf3a19d1f51e76b8ba" args="(const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * OGRLayer::GetInfo </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszTag</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch metadata from layer. </p>
<p>This method can be used to fetch various kinds of metadata or layer specific information encoded as a string. It is anticipated that various tag values will be defined with well known semantics, while other tags will be used for driver/application specific purposes.</p>
<p>This method is deprecated and will be replaced with a more general metadata model in the future. At this time no drivers return information via the <a class="el" href="classOGRLayer.html#a143b0d2c48bc0adf3a19d1f51e76b8ba" title="Fetch metadata from layer.">GetInfo()</a> call.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszTag</em>&nbsp;</td><td>the tag for which information is being requested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the value of the requested tag, or NULL if that tag does not have a value, or is unknown.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000008">Deprecated:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a80473bcfd11341e70dd35bebe94026cf"></a><!-- doxytag: member="OGRLayer::GetLayerDefn" ref="a80473bcfd11341e70dd35bebe94026cf" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> * OGRLayer::GetLayerDefn </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch the schema information for this layer. </p>
<p>The returned <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> is owned by the <a class="el" href="classOGRLayer.html">OGRLayer</a>, and should not be modified or freed by the application. It encapsulates the attribute schema of the features of the layer.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a7b67ea4ab5892c6720460dc7f66eca2d" title="Fetch the schema information for this layer.">OGR_L_GetLayerDefn()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>feature definition. </dd></dl>

<p>Implemented in <a class="el" href="classOGRGenSQLResultsLayer.html#a00f2d89533fda930ed263413ef5b140c">OGRGenSQLResultsLayer</a>, <a class="el" href="classOGRLayerDecorator.html#a6cb57d19416c9eb4d9c1615282b498d1">OGRLayerDecorator</a>, <a class="el" href="classOGRProxiedLayer.html#a27d1b3cd7effe7c17b4f3ab211b029ca">OGRProxiedLayer</a>, <a class="el" href="classOGRMutexedLayer.html#ad842cc7d620591e7c0149d27f2892105">OGRMutexedLayer</a>, <a class="el" href="classOGRUnionLayer.html#a4c680d7e5c02454ea7361f341d6d54e9">OGRUnionLayer</a>, and <a class="el" href="classOGRWarpedLayer.html#aba232ed7807f305b9ed4e56af9e370ec">OGRWarpedLayer</a>.</p>

<p>Referenced by <a class="el" href="classOGRLayer.html#a56d7ee3b2020e53c730d67ee4f1e2fb6">Clip()</a>, <a class="el" href="classOGRSFDriver.html#a0b1f2c7944603bebac2dab96d1fee7c5">OGRSFDriver::CopyDataSource()</a>, <a class="el" href="classOGRDataSource.html#a42dc7f7f538cd4f083af350722fe53ae">OGRDataSource::CopyLayer()</a>, <a class="el" href="classOGRLayer.html#ae8fcf55ffa259f32df35edcb05274439">Erase()</a>, <a class="el" href="classOGRLayer.html#aef41bcd7adad1ac5ddcef54d6b38713c">FindFieldIndex()</a>, <a class="el" href="classOGRUnionLayer.html#a36e1634fb7f68fae343179a6007960c4">OGRUnionLayer::GetExtent()</a>, <a class="el" href="classOGRLayer.html#af68036c23622c954ce3a91861f22b724">GetGeometryColumn()</a>, <a class="el" href="classOGRLayer.html#a818a25520ce08d5a681443348e930604">GetGeomType()</a>, <a class="el" href="classOGRWarpedLayer.html#aba232ed7807f305b9ed4e56af9e370ec">OGRWarpedLayer::GetLayerDefn()</a>, <a class="el" href="classOGRUnionLayer.html#a4c680d7e5c02454ea7361f341d6d54e9">OGRUnionLayer::GetLayerDefn()</a>, <a class="el" href="classOGRProxiedLayer.html#a27d1b3cd7effe7c17b4f3ab211b029ca">OGRProxiedLayer::GetLayerDefn()</a>, <a class="el" href="classOGRLayerDecorator.html#a6cb57d19416c9eb4d9c1615282b498d1">OGRLayerDecorator::GetLayerDefn()</a>, <a class="el" href="classOGRLayer.html#a287f5ec7728cacc2f7d94882a9f1a22e">GetName()</a>, <a class="el" href="classOGRLayer.html#a75c06b4993f8eb76b569f37365cd19ab">GetSpatialRef()</a>, <a class="el" href="classOGRLayer.html#acac6a0bde9737555b22c6ac7fa967431">Identity()</a>, <a class="el" href="classOGRLayer.html#ac189f54996c2d6fd769889ec99e0f48a">Intersection()</a>, <a class="el" href="classOGRLayer.html#ab4c02b991bfa78552eeb0cbcdcf1aed8">ReorderField()</a>, <a class="el" href="classOGRLayer.html#acb2c6cc5fa3577df5be538284c1b0dde">SetAttributeFilter()</a>, <a class="el" href="classOGRLayer.html#a5e0c3427f64249d1c35cefb487546b10">SetIgnoredFields()</a>, <a class="el" href="classOGRLayer.html#aebac60fb86ee178be016655532070ee3">SetSpatialFilter()</a>, <a class="el" href="classOGRLayer.html#a781aa76c6b44b19de09f61816e32245b">SymDifference()</a>, <a class="el" href="classOGRLayer.html#aeb8ab475561f2aca2c0e605cfb810b22">Union()</a>, and <a class="el" href="classOGRLayer.html#aa1c5dc5ca195956c46d35a85b0b21d9b">Update()</a>.</p>

</div>
</div>
<a class="anchor" id="a287f5ec7728cacc2f7d94882a9f1a22e"></a><!-- doxytag: member="OGRLayer::GetName" ref="a287f5ec7728cacc2f7d94882a9f1a22e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * OGRLayer::GetName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the layer name. </p>
<p>This returns the same content as <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">GetLayerDefn()</a>-&gt;<a class="el" href="classOGRLayer.html#a287f5ec7728cacc2f7d94882a9f1a22e" title="Return the layer name.">GetName()</a>, but for a few drivers, calling <a class="el" href="classOGRLayer.html#a287f5ec7728cacc2f7d94882a9f1a22e" title="Return the layer name.">GetName()</a> directly can avoid lengthy layer definition initialization.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a88facf4f8e8b32278101d52ae094255c" title="Return the layer name.">OGR_L_GetName()</a>.</p>
<p>If this method is derived in a driver, it must be done such that it returns the same content as <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">GetLayerDefn()</a>-&gt;<a class="el" href="classOGRLayer.html#a287f5ec7728cacc2f7d94882a9f1a22e" title="Return the layer name.">GetName()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the layer name (must not been freed) </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.8.0 </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRLayerDecorator.html#a97686a6ef8e461caf74cf624e02b49f9">OGRLayerDecorator</a>, <a class="el" href="classOGRProxiedLayer.html#ae159821d1b4b5cd5454f2c40dee9f843">OGRProxiedLayer</a>, <a class="el" href="classOGRMutexedLayer.html#aa7a1e5652e760500cb5017669299e1ea">OGRMutexedLayer</a>, and <a class="el" href="classOGRUnionLayer.html#a530eaa40528ad609ae506336103fbedf">OGRUnionLayer</a>.</p>

<p>References <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf">GetLayerDefn()</a>, and <a class="el" href="classOGRFeatureDefn.html#a1efe6db724bb1c5fde13e5f3896e4a01">OGRFeatureDefn::GetName()</a>.</p>

<p>Referenced by <a class="el" href="classOGRDataSource.html#aa0fafafc83084ad140ecdf17d9e139f9">OGRDataSource::GetLayerByName()</a>, <a class="el" href="classOGRProxiedLayer.html#ae159821d1b4b5cd5454f2c40dee9f843">OGRProxiedLayer::GetName()</a>, and <a class="el" href="classOGRLayerDecorator.html#a97686a6ef8e461caf74cf624e02b49f9">OGRLayerDecorator::GetName()</a>.</p>

</div>
</div>
<a class="anchor" id="a47d21ff33b32d14fa4e9885b9edecad6"></a><!-- doxytag: member="OGRLayer::GetNextFeature" ref="a47d21ff33b32d14fa4e9885b9edecad6" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRFeature.html">OGRFeature</a> * OGRLayer::GetNextFeature </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch the next available feature from this layer. </p>
<p>The returned feature becomes the responsiblity of the caller to delete with <a class="el" href="classOGRFeature.html#a5d2602d11f21567119da0ca6b6c5ad45" title="Destroy feature.">OGRFeature::DestroyFeature()</a>. It is critical that all features associated with an <a class="el" href="classOGRLayer.html">OGRLayer</a> (more specifically an <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a>) be deleted before that layer/datasource is deleted.</p>
<p>Only features matching the current spatial filter (set with <a class="el" href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169" title="Set a new spatial filter.">SetSpatialFilter()</a>) will be returned.</p>
<p>This method implements sequential access to the features of a layer. The <a class="el" href="classOGRLayer.html#aad0f2cd7f0587584b8f382c6a913583c" title="Reset feature reading to start on the first feature.">ResetReading()</a> method can be used to start at the beginning again.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a6708c067521ab7b7f9c4ec0ebe221b5b" title="Fetch the next available feature from this layer.">OGR_L_GetNextFeature()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a feature, or NULL if no more features are available. </dd></dl>

<p>Implemented in <a class="el" href="classOGRGenSQLResultsLayer.html#a017e409c228f5182bd71bb0053206496">OGRGenSQLResultsLayer</a>, <a class="el" href="classOGRLayerDecorator.html#a5d1edbecca464827511bd7a34b862529">OGRLayerDecorator</a>, <a class="el" href="classOGRProxiedLayer.html#ae651eef82b8490571b6d1b4e13e8ab86">OGRProxiedLayer</a>, <a class="el" href="classOGRMutexedLayer.html#a374128e0f80a2c7872e6e916dae1278c">OGRMutexedLayer</a>, <a class="el" href="classOGRUnionLayer.html#a1ff231230bc51b63952c49fbf565d2b8">OGRUnionLayer</a>, and <a class="el" href="classOGRWarpedLayer.html#a7d55012a49484e77ef06246597736c09">OGRWarpedLayer</a>.</p>

<p>Referenced by <a class="el" href="classOGRLayer.html#a56d7ee3b2020e53c730d67ee4f1e2fb6">Clip()</a>, <a class="el" href="classOGRDataSource.html#a42dc7f7f538cd4f083af350722fe53ae">OGRDataSource::CopyLayer()</a>, <a class="el" href="classOGRLayer.html#ae8fcf55ffa259f32df35edcb05274439">Erase()</a>, <a class="el" href="classOGRLayer.html#acb7625383f161e5a04aeea2173dce411">GetFeature()</a>, <a class="el" href="classOGRLayer.html#a74c796d4ce712e9a78df6042eeb8a91a">GetFeatureCount()</a>, <a class="el" href="classOGRWarpedLayer.html#a7d55012a49484e77ef06246597736c09">OGRWarpedLayer::GetNextFeature()</a>, <a class="el" href="classOGRUnionLayer.html#a1ff231230bc51b63952c49fbf565d2b8">OGRUnionLayer::GetNextFeature()</a>, <a class="el" href="classOGRProxiedLayer.html#ae651eef82b8490571b6d1b4e13e8ab86">OGRProxiedLayer::GetNextFeature()</a>, <a class="el" href="classOGRLayerDecorator.html#a5d1edbecca464827511bd7a34b862529">OGRLayerDecorator::GetNextFeature()</a>, <a class="el" href="classOGRGenSQLResultsLayer.html#a017e409c228f5182bd71bb0053206496">OGRGenSQLResultsLayer::GetNextFeature()</a>, <a class="el" href="classOGRLayer.html#acac6a0bde9737555b22c6ac7fa967431">Identity()</a>, <a class="el" href="classOGRLayer.html#ac189f54996c2d6fd769889ec99e0f48a">Intersection()</a>, <a class="el" href="classOGRLayer.html#ae3b6234d6077a18a19eddaf7e75ff5e1">SetNextByIndex()</a>, <a class="el" href="classOGRLayer.html#a781aa76c6b44b19de09f61816e32245b">SymDifference()</a>, <a class="el" href="classOGRLayer.html#aeb8ab475561f2aca2c0e605cfb810b22">Union()</a>, and <a class="el" href="classOGRLayer.html#aa1c5dc5ca195956c46d35a85b0b21d9b">Update()</a>.</p>

</div>
</div>
<a class="anchor" id="a2fc393bc9962a73e94478b72d9fc4954"></a><!-- doxytag: member="OGRLayer::GetRefCount" ref="a2fc393bc9962a73e94478b72d9fc4954" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRLayer::GetRefCount </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch reference count. </p>
<p>This method is the same as the C function OGR_L_GetRefCount().</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the current reference count for the layer object itself. </dd></dl>

<p>Referenced by <a class="el" href="classOGRDataSource.html#ab7e7f2d617ad3df448d3e8ebaa800a6a">OGRDataSource::GetSummaryRefCount()</a>.</p>

</div>
</div>
<a class="anchor" id="adc3735e444204d46f517eec251712f4d"></a><!-- doxytag: member="OGRLayer::GetSpatialFilter" ref="adc3735e444204d46f517eec251712f4d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRLayer::GetSpatialFilter </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method returns the current spatial filter for this layer. </p>
<p>The returned pointer is to an internally owned object, and should not be altered or deleted by the caller.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a36d61f311c9f8c172ad118659358c60a" title="This function returns the current spatial filter for this layer.">OGR_L_GetSpatialFilter()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>spatial filter geometry. </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRGenSQLResultsLayer.html#a75291ea84d417728630d8fe213956ecb">OGRGenSQLResultsLayer</a>, <a class="el" href="classOGRLayerDecorator.html#ab25905a67ea89683495ccc7fd74579fc">OGRLayerDecorator</a>, <a class="el" href="classOGRProxiedLayer.html#a57e01dc5e66b5498ebaf0f39995b01c1">OGRProxiedLayer</a>, and <a class="el" href="classOGRMutexedLayer.html#ae2e5e834c3959ffc0231c6d9736776d9">OGRMutexedLayer</a>.</p>

<p>Referenced by <a class="el" href="classOGRProxiedLayer.html#a57e01dc5e66b5498ebaf0f39995b01c1">OGRProxiedLayer::GetSpatialFilter()</a>, and <a class="el" href="classOGRLayerDecorator.html#ab25905a67ea89683495ccc7fd74579fc">OGRLayerDecorator::GetSpatialFilter()</a>.</p>

</div>
</div>
<a class="anchor" id="a75c06b4993f8eb76b569f37365cd19ab"></a><!-- doxytag: member="OGRLayer::GetSpatialRef" ref="a75c06b4993f8eb76b569f37365cd19ab" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> * OGRLayer::GetSpatialRef </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch the spatial reference system for this layer. </p>
<p>The returned object is owned by the <a class="el" href="classOGRLayer.html">OGRLayer</a> and should not be modified or freed by the application.</p>
<p>Starting with OGR 1.11, several geometry fields can be associated to a feature definition. Each geometry field can have its own spatial reference system, which is returned by <a class="el" href="classOGRGeomFieldDefn.html#ae043691f36413950ea2ec0c3495ac959" title="Fetch spatial reference system of this field.">OGRGeomFieldDefn::GetSpatialRef()</a>. <a class="el" href="classOGRLayer.html#a75c06b4993f8eb76b569f37365cd19ab" title="Fetch the spatial reference system for this layer.">OGRLayer::GetSpatialRef()</a> is equivalent to <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">GetLayerDefn()</a>-&gt;GetGeomFieldDefn(0)-&gt;<a class="el" href="classOGRLayer.html#a75c06b4993f8eb76b569f37365cd19ab" title="Fetch the spatial reference system for this layer.">GetSpatialRef()</a></p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a8b2a10085f410aa84172eba413408c39" title="Fetch the spatial reference system for this layer.">OGR_L_GetSpatialRef()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>spatial reference, or NULL if there isn't one. </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRLayerDecorator.html#ac9a72ec894519baa3b3e709713cb665f">OGRLayerDecorator</a>, <a class="el" href="classOGRProxiedLayer.html#ae7cd2e00f35e1395d7c12414dc7b300b">OGRProxiedLayer</a>, <a class="el" href="classOGRMutexedLayer.html#a35e7e3246fc1f8db4d0d8826c58927c1">OGRMutexedLayer</a>, <a class="el" href="classOGRUnionLayer.html#a8223e23c723151ef11fba997ab4fc605">OGRUnionLayer</a>, and <a class="el" href="classOGRWarpedLayer.html#a1bf0ab0345277bbf37fe0aba15582164">OGRWarpedLayer</a>.</p>

<p>References <a class="el" href="classOGRFeatureDefn.html#acacca3de3718ae525565e5130b5474dc">OGRFeatureDefn::GetGeomFieldDefn()</a>, <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf">GetLayerDefn()</a>, and <a class="el" href="classOGRGeomFieldDefn.html#ae043691f36413950ea2ec0c3495ac959">OGRGeomFieldDefn::GetSpatialRef()</a>.</p>

<p>Referenced by <a class="el" href="classOGRDataSource.html#a42dc7f7f538cd4f083af350722fe53ae">OGRDataSource::CopyLayer()</a>, <a class="el" href="classOGRUnionLayer.html#a8223e23c723151ef11fba997ab4fc605">OGRUnionLayer::GetSpatialRef()</a>, <a class="el" href="classOGRProxiedLayer.html#ae7cd2e00f35e1395d7c12414dc7b300b">OGRProxiedLayer::GetSpatialRef()</a>, and <a class="el" href="classOGRLayerDecorator.html#ac9a72ec894519baa3b3e709713cb665f">OGRLayerDecorator::GetSpatialRef()</a>.</p>

</div>
</div>
<a class="anchor" id="ac65f762d5b3c6fc4ca0f0cc4aafcdcbe"></a><!-- doxytag: member="OGRLayer::GetStyleTable" ref="ac65f762d5b3c6fc4ca0f0cc4aafcdcbe" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRStyleTable.html">OGRStyleTable</a> * OGRLayer::GetStyleTable </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns layer style table. </p>
<p>This method is the same as the C function OGR_L_GetStyleTable().</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to a style table which should not be modified or freed by the caller. </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRLayerDecorator.html#ab093ab7f9a7d66c97c16232b6035c82a">OGRLayerDecorator</a>, <a class="el" href="classOGRProxiedLayer.html#a517083b125d629c936e57eaec40cb74f">OGRProxiedLayer</a>, and <a class="el" href="classOGRMutexedLayer.html#a83e21757447d5f195f43d92de6d05021">OGRMutexedLayer</a>.</p>

<p>Referenced by <a class="el" href="classOGRProxiedLayer.html#a517083b125d629c936e57eaec40cb74f">OGRProxiedLayer::GetStyleTable()</a>, and <a class="el" href="classOGRLayerDecorator.html#ab093ab7f9a7d66c97c16232b6035c82a">OGRLayerDecorator::GetStyleTable()</a>.</p>

</div>
</div>
<a class="anchor" id="acac6a0bde9737555b22c6ac7fa967431"></a><!-- doxytag: member="OGRLayer::Identity" ref="acac6a0bde9737555b22c6ac7fa967431" args="(OGRLayer *pLayerMethod, OGRLayer *pLayerResult, char **papszOptions=NULL, GDALProgressFunc pfnProgress=NULL, void *pProgressArg=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRLayer::Identity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRLayer.html">OGRLayer</a> *&nbsp;</td>
          <td class="paramname"> <em>pLayerMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRLayer.html">OGRLayer</a> *&nbsp;</td>
          <td class="paramname"> <em>pLayerResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszOptions</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&nbsp;</td>
          <td class="paramname"> <em>pfnProgress</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pProgressArg</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Identify the features of this layer with the ones from the identity layer. </p>
<p>The result layer contains features whose geometries represent areas that are in the input layer. The features in the result layer have attributes from both input and method layers. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in input and method layers.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If the schema of the result is set by user and contains fields that have the same name as a field in input and in method layer, then the attribute in the result feature will get the value from the feature of the method layer (even if it is undefined).</dd>
<dd>
For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</dd>
<dd>
This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</dd></dl>
<p>The recognized list of options is : </p>
<ul>
<li>
SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted. </li>
<li>
PROMOTE_TO_MULTI=YES/NO. Set it to YES to convert Polygons into MultiPolygons, or LineStrings to MultiLineStrings. </li>
<li>
INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer. </li>
<li>
METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer. </li>
</ul>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a67948074f2e2942cebdd0f90bbec8aa9" title="Identify the features of this layer with the ones from the identity layer.">OGR_L_Identity()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pLayerMethod</em>&nbsp;</td><td>the method layer. Should not be NULL.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pLayerResult</em>&nbsp;</td><td>the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>papszOptions</em>&nbsp;</td><td>NULL terminated list of options (may be NULL).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnProgress</em>&nbsp;</td><td>a GDALProgressFunc() compatible callback function for reporting progress or NULL.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pProgressArg</em>&nbsp;</td><td>argument to be passed to pfnProgress. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.10 </dd></dl>

<p>References <a class="el" href="classOGRGeometry.html#af4cf9f6eee1997268a481b39401c3161">OGRGeometry::clone()</a>, <a class="el" href="classOGRLayer.html#aaa1e32016f481596a55e1d988a15a067">CreateFeature()</a>, <a class="el" href="classOGRGeometry.html#ac92e1ca0e8b108ee920147d4894bde3a">OGRGeometry::Difference()</a>, <a class="el" href="classOGRGeometry.html#aadca09471fa9917452e087ba12d73eeb">OGRGeometry::getDimension()</a>, <a class="el" href="classOGRLayer.html#a74c796d4ce712e9a78df6042eeb8a91a">GetFeatureCount()</a>, <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf">GetLayerDefn()</a>, <a class="el" href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6">GetNextFeature()</a>, <a class="el" href="classOGRGeometryFactory.html#a04998dcdbb37aa37871891593c048544">OGRGeometryFactory::haveGEOS()</a>, <a class="el" href="classOGRGeometry.html#a202ad4c29487ca046c4a2b055042cb6a">OGRGeometry::Intersection()</a>, <a class="el" href="classOGRGeometry.html#ac8653ba97e53f3e3b041946ca2acc111">OGRGeometry::IsEmpty()</a>, <a class="el" href="classOGRLayer.html#aad0f2cd7f0587584b8f382c6a913583c">ResetReading()</a>, <a class="el" href="classOGRFeature.html#a6705e5ff8b1012ce4a687b973ecddf73">OGRFeature::SetFieldsFrom()</a>, <a class="el" href="classOGRFeature.html#a40a4ddb33f09a5f340b9139be72e277d">OGRFeature::SetGeometryDirectly()</a>, and <a class="el" href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169">SetSpatialFilter()</a>.</p>

</div>
</div>
<a class="anchor" id="ac189f54996c2d6fd769889ec99e0f48a"></a><!-- doxytag: member="OGRLayer::Intersection" ref="ac189f54996c2d6fd769889ec99e0f48a" args="(OGRLayer *pLayerMethod, OGRLayer *pLayerResult, char **papszOptions=NULL, GDALProgressFunc pfnProgress=NULL, void *pProgressArg=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRLayer::Intersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRLayer.html">OGRLayer</a> *&nbsp;</td>
          <td class="paramname"> <em>pLayerMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRLayer.html">OGRLayer</a> *&nbsp;</td>
          <td class="paramname"> <em>pLayerResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszOptions</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&nbsp;</td>
          <td class="paramname"> <em>pfnProgress</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pProgressArg</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Intersection of two layers. </p>
<p>The result layer contains features whose geometries represent areas that are common between features in the input layer and in the method layer. The features in the result layer have attributes from both input and method layers. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in the input and method layers.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If the schema of the result is set by user and contains fields that have the same name as a field in input and in method layer, then the attribute in the result feature will get the value from the feature of the method layer.</dd>
<dd>
For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</dd>
<dd>
This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</dd></dl>
<p>The recognized list of options is : </p>
<ul>
<li>
SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted. </li>
<li>
PROMOTE_TO_MULTI=YES/NO. Set it to YES to convert Polygons into MultiPolygons, or LineStrings to MultiLineStrings. </li>
<li>
INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer. </li>
<li>
METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer. </li>
</ul>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a5c353cc32c9dd02967a7bed1450d2524" title="Intersection of two layers.">OGR_L_Intersection()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pLayerMethod</em>&nbsp;</td><td>the method layer. Should not be NULL.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pLayerResult</em>&nbsp;</td><td>the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>papszOptions</em>&nbsp;</td><td>NULL terminated list of options (may be NULL).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnProgress</em>&nbsp;</td><td>a GDALProgressFunc() compatible callback function for reporting progress or NULL.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pProgressArg</em>&nbsp;</td><td>argument to be passed to pfnProgress. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.10 </dd></dl>

<p>References <a class="el" href="classOGRLayer.html#aaa1e32016f481596a55e1d988a15a067">CreateFeature()</a>, <a class="el" href="classOGRGeometry.html#aadca09471fa9917452e087ba12d73eeb">OGRGeometry::getDimension()</a>, <a class="el" href="classOGRGeometry.html#aa3d42b06ae6f7bbef6d1a2886da8d398">OGRGeometry::getEnvelope()</a>, <a class="el" href="classOGRLayer.html#a3be658ddb5b33d1ed95c31286774bbd2">GetExtent()</a>, <a class="el" href="classOGRLayer.html#a74c796d4ce712e9a78df6042eeb8a91a">GetFeatureCount()</a>, <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf">GetLayerDefn()</a>, <a class="el" href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6">GetNextFeature()</a>, <a class="el" href="classOGRGeometryFactory.html#a04998dcdbb37aa37871891593c048544">OGRGeometryFactory::haveGEOS()</a>, <a class="el" href="classOGRGeometry.html#a202ad4c29487ca046c4a2b055042cb6a">OGRGeometry::Intersection()</a>, <a class="el" href="classOGRGeometry.html#ac8653ba97e53f3e3b041946ca2acc111">OGRGeometry::IsEmpty()</a>, <a class="el" href="classOGRLayer.html#aad0f2cd7f0587584b8f382c6a913583c">ResetReading()</a>, <a class="el" href="classOGRFeature.html#a6705e5ff8b1012ce4a687b973ecddf73">OGRFeature::SetFieldsFrom()</a>, <a class="el" href="classOGRFeature.html#a40a4ddb33f09a5f340b9139be72e277d">OGRFeature::SetGeometryDirectly()</a>, and <a class="el" href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169">SetSpatialFilter()</a>.</p>

</div>
</div>
<a class="anchor" id="ae783de2e9ee2629e6bf27fd3b8622fb5"></a><!-- doxytag: member="OGRLayer::Reference" ref="ae783de2e9ee2629e6bf27fd3b8622fb5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRLayer::Reference </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Increment layer reference count. </p>
<p>This method is the same as the C function OGR_L_Reference().</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the reference count after incrementing. </dd></dl>

</div>
</div>
<a class="anchor" id="ab4c02b991bfa78552eeb0cbcdcf1aed8"></a><!-- doxytag: member="OGRLayer::ReorderField" ref="ab4c02b991bfa78552eeb0cbcdcf1aed8" args="(int iOldFieldPos, int iNewFieldPos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRLayer::ReorderField </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iOldFieldPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iNewFieldPos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reorder an existing field on a layer. </p>
<p>This method is a conveniency wrapper of <a class="el" href="classOGRLayer.html#aebd364a150d91f8d65d967646e0f92d3" title="Reorder all the fields of a layer.">ReorderFields()</a> dedicated to move a single field. It is a non-virtual method, so drivers should implement <a class="el" href="classOGRLayer.html#aebd364a150d91f8d65d967646e0f92d3" title="Reorder all the fields of a layer.">ReorderFields()</a> instead.</p>
<p>You must use this to reorder existing fields on a real layer. Internally the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> for the layer will be updated to reflect the reordering of the fields. Applications should never modify the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> used by a layer directly.</p>
<p>This method should not be called while there are feature objects in existance that were obtained or created with the previous layer definition.</p>
<p>The field definition that was at initial position iOldFieldPos will be moved at position iNewFieldPos, and elements between will be shuffled accordingly.</p>
<p>For example, let suppose the fields were "0","1","2","3","4" initially. ReorderField(1, 3) will reorder them as "0","2","3","1","4".</p>
<p>Not all drivers support this method. You can query a layer to check if it supports it with the OLCReorderFields capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existings features of the backing file/database should be updated accordingly.</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#ad20a3796ee63935285976ee425878927" title="Reorder an existing field on a layer.">OGR_L_ReorderField()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iOldFieldPos</em>&nbsp;</td><td>previous position of the field to move. Must be in the range [0,GetFieldCount()-1]. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iNewFieldPos</em>&nbsp;</td><td>new position of the field to move. Must be in the range [0,GetFieldCount()-1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE on success.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.9.0 </dd></dl>

<p>References <a class="el" href="classOGRFeatureDefn.html#ab400f9106e7544ebafa30b1fe59869b1">OGRFeatureDefn::GetFieldCount()</a>, <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf">GetLayerDefn()</a>, and <a class="el" href="classOGRLayer.html#aebd364a150d91f8d65d967646e0f92d3">ReorderFields()</a>.</p>

</div>
</div>
<a class="anchor" id="aebd364a150d91f8d65d967646e0f92d3"></a><!-- doxytag: member="OGRLayer::ReorderFields" ref="aebd364a150d91f8d65d967646e0f92d3" args="(int *panMap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRLayer::ReorderFields </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>panMap</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reorder all the fields of a layer. </p>
<p>You must use this to reorder existing fields on a real layer. Internally the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> for the layer will be updated to reflect the reordering of the fields. Applications should never modify the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> used by a layer directly.</p>
<p>This method should not be called while there are feature objects in existance that were obtained or created with the previous layer definition.</p>
<p>panMap is such that,for each field definition at position i after reordering, its position before reordering was panMap[i].</p>
<p>For example, let suppose the fields were "0","1","2","3","4" initially. ReorderFields([0,2,3,1,4]) will reorder them as "0","2","3","1","4".</p>
<p>Not all drivers support this method. You can query a layer to check if it supports it with the OLCReorderFields capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existings features of the backing file/database should be updated accordingly.</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#a4cc576cb39e1dd4a1f074125199245bb" title="Reorder all the fields of a layer.">OGR_L_ReorderFields()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>panMap</em>&nbsp;</td><td>an array of <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">GetLayerDefn()</a>-&gt;GetFieldCount() elements which is a permutation of [0, <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">GetLayerDefn()</a>-&gt;GetFieldCount()-1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE on success.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.9.0 </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRLayerDecorator.html#aca079c71a7cda466c46203d1cecdac45">OGRLayerDecorator</a>, <a class="el" href="classOGRProxiedLayer.html#a5777788301799adef78a1decdeb7c503">OGRProxiedLayer</a>, and <a class="el" href="classOGRMutexedLayer.html#a5cc9d32e8347b2e9208ea5b98da6f413">OGRMutexedLayer</a>.</p>

<p>Referenced by <a class="el" href="classOGRLayer.html#ab4c02b991bfa78552eeb0cbcdcf1aed8">ReorderField()</a>, <a class="el" href="classOGRProxiedLayer.html#a5777788301799adef78a1decdeb7c503">OGRProxiedLayer::ReorderFields()</a>, and <a class="el" href="classOGRLayerDecorator.html#aca079c71a7cda466c46203d1cecdac45">OGRLayerDecorator::ReorderFields()</a>.</p>

</div>
</div>
<a class="anchor" id="aad0f2cd7f0587584b8f382c6a913583c"></a><!-- doxytag: member="OGRLayer::ResetReading" ref="aad0f2cd7f0587584b8f382c6a913583c" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRLayer::ResetReading </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset feature reading to start on the first feature. </p>
<p>This affects <a class="el" href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6" title="Fetch the next available feature from this layer.">GetNextFeature()</a>.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ab0383004bf637171648a9d03a80f15a4" title="Reset feature reading to start on the first feature.">OGR_L_ResetReading()</a>. </p>

<p>Implemented in <a class="el" href="classOGRGenSQLResultsLayer.html#a55152e648a19d47b1477a732a30f5950">OGRGenSQLResultsLayer</a>, <a class="el" href="classOGRLayerDecorator.html#aa430e840e443235b9aa72e1baac86b18">OGRLayerDecorator</a>, <a class="el" href="classOGRProxiedLayer.html#a31afd15eed0c8f9382505d0e358631a2">OGRProxiedLayer</a>, <a class="el" href="classOGRMutexedLayer.html#a46bb36f6749839d7a6d8f965ed86a73b">OGRMutexedLayer</a>, and <a class="el" href="classOGRUnionLayer.html#a20c1d59b04f816722d0d6f865f079273">OGRUnionLayer</a>.</p>

<p>Referenced by <a class="el" href="classOGRLayer.html#a56d7ee3b2020e53c730d67ee4f1e2fb6">Clip()</a>, <a class="el" href="classOGRDataSource.html#a42dc7f7f538cd4f083af350722fe53ae">OGRDataSource::CopyLayer()</a>, <a class="el" href="classOGRLayer.html#ae8fcf55ffa259f32df35edcb05274439">Erase()</a>, <a class="el" href="classOGRLayer.html#acb7625383f161e5a04aeea2173dce411">GetFeature()</a>, <a class="el" href="classOGRLayer.html#a74c796d4ce712e9a78df6042eeb8a91a">GetFeatureCount()</a>, <a class="el" href="classOGRLayer.html#acac6a0bde9737555b22c6ac7fa967431">Identity()</a>, <a class="el" href="classOGRLayer.html#ac189f54996c2d6fd769889ec99e0f48a">Intersection()</a>, <a class="el" href="classOGRProxiedLayer.html#a31afd15eed0c8f9382505d0e358631a2">OGRProxiedLayer::ResetReading()</a>, <a class="el" href="classOGRLayerDecorator.html#aa430e840e443235b9aa72e1baac86b18">OGRLayerDecorator::ResetReading()</a>, <a class="el" href="classOGRLayer.html#acb2c6cc5fa3577df5be538284c1b0dde">SetAttributeFilter()</a>, <a class="el" href="classOGRLayer.html#ae3b6234d6077a18a19eddaf7e75ff5e1">SetNextByIndex()</a>, <a class="el" href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169">SetSpatialFilter()</a>, <a class="el" href="classOGRLayer.html#a781aa76c6b44b19de09f61816e32245b">SymDifference()</a>, <a class="el" href="classOGRLayer.html#aeb8ab475561f2aca2c0e605cfb810b22">Union()</a>, and <a class="el" href="classOGRLayer.html#aa1c5dc5ca195956c46d35a85b0b21d9b">Update()</a>.</p>

</div>
</div>
<a class="anchor" id="acb2c6cc5fa3577df5be538284c1b0dde"></a><!-- doxytag: member="OGRLayer::SetAttributeFilter" ref="acb2c6cc5fa3577df5be538284c1b0dde" args="(const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRLayer::SetAttributeFilter </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszQuery</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a new attribute query. </p>
<p>This method sets the attribute query string to be used when fetching features via the <a class="el" href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6" title="Fetch the next available feature from this layer.">GetNextFeature()</a> method. Only features for which the query evaluates as true will be returned.</p>
<p>The query string should be in the format of an SQL WHERE clause. For instance "population &gt; 1000000 and population &lt; 5000000" where population is an attribute in the layer. The query format is normally a restricted form of SQL WHERE clause as described in the "WHERE" section of the <a href="ogr_sql.html">OGR SQL</a> tutorial. In some cases (RDBMS backed drivers) the native capabilities of the database may be used to interprete the WHERE clause in which case the capabilities will be broader than those of OGR SQL.</p>
<p>Note that installing a query string will generally result in resetting the current reading position (ala <a class="el" href="classOGRLayer.html#aad0f2cd7f0587584b8f382c6a913583c" title="Reset feature reading to start on the first feature.">ResetReading()</a>).</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a4000d426bf26ad7cc7d4012634c93f09" title="Set a new attribute query.">OGR_L_SetAttributeFilter()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszQuery</em>&nbsp;</td><td>query in restricted SQL WHERE format, or NULL to clear the current query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE if successfully installed, or an error code if the query expression is in error, or some other failure occurs. </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRGenSQLResultsLayer.html#aa8320c52c48e9d4eb9884cfdfc1fdd63">OGRGenSQLResultsLayer</a>, <a class="el" href="classOGRLayerDecorator.html#ae9659fb3c5026f2430f048b4e7169fff">OGRLayerDecorator</a>, <a class="el" href="classOGRProxiedLayer.html#a5001f1f78b96a8d3003ba7878c01e7bb">OGRProxiedLayer</a>, <a class="el" href="classOGRMutexedLayer.html#a6113634c9216c4c26e5b3f410e170860">OGRMutexedLayer</a>, and <a class="el" href="classOGRUnionLayer.html#a2231dba322c7cfbc5914e2201d27c610">OGRUnionLayer</a>.</p>

<p>References <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf">GetLayerDefn()</a>, and <a class="el" href="classOGRLayer.html#aad0f2cd7f0587584b8f382c6a913583c">ResetReading()</a>.</p>

<p>Referenced by <a class="el" href="classOGRLayer.html#acb7625383f161e5a04aeea2173dce411">GetFeature()</a>, <a class="el" href="classOGRProxiedLayer.html#a5001f1f78b96a8d3003ba7878c01e7bb">OGRProxiedLayer::SetAttributeFilter()</a>, and <a class="el" href="classOGRLayerDecorator.html#ae9659fb3c5026f2430f048b4e7169fff">OGRLayerDecorator::SetAttributeFilter()</a>.</p>

</div>
</div>
<a class="anchor" id="a681139bfd585b74d7218e51a32144283"></a><!-- doxytag: member="OGRLayer::SetFeature" ref="a681139bfd585b74d7218e51a32144283" args="(OGRFeature *poFeature)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRLayer::SetFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRFeature.html">OGRFeature</a> *&nbsp;</td>
          <td class="paramname"> <em>poFeature</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rewrite an existing feature. </p>
<p>This method will write a feature to the layer, based on the feature id within the <a class="el" href="classOGRFeature.html">OGRFeature</a>.</p>
<p>Use OGRLayer::TestCapability(OLCRandomWrite) to establish if this layer supports random access writing via <a class="el" href="classOGRLayer.html#a681139bfd585b74d7218e51a32144283" title="Rewrite an existing feature.">SetFeature()</a>.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a5b380520d0999422987f06b6e31b9b00" title="Rewrite an existing feature.">OGR_L_SetFeature()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poFeature</em>&nbsp;</td><td>the feature to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE if the operation works, otherwise an appropriate error code. </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRLayerDecorator.html#af42a6e262dd2c788d77643a7388564ca">OGRLayerDecorator</a>, <a class="el" href="classOGRProxiedLayer.html#ab7f53682284d9e17993c115835f69522">OGRProxiedLayer</a>, <a class="el" href="classOGRMutexedLayer.html#a87301abe09e2d407c9cdce84dc3be373">OGRMutexedLayer</a>, <a class="el" href="classOGRUnionLayer.html#ab44d7c6a95d8d6a73f906f60760c0c56">OGRUnionLayer</a>, and <a class="el" href="classOGRWarpedLayer.html#a675128117d059eee968fcf9d42b68acd">OGRWarpedLayer</a>.</p>

<p>Referenced by <a class="el" href="classOGRWarpedLayer.html#a675128117d059eee968fcf9d42b68acd">OGRWarpedLayer::SetFeature()</a>, <a class="el" href="classOGRUnionLayer.html#ab44d7c6a95d8d6a73f906f60760c0c56">OGRUnionLayer::SetFeature()</a>, <a class="el" href="classOGRProxiedLayer.html#ab7f53682284d9e17993c115835f69522">OGRProxiedLayer::SetFeature()</a>, and <a class="el" href="classOGRLayerDecorator.html#af42a6e262dd2c788d77643a7388564ca">OGRLayerDecorator::SetFeature()</a>.</p>

</div>
</div>
<a class="anchor" id="a5e0c3427f64249d1c35cefb487546b10"></a><!-- doxytag: member="OGRLayer::SetIgnoredFields" ref="a5e0c3427f64249d1c35cefb487546b10" args="(const char **papszFields)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRLayer::SetIgnoredFields </td>
          <td>(</td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>papszFields</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set which fields can be omitted when retrieving features from the layer. </p>
<p>If the driver supports this functionality (testable using OLCIgnoreFields capability), it will not fetch the specified fields in subsequent calls to <a class="el" href="classOGRLayer.html#acb7625383f161e5a04aeea2173dce411" title="Fetch a feature by its identifier.">GetFeature()</a> / <a class="el" href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6" title="Fetch the next available feature from this layer.">GetNextFeature()</a> and thus save some processing time and/or bandwidth.</p>
<p>Besides field names of the layers, the following special fields can be passed: "OGR_GEOMETRY" to ignore geometry and "OGR_STYLE" to ignore layer style.</p>
<p>By default, no fields are ignored.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a6d43f1474201356bed2e6f92e7d37154" title="Set which fields can be omitted when retrieving features from the layer.">OGR_L_SetIgnoredFields()</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>papszFields</em>&nbsp;</td><td>an array of field names terminated by NULL item. If NULL is passed, the ignored list is cleared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE if all field names have been resolved (even if the driver does not support this method) </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRLayerDecorator.html#adc1b3ec7fe99335be403646123636800">OGRLayerDecorator</a>, <a class="el" href="classOGRProxiedLayer.html#aa4a7f6badebe7e6c45e0d6b3a96e0aa1">OGRProxiedLayer</a>, <a class="el" href="classOGRMutexedLayer.html#a953ced5149b5a40b12ecf5e289a68ced">OGRMutexedLayer</a>, and <a class="el" href="classOGRUnionLayer.html#a81737b724f0c7c0f81d593cec662bb08">OGRUnionLayer</a>.</p>

<p>References <a class="el" href="classOGRFeatureDefn.html#ab400f9106e7544ebafa30b1fe59869b1">OGRFeatureDefn::GetFieldCount()</a>, <a class="el" href="classOGRFeatureDefn.html#a43b95ce699bbca73acb453cc959378e7">OGRFeatureDefn::GetFieldDefn()</a>, <a class="el" href="classOGRFeatureDefn.html#a4f7111e4c818f194932795e9c9593258">OGRFeatureDefn::GetFieldIndex()</a>, <a class="el" href="classOGRFeatureDefn.html#acacca3de3718ae525565e5130b5474dc">OGRFeatureDefn::GetGeomFieldDefn()</a>, <a class="el" href="classOGRFeatureDefn.html#a2aaea18e9bcfee39cee05d616de6e12c">OGRFeatureDefn::GetGeomFieldIndex()</a>, <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf">GetLayerDefn()</a>, <a class="el" href="classOGRFeatureDefn.html#a539b87cd1587dc928b246a211839e22a">OGRFeatureDefn::SetGeometryIgnored()</a>, <a class="el" href="classOGRGeomFieldDefn.html#a387cedc1973472c54237944bfb530b25">OGRGeomFieldDefn::SetIgnored()</a>, <a class="el" href="classOGRFieldDefn.html#ad194ad748a62ec40b772a7ded173c367">OGRFieldDefn::SetIgnored()</a>, and <a class="el" href="classOGRFeatureDefn.html#a18e45edc2008f3a73e8bf4fed39fddd9">OGRFeatureDefn::SetStyleIgnored()</a>.</p>

<p>Referenced by <a class="el" href="classOGRProxiedLayer.html#aa4a7f6badebe7e6c45e0d6b3a96e0aa1">OGRProxiedLayer::SetIgnoredFields()</a>, and <a class="el" href="classOGRLayerDecorator.html#adc1b3ec7fe99335be403646123636800">OGRLayerDecorator::SetIgnoredFields()</a>.</p>

</div>
</div>
<a class="anchor" id="ae3b6234d6077a18a19eddaf7e75ff5e1"></a><!-- doxytag: member="OGRLayer::SetNextByIndex" ref="ae3b6234d6077a18a19eddaf7e75ff5e1" args="(long nIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRLayer::SetNextByIndex </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nIndex</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Move read cursor to the nIndex'th feature in the current resultset. </p>
<p>This method allows positioning of a layer such that the <a class="el" href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6" title="Fetch the next available feature from this layer.">GetNextFeature()</a> call will read the requested feature, where nIndex is an absolute index into the current result set. So, setting it to 3 would mean the next feature read with <a class="el" href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6" title="Fetch the next available feature from this layer.">GetNextFeature()</a> would have been the 4th feature to have been read if sequential reading took place from the beginning of the layer, including accounting for spatial and attribute filters.</p>
<p>Only in rare circumstances is <a class="el" href="classOGRLayer.html#ae3b6234d6077a18a19eddaf7e75ff5e1" title="Move read cursor to the nIndex&#39;th feature in the current resultset.">SetNextByIndex()</a> efficiently implemented. In all other cases the default implementation which calls <a class="el" href="classOGRLayer.html#aad0f2cd7f0587584b8f382c6a913583c" title="Reset feature reading to start on the first feature.">ResetReading()</a> and then calls <a class="el" href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6" title="Fetch the next available feature from this layer.">GetNextFeature()</a> nIndex times is used. To determine if fast seeking is available on the current layer use the <a class="el" href="classOGRLayer.html#aeedbda1a62f9b89b8e5f24332cf22286" title="Test if this layer supported the named capability.">TestCapability()</a> method with a value of OLCFastSetNextByIndex.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a5bb3f366e3e6cd8cb586842193b4a7f9" title="Move read cursor to the nIndex&#39;th feature in the current resultset.">OGR_L_SetNextByIndex()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nIndex</em>&nbsp;</td><td>the index indicating how many steps into the result set to seek.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE on success or an error code. </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRGenSQLResultsLayer.html#ab083e809dadb0aa6467cccd5a4dda625">OGRGenSQLResultsLayer</a>, <a class="el" href="classOGRLayerDecorator.html#afdecea758d3bcc6f4b251a90b59138c3">OGRLayerDecorator</a>, <a class="el" href="classOGRProxiedLayer.html#a50dc75caf604cf2a7d0a41d4aba0341b">OGRProxiedLayer</a>, and <a class="el" href="classOGRMutexedLayer.html#a9bcd2f4624f07c873d18f48526dac76e">OGRMutexedLayer</a>.</p>

<p>References <a class="el" href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6">GetNextFeature()</a>, and <a class="el" href="classOGRLayer.html#aad0f2cd7f0587584b8f382c6a913583c">ResetReading()</a>.</p>

<p>Referenced by <a class="el" href="classOGRProxiedLayer.html#a50dc75caf604cf2a7d0a41d4aba0341b">OGRProxiedLayer::SetNextByIndex()</a>, <a class="el" href="classOGRLayerDecorator.html#afdecea758d3bcc6f4b251a90b59138c3">OGRLayerDecorator::SetNextByIndex()</a>, and <a class="el" href="classOGRGenSQLResultsLayer.html#ab083e809dadb0aa6467cccd5a4dda625">OGRGenSQLResultsLayer::SetNextByIndex()</a>.</p>

</div>
</div>
<a class="anchor" id="a0b4ab45cf97cbc470f0d60474d3e4169"></a><!-- doxytag: member="OGRLayer::SetSpatialFilter" ref="a0b4ab45cf97cbc470f0d60474d3e4169" args="(OGRGeometry *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRLayer::SetSpatialFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td>
          <td class="paramname"> <em>poFilter</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a new spatial filter. </p>
<p>This method set the geometry to be used as a spatial filter when fetching features via the <a class="el" href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6" title="Fetch the next available feature from this layer.">GetNextFeature()</a> method. Only features that geometrically intersect the filter geometry will be returned.</p>
<p>Currently this test is may be inaccurately implemented, but it is guaranteed that all features who's envelope (as returned by <a class="el" href="classOGRGeometry.html#aa3d42b06ae6f7bbef6d1a2886da8d398" title="Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure...">OGRGeometry::getEnvelope()</a>) overlaps the envelope of the spatial filter will be returned. This can result in more shapes being returned that should strictly be the case.</p>
<p>This method makes an internal copy of the passed geometry. The passed geometry remains the responsibility of the caller, and may be safely destroyed.</p>
<p>For the time being the passed filter geometry should be in the same SRS as the layer (as returned by <a class="el" href="classOGRLayer.html#a75c06b4993f8eb76b569f37365cd19ab" title="Fetch the spatial reference system for this layer.">OGRLayer::GetSpatialRef()</a>). In the future this may be generalized.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a678d1735bc82533614ac005691d1138c" title="Set a new spatial filter.">OGR_L_SetSpatialFilter()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poFilter</em>&nbsp;</td><td>the geometry to use as a filtering region. NULL may be passed indicating that the current spatial filter should be cleared, but no new one instituted. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classOGRGenSQLResultsLayer.html#ac2c12f3ced4a79673184abdb6e578fd8">OGRGenSQLResultsLayer</a>, <a class="el" href="classOGRLayerDecorator.html#ab113a978272fe2eb060cafa8bf13f8b9">OGRLayerDecorator</a>, <a class="el" href="classOGRProxiedLayer.html#a986e6f336946dc411abb05bf7e937409">OGRProxiedLayer</a>, <a class="el" href="classOGRMutexedLayer.html#a6aac6029961847c049bef0e193b4ea29">OGRMutexedLayer</a>, <a class="el" href="classOGRUnionLayer.html#a194555741a74ee0e61c92875683cce7f">OGRUnionLayer</a>, and <a class="el" href="classOGRWarpedLayer.html#a8f41d20ca38cfb431a54fecd4f1c858b">OGRWarpedLayer</a>.</p>

<p>References <a class="el" href="classOGRLayer.html#aad0f2cd7f0587584b8f382c6a913583c">ResetReading()</a>.</p>

<p>Referenced by <a class="el" href="classOGRLayer.html#a56d7ee3b2020e53c730d67ee4f1e2fb6">Clip()</a>, <a class="el" href="classOGRLayer.html#ae8fcf55ffa259f32df35edcb05274439">Erase()</a>, <a class="el" href="classOGRLayer.html#acb7625383f161e5a04aeea2173dce411">GetFeature()</a>, <a class="el" href="classOGRLayer.html#acac6a0bde9737555b22c6ac7fa967431">Identity()</a>, <a class="el" href="classOGRLayer.html#ac189f54996c2d6fd769889ec99e0f48a">Intersection()</a>, <a class="el" href="classOGRWarpedLayer.html#a50e1332a6d2bd495422e1ef83ca6a246">OGRWarpedLayer::SetSpatialFilter()</a>, <a class="el" href="classOGRProxiedLayer.html#a986e6f336946dc411abb05bf7e937409">OGRProxiedLayer::SetSpatialFilter()</a>, <a class="el" href="classOGRLayerDecorator.html#ab113a978272fe2eb060cafa8bf13f8b9">OGRLayerDecorator::SetSpatialFilter()</a>, <a class="el" href="classOGRLayer.html#aebac60fb86ee178be016655532070ee3">SetSpatialFilter()</a>, <a class="el" href="classOGRLayer.html#a5cd4ceb8f4ec20594be63280c8e4498a">SetSpatialFilterRect()</a>, <a class="el" href="classOGRLayer.html#a781aa76c6b44b19de09f61816e32245b">SymDifference()</a>, <a class="el" href="classOGRLayer.html#aeb8ab475561f2aca2c0e605cfb810b22">Union()</a>, and <a class="el" href="classOGRLayer.html#aa1c5dc5ca195956c46d35a85b0b21d9b">Update()</a>.</p>

</div>
</div>
<a class="anchor" id="aebac60fb86ee178be016655532070ee3"></a><!-- doxytag: member="OGRLayer::SetSpatialFilter" ref="aebac60fb86ee178be016655532070ee3" args="(int iGeomField, OGRGeometry *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRLayer::SetSpatialFilter </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iGeomField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td>
          <td class="paramname"> <em>poFilter</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a new spatial filter. </p>
<p>This method set the geometry to be used as a spatial filter when fetching features via the <a class="el" href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6" title="Fetch the next available feature from this layer.">GetNextFeature()</a> method. Only features that geometrically intersect the filter geometry will be returned.</p>
<p>Currently this test is may be inaccurately implemented, but it is guaranteed that all features who's envelope (as returned by <a class="el" href="classOGRGeometry.html#aa3d42b06ae6f7bbef6d1a2886da8d398" title="Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure...">OGRGeometry::getEnvelope()</a>) overlaps the envelope of the spatial filter will be returned. This can result in more shapes being returned that should strictly be the case.</p>
<p>This method makes an internal copy of the passed geometry. The passed geometry remains the responsibility of the caller, and may be safely destroyed.</p>
<p>For the time being the passed filter geometry should be in the same SRS as the geometry field definition it corresponds to (as returned by <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">GetLayerDefn()</a>-&gt;GetGeomFieldDefn(iGeomField)-&gt;<a class="el" href="classOGRLayer.html#a75c06b4993f8eb76b569f37365cd19ab" title="Fetch the spatial reference system for this layer.">GetSpatialRef()</a>). In the future this may be generalized.</p>
<p>Note that only the last spatial filter set is applied, even if several successive calls are done with different iGeomField values.</p>
<p>Note to driver implementators: if you implement <a class="el" href="classOGRLayer.html#aebac60fb86ee178be016655532070ee3" title="Set a new spatial filter.">SetSpatialFilter(int,OGRGeometry*)</a>, you must also implement <a class="el" href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169" title="Set a new spatial filter.">SetSpatialFilter(OGRGeometry*)</a> to make it call SetSpatialFilter(0,OGRGeometry*).</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a00c8a1a968542d389f86ed1b4edd5823" title="Set a new spatial filter.">OGR_L_SetSpatialFilterEx()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iGeomField</em>&nbsp;</td><td>index of the geometry field on which the spatial filter operates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>poFilter</em>&nbsp;</td><td>the geometry to use as a filtering region. NULL may be passed indicating that the current spatial filter should be cleared, but no new one instituted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.11 </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRGenSQLResultsLayer.html#a4654e3ad85e009513887a1c9cee9e6dc">OGRGenSQLResultsLayer</a>, <a class="el" href="classOGRLayerDecorator.html#ab5f573a61c192099ced0e83825a36aef">OGRLayerDecorator</a>, <a class="el" href="classOGRProxiedLayer.html#a31d3461d7a1f849299d742031d67c14c">OGRProxiedLayer</a>, <a class="el" href="classOGRMutexedLayer.html#ae15a0e5b02cc4eaefc6bdb6d3cb7dd32">OGRMutexedLayer</a>, <a class="el" href="classOGRUnionLayer.html#a2ece59929973a6f19a95443e45ffccad">OGRUnionLayer</a>, and <a class="el" href="classOGRWarpedLayer.html#a50e1332a6d2bd495422e1ef83ca6a246">OGRWarpedLayer</a>.</p>

<p>References <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf">GetLayerDefn()</a>, <a class="el" href="classOGRLayer.html#aad0f2cd7f0587584b8f382c6a913583c">ResetReading()</a>, and <a class="el" href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169">SetSpatialFilter()</a>.</p>

</div>
</div>
<a class="anchor" id="a5cd4ceb8f4ec20594be63280c8e4498a"></a><!-- doxytag: member="OGRLayer::SetSpatialFilterRect" ref="a5cd4ceb8f4ec20594be63280c8e4498a" args="(int iGeomField, double dfMinX, double dfMinY, double dfMaxX, double dfMaxY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRLayer::SetSpatialFilterRect </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iGeomField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfMinX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfMinY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfMaxX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfMaxY</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a new rectangular spatial filter. </p>
<p>This method set rectangle to be used as a spatial filter when fetching features via the <a class="el" href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6" title="Fetch the next available feature from this layer.">GetNextFeature()</a> method. Only features that geometrically intersect the given rectangle will be returned.</p>
<p>The x/y values should be in the same coordinate system as as the geometry field definition it corresponds to (as returned by <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">GetLayerDefn()</a>-&gt;GetGeomFieldDefn(iGeomField)-&gt;<a class="el" href="classOGRLayer.html#a75c06b4993f8eb76b569f37365cd19ab" title="Fetch the spatial reference system for this layer.">GetSpatialRef()</a>). Internally this method is normally implemented as creating a 5 vertex closed rectangular polygon and passing it to <a class="el" href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169" title="Set a new spatial filter.">OGRLayer::SetSpatialFilter()</a>. It exists as a convenience.</p>
<p>The only way to clear a spatial filter set with this method is to call OGRLayer::SetSpatialFilter(NULL).</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a489241dfe65d6e089809d3258c4f79f5" title="Set a new rectangular spatial filter.">OGR_L_SetSpatialFilterRectEx()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iGeomField</em>&nbsp;</td><td>index of the geometry field on which the spatial filter operates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfMinX</em>&nbsp;</td><td>the minimum X coordinate for the rectangular region. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfMinY</em>&nbsp;</td><td>the minimum Y coordinate for the rectangular region. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfMaxX</em>&nbsp;</td><td>the maximum X coordinate for the rectangular region. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfMaxY</em>&nbsp;</td><td>the maximum Y coordinate for the rectangular region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.11 </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRLayerDecorator.html#a52231526e17e03d1849a59f1231d5036">OGRLayerDecorator</a>, <a class="el" href="classOGRMutexedLayer.html#af125218a8743fdf4011298c4b213ad31">OGRMutexedLayer</a>, and <a class="el" href="classOGRWarpedLayer.html#afc940600931d49fce93c0f770079aadd">OGRWarpedLayer</a>.</p>

<p>References <a class="el" href="classOGRLineString.html#aeadb4c3f26162e12eadc311d8ec8ef9f">OGRLineString::addPoint()</a>, <a class="el" href="classOGRPolygon.html#a6a2400d013a7538169b6f610499d9e30">OGRPolygon::addRing()</a>, and <a class="el" href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169">SetSpatialFilter()</a>.</p>

</div>
</div>
<a class="anchor" id="acd16bcdb3e8f720003fb24cd68f25460"></a><!-- doxytag: member="OGRLayer::SetSpatialFilterRect" ref="acd16bcdb3e8f720003fb24cd68f25460" args="(double dfMinX, double dfMinY, double dfMaxX, double dfMaxY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRLayer::SetSpatialFilterRect </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfMinX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfMinY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfMaxX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfMaxY</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a new rectangular spatial filter. </p>
<p>This method set rectangle to be used as a spatial filter when fetching features via the <a class="el" href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6" title="Fetch the next available feature from this layer.">GetNextFeature()</a> method. Only features that geometrically intersect the given rectangle will be returned.</p>
<p>The x/y values should be in the same coordinate system as the layer as a whole (as returned by <a class="el" href="classOGRLayer.html#a75c06b4993f8eb76b569f37365cd19ab" title="Fetch the spatial reference system for this layer.">OGRLayer::GetSpatialRef()</a>). Internally this method is normally implemented as creating a 5 vertex closed rectangular polygon and passing it to <a class="el" href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169" title="Set a new spatial filter.">OGRLayer::SetSpatialFilter()</a>. It exists as a convenience.</p>
<p>The only way to clear a spatial filter set with this method is to call OGRLayer::SetSpatialFilter(NULL).</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a5cba569e0779a02a95327f041d9f7a13" title="Set a new rectangular spatial filter.">OGR_L_SetSpatialFilterRect()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dfMinX</em>&nbsp;</td><td>the minimum X coordinate for the rectangular region. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfMinY</em>&nbsp;</td><td>the minimum Y coordinate for the rectangular region. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfMaxX</em>&nbsp;</td><td>the maximum X coordinate for the rectangular region. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfMaxY</em>&nbsp;</td><td>the maximum Y coordinate for the rectangular region. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classOGRLayerDecorator.html#a5182e0e702fb3598bfcd556901c2191e">OGRLayerDecorator</a>, <a class="el" href="classOGRMutexedLayer.html#ae93c6d30ca620ab8a782907b1a37dd59">OGRMutexedLayer</a>, and <a class="el" href="classOGRWarpedLayer.html#a159b1aafced966dbbd35535d3ecc18ac">OGRWarpedLayer</a>.</p>

<p>Referenced by <a class="el" href="classOGRWarpedLayer.html#a50e1332a6d2bd495422e1ef83ca6a246">OGRWarpedLayer::SetSpatialFilter()</a>, and <a class="el" href="classOGRLayerDecorator.html#a5182e0e702fb3598bfcd556901c2191e">OGRLayerDecorator::SetSpatialFilterRect()</a>.</p>

</div>
</div>
<a class="anchor" id="a33fa0802c0686fb0e6ca6337e11cd7d5"></a><!-- doxytag: member="OGRLayer::SetStyleTable" ref="a33fa0802c0686fb0e6ca6337e11cd7d5" args="(OGRStyleTable *poStyleTable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRLayer::SetStyleTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRStyleTable.html">OGRStyleTable</a> *&nbsp;</td>
          <td class="paramname"> <em>poStyleTable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set layer style table. </p>
<p>This method operate exactly as <a class="el" href="classOGRLayer.html#a2687d4312c044bb3a20bd13974ba8905" title="Set layer style table.">OGRLayer::SetStyleTableDirectly()</a> except that it does not assume ownership of the passed table.</p>
<p>This method is the same as the C function OGR_L_SetStyleTable().</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poStyleTable</em>&nbsp;</td><td>pointer to style table to set </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classOGRLayerDecorator.html#a3ec150e9dfbfadffcebec6a96396ac8f">OGRLayerDecorator</a>, <a class="el" href="classOGRProxiedLayer.html#ac9234513223c2c0833bc6e142d7427a8">OGRProxiedLayer</a>, and <a class="el" href="classOGRMutexedLayer.html#ad66266ef0b42ad18ae3ab20e9d3518b7">OGRMutexedLayer</a>.</p>

<p>References <a class="el" href="classOGRStyleTable.html#a238073729c346b514ec70a5f81ecd3df">OGRStyleTable::Clone()</a>.</p>

<p>Referenced by <a class="el" href="classOGRProxiedLayer.html#ac9234513223c2c0833bc6e142d7427a8">OGRProxiedLayer::SetStyleTable()</a>, and <a class="el" href="classOGRLayerDecorator.html#a3ec150e9dfbfadffcebec6a96396ac8f">OGRLayerDecorator::SetStyleTable()</a>.</p>

</div>
</div>
<a class="anchor" id="a2687d4312c044bb3a20bd13974ba8905"></a><!-- doxytag: member="OGRLayer::SetStyleTableDirectly" ref="a2687d4312c044bb3a20bd13974ba8905" args="(OGRStyleTable *poStyleTable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRLayer::SetStyleTableDirectly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRStyleTable.html">OGRStyleTable</a> *&nbsp;</td>
          <td class="paramname"> <em>poStyleTable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set layer style table. </p>
<p>This method operate exactly as <a class="el" href="classOGRLayer.html#a33fa0802c0686fb0e6ca6337e11cd7d5" title="Set layer style table.">OGRLayer::SetStyleTable()</a> except that it assumes ownership of the passed table.</p>
<p>This method is the same as the C function OGR_L_SetStyleTableDirectly().</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poStyleTable</em>&nbsp;</td><td>pointer to style table to set </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classOGRLayerDecorator.html#a531fc3d535c43848ff001c2a4455700f">OGRLayerDecorator</a>, <a class="el" href="classOGRProxiedLayer.html#aa0a09af2a5e9279e3e9e5637e524c17a">OGRProxiedLayer</a>, and <a class="el" href="classOGRMutexedLayer.html#acab228210e846924be8816538ab7d64d">OGRMutexedLayer</a>.</p>

<p>Referenced by <a class="el" href="classOGRProxiedLayer.html#aa0a09af2a5e9279e3e9e5637e524c17a">OGRProxiedLayer::SetStyleTableDirectly()</a>, and <a class="el" href="classOGRLayerDecorator.html#a531fc3d535c43848ff001c2a4455700f">OGRLayerDecorator::SetStyleTableDirectly()</a>.</p>

</div>
</div>
<a class="anchor" id="a781aa76c6b44b19de09f61816e32245b"></a><!-- doxytag: member="OGRLayer::SymDifference" ref="a781aa76c6b44b19de09f61816e32245b" args="(OGRLayer *pLayerMethod, OGRLayer *pLayerResult, char **papszOptions, GDALProgressFunc pfnProgress, void *pProgressArg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRLayer::SymDifference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRLayer.html">OGRLayer</a> *&nbsp;</td>
          <td class="paramname"> <em>pLayerMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRLayer.html">OGRLayer</a> *&nbsp;</td>
          <td class="paramname"> <em>pLayerResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&nbsp;</td>
          <td class="paramname"> <em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pProgressArg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Symmetrical difference of two layers. </p>
<p>The result layer contains features whose geometries represent areas that are in either in the input layer or in the method layer but not in both. The features in the result layer have attributes from both input and method layers. For features which represent areas that are only in the input or in the method layer the respective attributes have undefined values. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in the input and method layers.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If the schema of the result is set by user and contains fields that have the same name as a field in input and in method layer, then the attribute in the result feature will get the value from the feature of the method layer (even if it is undefined).</dd>
<dd>
For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</dd>
<dd>
This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</dd></dl>
<p>The recognized list of options is : </p>
<ul>
<li>
SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted. </li>
<li>
PROMOTE_TO_MULTI=YES/NO. Set it to YES to convert Polygons into MultiPolygons, or LineStrings to MultiLineStrings. </li>
<li>
INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer. </li>
<li>
METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer. </li>
</ul>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a03249311ff4c88b2fac5f728be63b549" title="Symmetrical difference of two layers.">OGR_L_SymDifference()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pLayerMethod</em>&nbsp;</td><td>the method layer. Should not be NULL.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pLayerResult</em>&nbsp;</td><td>the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>papszOptions</em>&nbsp;</td><td>NULL terminated list of options (may be NULL).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnProgress</em>&nbsp;</td><td>a GDALProgressFunc() compatible callback function for reporting progress or NULL.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pProgressArg</em>&nbsp;</td><td>argument to be passed to pfnProgress. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.10 </dd></dl>

<p>References <a class="el" href="classOGRGeometry.html#af4cf9f6eee1997268a481b39401c3161">OGRGeometry::clone()</a>, <a class="el" href="classOGRLayer.html#aaa1e32016f481596a55e1d988a15a067">CreateFeature()</a>, <a class="el" href="classOGRGeometry.html#ac92e1ca0e8b108ee920147d4894bde3a">OGRGeometry::Difference()</a>, <a class="el" href="classOGRLayer.html#a74c796d4ce712e9a78df6042eeb8a91a">GetFeatureCount()</a>, <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf">GetLayerDefn()</a>, <a class="el" href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6">GetNextFeature()</a>, <a class="el" href="classOGRGeometryFactory.html#a04998dcdbb37aa37871891593c048544">OGRGeometryFactory::haveGEOS()</a>, <a class="el" href="classOGRGeometry.html#ac8653ba97e53f3e3b041946ca2acc111">OGRGeometry::IsEmpty()</a>, <a class="el" href="classOGRLayer.html#aad0f2cd7f0587584b8f382c6a913583c">ResetReading()</a>, <a class="el" href="classOGRFeature.html#a6705e5ff8b1012ce4a687b973ecddf73">OGRFeature::SetFieldsFrom()</a>, <a class="el" href="classOGRFeature.html#a40a4ddb33f09a5f340b9139be72e277d">OGRFeature::SetGeometryDirectly()</a>, and <a class="el" href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169">SetSpatialFilter()</a>.</p>

</div>
</div>
<a class="anchor" id="aebb07284c734e485d8611b7c8599254f"></a><!-- doxytag: member="OGRLayer::SyncToDisk" ref="aebb07284c734e485d8611b7c8599254f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRLayer::SyncToDisk </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flush pending changes to disk. </p>
<p>This call is intended to force the layer to flush any pending writes to disk, and leave the disk file in a consistent state. It would not normally have any effect on read-only datasources.</p>
<p>Some layers do not implement this method, and will still return OGRERR_NONE. The default implementation just returns OGRERR_NONE. An error is only returned if an error occurs while attempting to flush to disk.</p>
<p>In any event, you should always close any opened datasource with <a class="el" href="classOGRDataSource.html#a77841576d07b24a01208e4125ccb40a5" title="Closes opened datasource and releases allocated resources.">OGRDataSource::DestroyDataSource()</a> that will ensure all data is correctly flushed.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a9d845a6cf6652756925530418905471a" title="Flush pending changes to disk.">OGR_L_SyncToDisk()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE if no error occurs (even if nothing is done) or an error code. </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRLayerDecorator.html#a3b2242b1251cdf0979f8b10f56f0e3c4">OGRLayerDecorator</a>, <a class="el" href="classOGRProxiedLayer.html#a104fdff7c99d78906912ac53230765da">OGRProxiedLayer</a>, <a class="el" href="classOGRMutexedLayer.html#ad5cd220e083365ed5ef27ff713726d41">OGRMutexedLayer</a>, and <a class="el" href="classOGRUnionLayer.html#a2504c28d8bb046a55c198dbdc58e99bb">OGRUnionLayer</a>.</p>

<p>Referenced by <a class="el" href="classOGRUnionLayer.html#a2504c28d8bb046a55c198dbdc58e99bb">OGRUnionLayer::SyncToDisk()</a>, <a class="el" href="classOGRProxiedLayer.html#a104fdff7c99d78906912ac53230765da">OGRProxiedLayer::SyncToDisk()</a>, <a class="el" href="classOGRLayerDecorator.html#a3b2242b1251cdf0979f8b10f56f0e3c4">OGRLayerDecorator::SyncToDisk()</a>, and <a class="el" href="classOGRDataSource.html#a1af1c7cf202f9a2ca2310bbfa3d00cca">OGRDataSource::SyncToDisk()</a>.</p>

</div>
</div>
<a class="anchor" id="aeedbda1a62f9b89b8e5f24332cf22286"></a><!-- doxytag: member="OGRLayer::TestCapability" ref="aeedbda1a62f9b89b8e5f24332cf22286" args="(const char *)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRLayer::TestCapability </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszCap</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if this layer supported the named capability. </p>
<p>The capability codes that can be tested are represented as strings, but #defined constants exists to ensure correct spelling. Specific layer types may implement class specific capabilities, but this can't generally be discovered by the caller. </p>
<ul>
<li>
<p class="startli"><b>OLCRandomRead</b> / "RandomRead": TRUE if the <a class="el" href="classOGRLayer.html#acb7625383f161e5a04aeea2173dce411" title="Fetch a feature by its identifier.">GetFeature()</a> method is implemented in an optimized way for this layer, as opposed to the default implementation using <a class="el" href="classOGRLayer.html#aad0f2cd7f0587584b8f382c6a913583c" title="Reset feature reading to start on the first feature.">ResetReading()</a> and <a class="el" href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6" title="Fetch the next available feature from this layer.">GetNextFeature()</a> to find the requested feature id.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCSequentialWrite</b> / "SequentialWrite": TRUE if the <a class="el" href="classOGRLayer.html#aaa1e32016f481596a55e1d988a15a067" title="Create and write a new feature within a layer.">CreateFeature()</a> method works for this layer. Note this means that this particular layer is writable. The same <a class="el" href="classOGRLayer.html">OGRLayer</a> class may returned FALSE for other layer instances that are effectively read-only.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCRandomWrite</b> / "RandomWrite": TRUE if the <a class="el" href="classOGRLayer.html#a681139bfd585b74d7218e51a32144283" title="Rewrite an existing feature.">SetFeature()</a> method is operational on this layer. Note this means that this particular layer is writable. The same <a class="el" href="classOGRLayer.html">OGRLayer</a> class may returned FALSE for other layer instances that are effectively read-only.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCFastSpatialFilter</b> / "FastSpatialFilter": TRUE if this layer implements spatial filtering efficiently. Layers that effectively read all features, and test them with the <a class="el" href="classOGRFeature.html">OGRFeature</a> intersection methods should return FALSE. This can be used as a clue by the application whether it should build and maintain its own spatial index for features in this layer.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCFastFeatureCount</b> / "FastFeatureCount": TRUE if this layer can return a feature count (via <a class="el" href="classOGRLayer.html#a74c796d4ce712e9a78df6042eeb8a91a" title="Fetch the feature count in this layer.">GetFeatureCount()</a>) efficiently ... ie. without counting the features. In some cases this will return TRUE until a spatial filter is installed after which it will return FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCFastGetExtent</b> / "FastGetExtent": TRUE if this layer can return its data extent (via <a class="el" href="classOGRLayer.html#a3be658ddb5b33d1ed95c31286774bbd2" title="Fetch the extent of this layer.">GetExtent()</a>) efficiently ... ie. without scanning all the features. In some cases this will return TRUE until a spatial filter is installed after which it will return FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCFastSetNextByIndex</b> / "FastSetNextByIndex": TRUE if this layer can perform the <a class="el" href="classOGRLayer.html#ae3b6234d6077a18a19eddaf7e75ff5e1" title="Move read cursor to the nIndex&#39;th feature in the current resultset.">SetNextByIndex()</a> call efficiently, otherwise FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCCreateField</b> / "CreateField": TRUE if this layer can create new fields on the current layer using <a class="el" href="classOGRLayer.html#a00b1376a1eabb1298ef278f92f6d84be" title="Create a new field on a layer.">CreateField()</a>, otherwise FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCCreateGeomField</b> / "CreateGeomField": (GDAL &gt;= 1.11) TRUE if this layer can create new geometry fields on the current layer using <a class="el" href="classOGRLayer.html#af3c68cad279ad80a476c6fb307cf5e48" title="Create a new geometry field on a layer.">CreateGeomField()</a>, otherwise FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCDeleteField</b> / "DeleteField": TRUE if this layer can delete existing fields on the current layer using <a class="el" href="classOGRLayer.html#aaebe7c671dca995549543eecf0f7a76a" title="Delete an existing field on a layer.">DeleteField()</a>, otherwise FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCReorderFields</b> / "ReorderFields": TRUE if this layer can reorder existing fields on the current layer using <a class="el" href="classOGRLayer.html#ab4c02b991bfa78552eeb0cbcdcf1aed8" title="Reorder an existing field on a layer.">ReorderField()</a> or <a class="el" href="classOGRLayer.html#aebd364a150d91f8d65d967646e0f92d3" title="Reorder all the fields of a layer.">ReorderFields()</a>, otherwise FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCAlterFieldDefn</b> / "AlterFieldDefn": TRUE if this layer can alter the definition of an existing field on the current layer using <a class="el" href="classOGRLayer.html#a71e69a665e93001d48a4339695f33c1a" title="Alter the definition of an existing field on a layer.">AlterFieldDefn()</a>, otherwise FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCDeleteFeature</b> / "DeleteFeature": TRUE if the <a class="el" href="classOGRLayer.html#a7e3d454d54a615a1b4359628bb6e7674" title="Delete feature from layer.">DeleteFeature()</a> method is supported on this layer, otherwise FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCStringsAsUTF8</b> / "StringsAsUTF8": TRUE if values of OFTString fields are assured to be in UTF-8 format. If FALSE the encoding of fields is uncertain, though it might still be UTF-8.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCTransactions</b> / "Transactions": TRUE if the StartTransaction(), CommitTransaction() and RollbackTransaction() methods work in a meaningful way, otherwise FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCIgnoreFields</b> / "IgnoreFields": TRUE if fields, geometry and style will be omitted when fetching features as set by <a class="el" href="classOGRLayer.html#a5e0c3427f64249d1c35cefb487546b10" title="Set which fields can be omitted when retrieving features from the layer.">SetIgnoredFields()</a> method.</p>
<p></p>
<p></p>
<p class="endli"></p>
</li>
</ul>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a480adc8b839b04597f49583371d366fd" title="Test if this layer supported the named capability.">OGR_L_TestCapability()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszCap</em>&nbsp;</td><td>the name of the capability to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the layer has the requested capability, or FALSE otherwise. OGRLayers will return FALSE for any unrecognised capabilities.</dd></dl>

<p>Implemented in <a class="el" href="classOGRGenSQLResultsLayer.html#a2feae7697e868fb6862c8f2b9ed1c7e8">OGRGenSQLResultsLayer</a>, <a class="el" href="classOGRLayerDecorator.html#a6dfcc85af021e5e4095b520692761226">OGRLayerDecorator</a>, <a class="el" href="classOGRProxiedLayer.html#a40e342260c37cd6885259b89213a5dc2">OGRProxiedLayer</a>, <a class="el" href="classOGRMutexedLayer.html#af1666c0580105ce8a3addeb13dfc91ec">OGRMutexedLayer</a>, <a class="el" href="classOGRUnionLayer.html#a6ba10280ddeda91a8ec0efc29e9ef7d6">OGRUnionLayer</a>, and <a class="el" href="classOGRWarpedLayer.html#a9f186b0f0898d1a4a0af9ada5dc319bd">OGRWarpedLayer</a>.</p>

<p>Referenced by <a class="el" href="classOGRDataSource.html#a42dc7f7f538cd4f083af350722fe53ae">OGRDataSource::CopyLayer()</a>, <a class="el" href="classOGRWarpedLayer.html#a9f186b0f0898d1a4a0af9ada5dc319bd">OGRWarpedLayer::TestCapability()</a>, <a class="el" href="classOGRProxiedLayer.html#a40e342260c37cd6885259b89213a5dc2">OGRProxiedLayer::TestCapability()</a>, <a class="el" href="classOGRLayerDecorator.html#a6dfcc85af021e5e4095b520692761226">OGRLayerDecorator::TestCapability()</a>, and <a class="el" href="classOGRGenSQLResultsLayer.html#a2feae7697e868fb6862c8f2b9ed1c7e8">OGRGenSQLResultsLayer::TestCapability()</a>.</p>

</div>
</div>
<a class="anchor" id="aeb8ab475561f2aca2c0e605cfb810b22"></a><!-- doxytag: member="OGRLayer::Union" ref="aeb8ab475561f2aca2c0e605cfb810b22" args="(OGRLayer *pLayerMethod, OGRLayer *pLayerResult, char **papszOptions=NULL, GDALProgressFunc pfnProgress=NULL, void *pProgressArg=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRLayer::Union </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRLayer.html">OGRLayer</a> *&nbsp;</td>
          <td class="paramname"> <em>pLayerMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRLayer.html">OGRLayer</a> *&nbsp;</td>
          <td class="paramname"> <em>pLayerResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszOptions</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&nbsp;</td>
          <td class="paramname"> <em>pfnProgress</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pProgressArg</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Union of two layers. </p>
<p>The result layer contains features whose geometries represent areas that are in either in the input layer or in the method layer. The features in the result layer have attributes from both input and method layers. For features which represent areas that are only in the input or in the method layer the respective attributes have undefined values. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in the input and method layers.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If the schema of the result is set by user and contains fields that have the same name as a field in input and in method layer, then the attribute in the result feature will get the value from the feature of the method layer (even if it is undefined).</dd>
<dd>
For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</dd>
<dd>
This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</dd></dl>
<p>The recognized list of options is : </p>
<ul>
<li>
SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted. </li>
<li>
PROMOTE_TO_MULTI=YES/NO. Set it to YES to convert Polygons into MultiPolygons, or LineStrings to MultiLineStrings. </li>
<li>
INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer. </li>
<li>
METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer. </li>
</ul>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ac8edb8696c2b046370e29efdd73787f7" title="Union of two layers.">OGR_L_Union()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pLayerMethod</em>&nbsp;</td><td>the method layer. Should not be NULL.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pLayerResult</em>&nbsp;</td><td>the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>papszOptions</em>&nbsp;</td><td>NULL terminated list of options (may be NULL).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnProgress</em>&nbsp;</td><td>a GDALProgressFunc() compatible callback function for reporting progress or NULL.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pProgressArg</em>&nbsp;</td><td>argument to be passed to pfnProgress. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.10 </dd></dl>

<p>References <a class="el" href="classOGRGeometry.html#af4cf9f6eee1997268a481b39401c3161">OGRGeometry::clone()</a>, <a class="el" href="classOGRLayer.html#aaa1e32016f481596a55e1d988a15a067">CreateFeature()</a>, <a class="el" href="classOGRGeometry.html#ac92e1ca0e8b108ee920147d4894bde3a">OGRGeometry::Difference()</a>, <a class="el" href="classOGRGeometry.html#aadca09471fa9917452e087ba12d73eeb">OGRGeometry::getDimension()</a>, <a class="el" href="classOGRLayer.html#a74c796d4ce712e9a78df6042eeb8a91a">GetFeatureCount()</a>, <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf">GetLayerDefn()</a>, <a class="el" href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6">GetNextFeature()</a>, <a class="el" href="classOGRGeometryFactory.html#a04998dcdbb37aa37871891593c048544">OGRGeometryFactory::haveGEOS()</a>, <a class="el" href="classOGRGeometry.html#a202ad4c29487ca046c4a2b055042cb6a">OGRGeometry::Intersection()</a>, <a class="el" href="classOGRGeometry.html#ac8653ba97e53f3e3b041946ca2acc111">OGRGeometry::IsEmpty()</a>, <a class="el" href="classOGRLayer.html#aad0f2cd7f0587584b8f382c6a913583c">ResetReading()</a>, <a class="el" href="classOGRFeature.html#a6705e5ff8b1012ce4a687b973ecddf73">OGRFeature::SetFieldsFrom()</a>, <a class="el" href="classOGRFeature.html#a40a4ddb33f09a5f340b9139be72e277d">OGRFeature::SetGeometryDirectly()</a>, and <a class="el" href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169">SetSpatialFilter()</a>.</p>

</div>
</div>
<a class="anchor" id="aa1c5dc5ca195956c46d35a85b0b21d9b"></a><!-- doxytag: member="OGRLayer::Update" ref="aa1c5dc5ca195956c46d35a85b0b21d9b" args="(OGRLayer *pLayerMethod, OGRLayer *pLayerResult, char **papszOptions=NULL, GDALProgressFunc pfnProgress=NULL, void *pProgressArg=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRLayer::Update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRLayer.html">OGRLayer</a> *&nbsp;</td>
          <td class="paramname"> <em>pLayerMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRLayer.html">OGRLayer</a> *&nbsp;</td>
          <td class="paramname"> <em>pLayerResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszOptions</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&nbsp;</td>
          <td class="paramname"> <em>pfnProgress</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pProgressArg</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update this layer with features from the update layer. </p>
<p>The result layer contains features whose geometries represent areas that are either in the input layer or in the method layer. The features in the result layer have areas of the features of the method layer or those ares of the features of the input layer that are not covered by the method layer. The features of the result layer get their attributes from the input layer. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in the input layer.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If the schema of the result is set by user and contains fields that have the same name as a field in the method layer, then the attribute in the result feature the originates from the method layer will get the value from the feature of the method layer.</dd>
<dd>
For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</dd>
<dd>
This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</dd></dl>
<p>The recognized list of options is : </p>
<ul>
<li>
SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted. </li>
<li>
PROMOTE_TO_MULTI=YES/NO. Set it to YES to convert Polygons into MultiPolygons, or LineStrings to MultiLineStrings. </li>
<li>
INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer. </li>
<li>
METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer. </li>
</ul>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a87b478c971619145dee7d8d8deeac702" title="Update this layer with features from the update layer.">OGR_L_Update()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pLayerMethod</em>&nbsp;</td><td>the method layer. Should not be NULL.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pLayerResult</em>&nbsp;</td><td>the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>papszOptions</em>&nbsp;</td><td>NULL terminated list of options (may be NULL).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnProgress</em>&nbsp;</td><td>a GDALProgressFunc() compatible callback function for reporting progress or NULL.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pProgressArg</em>&nbsp;</td><td>argument to be passed to pfnProgress. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.10 </dd></dl>

<p>References <a class="el" href="classOGRGeometry.html#af4cf9f6eee1997268a481b39401c3161">OGRGeometry::clone()</a>, <a class="el" href="classOGRLayer.html#aaa1e32016f481596a55e1d988a15a067">CreateFeature()</a>, <a class="el" href="classOGRGeometry.html#ac92e1ca0e8b108ee920147d4894bde3a">OGRGeometry::Difference()</a>, <a class="el" href="classOGRLayer.html#a74c796d4ce712e9a78df6042eeb8a91a">GetFeatureCount()</a>, <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf">GetLayerDefn()</a>, <a class="el" href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6">GetNextFeature()</a>, <a class="el" href="classOGRGeometryFactory.html#a04998dcdbb37aa37871891593c048544">OGRGeometryFactory::haveGEOS()</a>, <a class="el" href="classOGRGeometry.html#ac8653ba97e53f3e3b041946ca2acc111">OGRGeometry::IsEmpty()</a>, <a class="el" href="classOGRLayer.html#aad0f2cd7f0587584b8f382c6a913583c">ResetReading()</a>, <a class="el" href="classOGRFeature.html#a6705e5ff8b1012ce4a687b973ecddf73">OGRFeature::SetFieldsFrom()</a>, <a class="el" href="classOGRFeature.html#af1181ade837a52129ea25b46dd50cf30">OGRFeature::SetGeometry()</a>, <a class="el" href="classOGRFeature.html#a40a4ddb33f09a5f340b9139be72e277d">OGRFeature::SetGeometryDirectly()</a>, and <a class="el" href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169">SetSpatialFilter()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="ogrsf__frmts_8h_source.html">ogrsf_frmts.h</a></li>
<li>ogrsf_frmts.dox</li>
<li>ogrlayer.cpp</li>
</ul>
</div>
<hr>

Generated for GDAL by 
<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.7.1.
</body>
</html>

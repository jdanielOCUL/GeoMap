<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OGR: OGRGeometry Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>OGRGeometry Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="OGRGeometry" -->
<p><code>#include &lt;<a class="el" href="ogr__geometry_8h_source.html">ogr_geometry.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for OGRGeometry:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classOGRGeometry.png" usemap="#OGRGeometry_map" alt=""/>
  <map id="OGRGeometry_map" name="OGRGeometry_map">
<area href="classOGRCurve.html" alt="OGRCurve" shape="rect" coords="0,56,149,80"/>
<area href="classOGRGeometryCollection.html" alt="OGRGeometryCollection" shape="rect" coords="318,56,467,80"/>
<area href="classOGRPoint.html" alt="OGRPoint" shape="rect" coords="477,56,626,80"/>
<area href="classOGRSurface.html" alt="OGRSurface" shape="rect" coords="636,56,785,80"/>
<area href="classOGRLineString.html" alt="OGRLineString" shape="rect" coords="0,112,149,136"/>
<area href="classOGRMultiLineString.html" alt="OGRMultiLineString" shape="rect" coords="159,112,308,136"/>
<area href="classOGRMultiPoint.html" alt="OGRMultiPoint" shape="rect" coords="318,112,467,136"/>
<area href="classOGRMultiPolygon.html" alt="OGRMultiPolygon" shape="rect" coords="477,112,626,136"/>
<area href="classOGRPolygon.html" alt="OGRPolygon" shape="rect" coords="636,112,785,136"/>
<area href="classOGRLinearRing.html" alt="OGRLinearRing" shape="rect" coords="0,168,149,192"/>
</map>
</div>

<p><a href="classOGRGeometry-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#aadca09471fa9917452e087ba12d73eeb">getDimension</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the dimension of this object.  <a href="#aadca09471fa9917452e087ba12d73eeb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a2a93f43a3b66462195b46f7fd2196dfc">getCoordinateDimension</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the dimension of the coordinates in this object.  <a href="#a2a93f43a3b66462195b46f7fd2196dfc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRBoolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ac8653ba97e53f3e3b041946ca2acc111">IsEmpty</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns TRUE (non-zero) if the object has no points.  <a href="#ac8653ba97e53f3e3b041946ca2acc111"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRBoolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a7bbb194937466a6127b5436ac2ae99d9">IsValid</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if the geometry is valid.  <a href="#a7bbb194937466a6127b5436ac2ae99d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRBoolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ab72b0c5c673d8b1cf6f870fabbeffe26">IsSimple</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if the geometry is simple.  <a href="#ab72b0c5c673d8b1cf6f870fabbeffe26"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRBoolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ad15ffdcae4351112b3106d4f87b2a3bf">IsRing</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if the geometry is a ring.  <a href="#ad15ffdcae4351112b3106d4f87b2a3bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a1702b5b8142abe761061a6cd44e50b05">empty</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear geometry information. This restores the geometry to it's initial state after construction, and before assignment of actual geometry.  <a href="#a1702b5b8142abe761061a6cd44e50b05"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#af4cf9f6eee1997268a481b39401c3161">clone</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a copy of this object.  <a href="#af4cf9f6eee1997268a481b39401c3161"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#aa3d42b06ae6f7bbef6d1a2886da8d398">getEnvelope</a> (<a class="el" href="classOGREnvelope.html">OGREnvelope</a> *psEnvelope) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure.  <a href="#aa3d42b06ae6f7bbef6d1a2886da8d398"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a3926892dbde299ffd652ee109b5967c5">getEnvelope</a> (<a class="el" href="classOGREnvelope3D.html">OGREnvelope3D</a> *psEnvelope) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes and returns the bounding envelope (3D) for this geometry in the passed psEnvelope structure.  <a href="#a3926892dbde299ffd652ee109b5967c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#acd1a8164dae2e44e50990756ed6b8b4a">WkbSize</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns size of related binary representation.  <a href="#acd1a8164dae2e44e50990756ed6b8b4a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ab2c6583c2b7c3e526dcfe54a61470c1f">importFromWkb</a> (unsigned char *, int=-1)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign geometry from well known binary data.  <a href="#ab2c6583c2b7c3e526dcfe54a61470c1f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ad46eeb33da8b6de99f1697f8de9cbea7">exportToWkb</a> (OGRwkbByteOrder, unsigned char *, <a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6">OGRwkbVariant</a>=wkbVariantOgc) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a geometry into well known binary format.  <a href="#ad46eeb33da8b6de99f1697f8de9cbea7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a30561a301d44b1f90393ea4a78a5b0a5">importFromWkt</a> (char **ppszInput)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign geometry from well known text data.  <a href="#a30561a301d44b1f90393ea4a78a5b0a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a0c941d5efdff84666af5a6f6b540aafb">exportToWkt</a> (char **ppszDstText) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a geometry into well known text format.  <a href="#a0c941d5efdff84666af5a6f6b540aafb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a5c6bca18682cb933e3227552d480e1a5">getGeometryType</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch geometry type.  <a href="#a5c6bca18682cb933e3227552d480e1a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#aba109e1c53ce1452942f85eae66d88b8">getGeometryName</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch WKT name for geometry type.  <a href="#aba109e1c53ce1452942f85eae66d88b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a2e70f05d61566a5ddaa29b44f637cfff">dumpReadable</a> (FILE *, const char *=NULL, char **papszOptions=NULL) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dump geometry in well known text format to indicated output file.  <a href="#a2e70f05d61566a5ddaa29b44f637cfff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#aaae1a2ced937a5900b2bfeb717bad6c9">flattenTo2D</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert geometry to strictly 2D. In a sense this converts all Z coordinates to 0.0.  <a href="#aaae1a2ced937a5900b2bfeb717bad6c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#aacfeca4beed34b58bed61de7cae36b4e">exportToGML</a> (const char *const *papszOptions=NULL) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a geometry into GML format.  <a href="#aacfeca4beed34b58bed61de7cae36b4e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a579b67f04630b791a229b6a7c2914640">exportToKML</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a geometry into KML format.  <a href="#a579b67f04630b791a229b6a7c2914640"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a28609fce6bd422b16182eab58ff4e812">exportToJson</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a geometry into GeoJSON format.  <a href="#a28609fce6bd422b16182eab58ff4e812"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#aeb6cf249316b3046e0d4f77ec400e844">closeRings</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Force rings to be closed.  <a href="#aeb6cf249316b3046e0d4f77ec400e844"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a79f84a2b948d511f28c47c47577dea49">setCoordinateDimension</a> (int nDimension)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the coordinate dimension.  <a href="#a79f84a2b948d511f28c47c47577dea49"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a4308e3549c65aa12cc2ba41be15d99a0">assignSpatialReference</a> (<a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *poSR)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign spatial reference to this object.  <a href="#a4308e3549c65aa12cc2ba41be15d99a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a194f0bbdae896539852106cafbffbe87">getSpatialReference</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns spatial reference system for object.  <a href="#a194f0bbdae896539852106cafbffbe87"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#aa9e8bfb3c2129f25cf622660f734e1ba">transform</a> (<a class="el" href="classOGRCoordinateTransformation.html">OGRCoordinateTransformation</a> *poCT)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Apply arbitrary coordinate transformation to geometry.  <a href="#aa9e8bfb3c2129f25cf622660f734e1ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ae3f0b441fbf2f66ce3ef3571268ab10f">transformTo</a> (<a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *poSR)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transform geometry to new spatial reference system.  <a href="#ae3f0b441fbf2f66ce3ef3571268ab10f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a91685bd7c0bdd67cd073a8b4da3c06a5">segmentize</a> (double dfMaxLength)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modify the geometry such it has no segment longer then the given distance.  <a href="#a91685bd7c0bdd67cd073a8b4da3c06a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRBoolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a0829528c9ca29059f86399da954fc8ae">Intersects</a> (<a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Do these features intersect?  <a href="#a0829528c9ca29059f86399da954fc8ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRBoolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ae751513a46c7e7b154796bfe494faf16">Equals</a> (<a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns TRUE if two geometries are equivalent.  <a href="#ae751513a46c7e7b154796bfe494faf16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRBoolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a45f683761d57c8bea40e4ca1d832760a">Disjoint</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test for disjointness.  <a href="#a45f683761d57c8bea40e4ca1d832760a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRBoolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a5d3e23c20b51ceb5a56d397f812a81a2">Touches</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test for touching.  <a href="#a5d3e23c20b51ceb5a56d397f812a81a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRBoolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ad5656df62f0857852519bea1486ab1ff">Crosses</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test for crossing.  <a href="#ad5656df62f0857852519bea1486ab1ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRBoolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#abb4bb4687de9b6f23e61b686177b2856">Within</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test for containment.  <a href="#abb4bb4687de9b6f23e61b686177b2856"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRBoolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a5e2c9296c75521ec8aff5bc2285c347f">Contains</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test for containment.  <a href="#a5e2c9296c75521ec8aff5bc2285c347f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRBoolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#afc672c524568f3ee6ee5257b250d2b12">Overlaps</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test for overlap.  <a href="#afc672c524568f3ee6ee5257b250d2b12"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a0cea06bf68f632c68a54f7356722fb1d">Boundary</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute boundary.  <a href="#a0cea06bf68f632c68a54f7356722fb1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a24fb51e9b419e97f14964e5a00ae3fb4">Distance</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute distance between two geometries.  <a href="#a24fb51e9b419e97f14964e5a00ae3fb4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ac906abd9b1cd9dd2b208a10c6e9d1bf0">ConvexHull</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute convex hull.  <a href="#ac906abd9b1cd9dd2b208a10c6e9d1bf0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ab34b27e2c8812a0fc1dccf055b11d1a2">Buffer</a> (double dfDist, int nQuadSegs=30) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute buffer of geometry.  <a href="#ab34b27e2c8812a0fc1dccf055b11d1a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a202ad4c29487ca046c4a2b055042cb6a">Intersection</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute intersection.  <a href="#a202ad4c29487ca046c4a2b055042cb6a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a15fb98d101f5887f7c3af40b6da5a3c4">Union</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute union.  <a href="#a15fb98d101f5887f7c3af40b6da5a3c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a2ba2d777083c60fe707a40d2adc36f20">UnionCascaded</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute union using cascading.  <a href="#a2ba2d777083c60fe707a40d2adc36f20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ac92e1ca0e8b108ee920147d4894bde3a">Difference</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute difference.  <a href="#ac92e1ca0e8b108ee920147d4894bde3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ac76b3046de873ada2ae7ba4de75b9ccb">SymDifference</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute symmetric difference.  <a href="#ac76b3046de873ada2ae7ba4de75b9ccb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#abc2cba699382fbb6a45229e4f5f6e792">Centroid</a> (<a class="el" href="classOGRPoint.html">OGRPoint</a> *poPoint) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the geometry centroid.  <a href="#abc2cba699382fbb6a45229e4f5f6e792"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#afd3ea0ffa1e2994427032d0212206ccf">Simplify</a> (double dTolerance) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simplify the geometry.  <a href="#afd3ea0ffa1e2994427032d0212206ccf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a6b770f62585c9e6081fda50d270ffbd9">SimplifyPreserveTopology</a> (double dTolerance) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simplify the geometry while preserving topology.  <a href="#a6b770f62585c9e6081fda50d270ffbd9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a674319670e735bf6d4049300096157ec">Polygonize</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Polygonizes a set of sparse edges.  <a href="#a674319670e735bf6d4049300096157ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a61d73b46cfa6488167dd4005f85c7ca0">SymmetricDifference</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const CPL_WARN_DEPRECATED(&quot;Non standard method. Use SymDifference() instead&quot;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute symmetric difference (deprecated).  <a href="#a61d73b46cfa6488167dd4005f85c7ca0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#af5148543fe79ff60c60793741c297346">getBoundary</a> () const CPL_WARN_DEPRECATED(&quot;Non standard method. Use Boundary() instead&quot;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute boundary (deprecated).  <a href="#af5148543fe79ff60c60793741c297346"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a3ffd51d4998a8e2ae422c69b6adf480a">swapXY</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swap x and y coordinates.  <a href="#a3ffd51d4998a8e2ae422c69b6adf480a"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Abstract base class for all geometry classes.</p>
<p>Some spatial analysis methods require that OGR is built on the GEOS library to work properly. The precise meaning of methods that describe spatial relationships between geometries is described in the SFCOM, or other simple features interface specifications, like "OpenGIS® Implementation Specification for
 Geographic information - Simple feature access - Part 1: Common architecture" (<a href="http://www.opengeospatial.org/standards/sfa">OGC 06-103r3</a>) </p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a4308e3549c65aa12cc2ba41be15d99a0"></a><!-- doxytag: member="OGRGeometry::assignSpatialReference" ref="a4308e3549c65aa12cc2ba41be15d99a0" args="(OGRSpatialReference *poSR)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::assignSpatialReference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&nbsp;</td>
          <td class="paramname"> <em>poSR</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assign spatial reference to this object. </p>
<p>Any existing spatial reference is replaced, but under no circumstances does this result in the object being reprojected. It is just changing the interpretation of the existing geometry. Note that assigning a spatial reference increments the reference count on the <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a>, but does not copy it.</p>
<p>This is similar to the SFCOM IGeometry::put_SpatialReference() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a4dfbd5861e1cd20b372d090539fa4536" title="Assign spatial reference to this object.">OGR_G_AssignSpatialReference()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poSR</em>&nbsp;</td><td>new spatial reference system to apply. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classOGRSpatialReference.html#a4b638c33c0a2b53e59fe694f26f8f89c">OGRSpatialReference::Reference()</a>, and <a class="el" href="classOGRSpatialReference.html#aef9a8378c266604b9cd09042597a649f">OGRSpatialReference::Release()</a>.</p>

<p>Referenced by <a class="el" href="classOGRGeometry.html#a0cea06bf68f632c68a54f7356722fb1d">Boundary()</a>, <a class="el" href="classOGRGeometry.html#ab34b27e2c8812a0fc1dccf055b11d1a2">Buffer()</a>, <a class="el" href="classOGRGeometry.html#abc2cba699382fbb6a45229e4f5f6e792">Centroid()</a>, <a class="el" href="classOGRPolygon.html#a723ac02b4551c683ab7ad88e6616c16b">OGRPolygon::clone()</a>, <a class="el" href="classOGRPoint.html#adacecce9c5c6a7ef7d09842827565eae">OGRPoint::clone()</a>, <a class="el" href="classOGRMultiPolygon.html#a4ef6848b2988b29c9387897debc85cc0">OGRMultiPolygon::clone()</a>, <a class="el" href="classOGRMultiPoint.html#a62e4056dc08502ac1161d8e44c434d80">OGRMultiPoint::clone()</a>, <a class="el" href="classOGRMultiLineString.html#a00cb2d7be778ad436530834bdc3cda38">OGRMultiLineString::clone()</a>, <a class="el" href="classOGRLineString.html#aa3274a231b53c920584257e15119b0f6">OGRLineString::clone()</a>, <a class="el" href="classOGRLinearRing.html#a7f64b5d73de1fc1df6e0de938e5fac63">OGRLinearRing::clone()</a>, <a class="el" href="classOGRGeometryCollection.html#ae007573cfec375b0fbb246a758b20b4c">OGRGeometryCollection::clone()</a>, <a class="el" href="classOGRGeometry.html#ac906abd9b1cd9dd2b208a10c6e9d1bf0">ConvexHull()</a>, <a class="el" href="classOGRGeometryFactory.html#a699688dba97260f2eb29f802e39cb0ec">OGRGeometryFactory::createFromWkb()</a>, <a class="el" href="classOGRGeometryFactory.html#a9418f71bcfb1e334173882c38d89d070">OGRGeometryFactory::createFromWkt()</a>, <a class="el" href="classOGRGeometry.html#ac92e1ca0e8b108ee920147d4894bde3a">Difference()</a>, <a class="el" href="classOGRGeometryFactory.html#a1c00a78cec110d71175726d6f26b1b39">OGRGeometryFactory::forceToMultiLineString()</a>, <a class="el" href="classOGRGeometryFactory.html#aa97b7837101f6c56e476520d10a9f3c3">OGRGeometryFactory::forceToMultiPoint()</a>, <a class="el" href="classOGRGeometryFactory.html#a2a40032fa65cc71c028516bf8fc0df3e">OGRGeometryFactory::forceToMultiPolygon()</a>, <a class="el" href="classOGRGeometryFactory.html#afd61936e41ea69831b3196e817658d08">OGRGeometryFactory::forceToPolygon()</a>, <a class="el" href="classOGRLineString.html#ac1f06067f941e08a4446014be51cdae6">OGRLineString::getSubLine()</a>, <a class="el" href="classOGRGeometry.html#a202ad4c29487ca046c4a2b055042cb6a">Intersection()</a>, <a class="el" href="ogr__api_8h.html#af89dc63f138aee453cf8ff3e2b1c0833">OGR_G_PointOnSurface()</a>, <a class="el" href="classOGRGeometry.html#a674319670e735bf6d4049300096157ec">Polygonize()</a>, <a class="el" href="classOGRGeometry.html#afd3ea0ffa1e2994427032d0212206ccf">Simplify()</a>, <a class="el" href="classOGRGeometry.html#a6b770f62585c9e6081fda50d270ffbd9">SimplifyPreserveTopology()</a>, <a class="el" href="classOGRGeometry.html#ac76b3046de873ada2ae7ba4de75b9ccb">SymDifference()</a>, <a class="el" href="classOGRPolygon.html#aa974efb0dd2bdc7b62fa23dfdc4f8c72">OGRPolygon::transform()</a>, <a class="el" href="classOGRPoint.html#a351482d4852285a214ac1d55ec046356">OGRPoint::transform()</a>, <a class="el" href="classOGRLineString.html#a75675b1f158fd1d5d35cc431227ed000">OGRLineString::transform()</a>, <a class="el" href="classOGRGeometryCollection.html#a39e5d3d2fbfbfccd7cdf5275f0373816">OGRGeometryCollection::transform()</a>, <a class="el" href="classOGRGeometry.html#a15fb98d101f5887f7c3af40b6da5a3c4">Union()</a>, and <a class="el" href="classOGRGeometry.html#a2ba2d777083c60fe707a40d2adc36f20">UnionCascaded()</a>.</p>

</div>
</div>
<a class="anchor" id="a0cea06bf68f632c68a54f7356722fb1d"></a><!-- doxytag: member="OGRGeometry::Boundary" ref="a0cea06bf68f632c68a54f7356722fb1d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::Boundary </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute boundary. </p>
<p>A new geometry object is created and returned containing the boundary of the geometry on which the method is invoked.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a95447f722f907b7143a1fc19005dd20b" title="Compute boundary.">OGR_G_Boundary()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a newly allocated geometry now owned by the caller, or NULL on failure.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.8.0 </dd></dl>

<p>References <a class="el" href="classOGRGeometry.html#a4308e3549c65aa12cc2ba41be15d99a0">assignSpatialReference()</a>, and <a class="el" href="classOGRGeometry.html#a194f0bbdae896539852106cafbffbe87">getSpatialReference()</a>.</p>

<p>Referenced by <a class="el" href="classOGRGeometry.html#af5148543fe79ff60c60793741c297346">getBoundary()</a>.</p>

</div>
</div>
<a class="anchor" id="ab34b27e2c8812a0fc1dccf055b11d1a2"></a><!-- doxytag: member="OGRGeometry::Buffer" ref="ab34b27e2c8812a0fc1dccf055b11d1a2" args="(double dfDist, int nQuadSegs=30) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::Buffer </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nQuadSegs</em> = <code>30</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute buffer of geometry. </p>
<p>Builds a new geometry containing the buffer region around the geometry on which it is invoked. The buffer is a polygon containing the region within the buffer distance of the original geometry.</p>
<p>Some buffer sections are properly described as curves, but are converted to approximate polygons. The nQuadSegs parameter can be used to control how many segements should be used to define a 90 degree curve - a quadrant of a circle. A value of 30 is a reasonable default. Large values result in large numbers of vertices in the resulting buffer geometry while small numbers reduce the accuracy of the result.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a1ca0bd5c0fcb4b1af3c3973e467b0ec0" title="Compute buffer of geometry.">OGR_G_Buffer()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dfDist</em>&nbsp;</td><td>the buffer distance to be applied. Should be expressed into the same unit as the coordinates of the geometry.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nQuadSegs</em>&nbsp;</td><td>the number of segments used to approximate a 90 degree (quadrant) of curvature.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly created geometry, or NULL if an error occurs. </dd></dl>

<p>References <a class="el" href="classOGRGeometry.html#a4308e3549c65aa12cc2ba41be15d99a0">assignSpatialReference()</a>, and <a class="el" href="classOGRGeometry.html#a194f0bbdae896539852106cafbffbe87">getSpatialReference()</a>.</p>

</div>
</div>
<a class="anchor" id="abc2cba699382fbb6a45229e4f5f6e792"></a><!-- doxytag: member="OGRGeometry::Centroid" ref="abc2cba699382fbb6a45229e4f5f6e792" args="(OGRPoint *poPoint) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRGeometry::Centroid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRPoint.html">OGRPoint</a> *&nbsp;</td>
          <td class="paramname"> <em>poPoint</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the geometry centroid. </p>
<p>The centroid location is applied to the passed in <a class="el" href="classOGRPoint.html">OGRPoint</a> object. The centroid is not necessarily within the geometry.</p>
<p>This method relates to the SFCOM ISurface::get_Centroid() method however the current implementation based on GEOS can operate on other geometry types such as multipoint, linestring, geometrycollection such as multipolygons. OGC SF SQL 1.1 defines the operation for surfaces (polygons). SQL/MM-Part 3 defines the operation for surfaces and multisurfaces (multipolygons).</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#a23f5a19a81628af7f9cc59a37378cb2b" title="Compute the geometry centroid.">OGR_G_Centroid()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE on success or OGRERR_FAILURE on error.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.8.0 as a <a class="el" href="classOGRGeometry.html">OGRGeometry</a> method (previously was restricted to <a class="el" href="classOGRPolygon.html">OGRPolygon</a>) </dd></dl>

<p>References <a class="el" href="classOGRGeometry.html#a4308e3549c65aa12cc2ba41be15d99a0">assignSpatialReference()</a>, <a class="el" href="classOGRPoint.html#a3f4973eec2851ff655b61c600f8bf2f9">OGRPoint::empty()</a>, <a class="el" href="classOGRGeometry.html#a5c6bca18682cb933e3227552d480e1a5">getGeometryType()</a>, <a class="el" href="classOGRGeometry.html#a194f0bbdae896539852106cafbffbe87">getSpatialReference()</a>, <a class="el" href="classOGRPoint.html#a1d7f8cb579cd0d029efda38026bf4b68">OGRPoint::getX()</a>, <a class="el" href="classOGRPoint.html#a235eac8e50f6ce105ff5c16655d05ba9">OGRPoint::getY()</a>, <a class="el" href="classOGRPoint.html#a3d25537f07a1e7dd51868f82ad7df52f">OGRPoint::IsEmpty()</a>, <a class="el" href="classOGRPoint.html#a0eef5e2d9e0edeca0e0f06c7527facb4">OGRPoint::setX()</a>, <a class="el" href="classOGRPoint.html#ab064eaaedb2140ed1410e7c2ce4ad1ca">OGRPoint::setY()</a>, and <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa6f8377c5a4a9d36ae2384f4a5f45d77f">wkbPoint</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a23f5a19a81628af7f9cc59a37378cb2b">OGR_G_Centroid()</a>.</p>

</div>
</div>
<a class="anchor" id="af4cf9f6eee1997268a481b39401c3161"></a><!-- doxytag: member="OGRGeometry::clone" ref="af4cf9f6eee1997268a481b39401c3161" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::clone </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a copy of this object. </p>
<p>This method relates to the SFCOM IGeometry::clone() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a1725918932da7d59f9ee72829ac171fa" title="Make a copy of this object.">OGR_G_Clone()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new object instance with the same geometry, and spatial reference system as the original. </dd></dl>

<p>Implemented in <a class="el" href="classOGRPoint.html#adacecce9c5c6a7ef7d09842827565eae">OGRPoint</a>, <a class="el" href="classOGRLineString.html#aa3274a231b53c920584257e15119b0f6">OGRLineString</a>, <a class="el" href="classOGRLinearRing.html#a7f64b5d73de1fc1df6e0de938e5fac63">OGRLinearRing</a>, <a class="el" href="classOGRPolygon.html#a723ac02b4551c683ab7ad88e6616c16b">OGRPolygon</a>, <a class="el" href="classOGRGeometryCollection.html#ae007573cfec375b0fbb246a758b20b4c">OGRGeometryCollection</a>, <a class="el" href="classOGRMultiPolygon.html#a4ef6848b2988b29c9387897debc85cc0">OGRMultiPolygon</a>, <a class="el" href="classOGRMultiPoint.html#a62e4056dc08502ac1161d8e44c434d80">OGRMultiPoint</a>, and <a class="el" href="classOGRMultiLineString.html#a00cb2d7be778ad436530834bdc3cda38">OGRMultiLineString</a>.</p>

<p>Referenced by <a class="el" href="classOGRGeometryCollection.html#a3da519655d14346e591d22a547562b0c">OGRGeometryCollection::addGeometry()</a>, <a class="el" href="classOGRLayer.html#a56d7ee3b2020e53c730d67ee4f1e2fb6">OGRLayer::Clip()</a>, <a class="el" href="classOGRLayer.html#ae8fcf55ffa259f32df35edcb05274439">OGRLayer::Erase()</a>, <a class="el" href="classOGRLayer.html#acb7625383f161e5a04aeea2173dce411">OGRLayer::GetFeature()</a>, <a class="el" href="classOGRLayer.html#acac6a0bde9737555b22c6ac7fa967431">OGRLayer::Identity()</a>, <a class="el" href="classOGRFeature.html#a26d865b737d699a12f260ee0a75588b9">OGRFeature::SetGeomField()</a>, <a class="el" href="classOGRLayer.html#a781aa76c6b44b19de09f61816e32245b">OGRLayer::SymDifference()</a>, <a class="el" href="classOGRLayer.html#aeb8ab475561f2aca2c0e605cfb810b22">OGRLayer::Union()</a>, and <a class="el" href="classOGRLayer.html#aa1c5dc5ca195956c46d35a85b0b21d9b">OGRLayer::Update()</a>.</p>

</div>
</div>
<a class="anchor" id="aeb6cf249316b3046e0d4f77ec400e844"></a><!-- doxytag: member="OGRGeometry::closeRings" ref="aeb6cf249316b3046e0d4f77ec400e844" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::closeRings </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Force rings to be closed. </p>
<p>If this geometry, or any contained geometries has polygon rings that are not closed, they will be closed by adding the starting point at the end. </p>

<p>Reimplemented in <a class="el" href="classOGRLinearRing.html#a78d316c3e146dc8ee23a58336162d68a">OGRLinearRing</a>, <a class="el" href="classOGRPolygon.html#af5f15a5673fde9522b4e70abdb9cec93">OGRPolygon</a>, and <a class="el" href="classOGRGeometryCollection.html#a73648d3d592a8a804d160bf0c69648cc">OGRGeometryCollection</a>.</p>

</div>
</div>
<a class="anchor" id="a5e2c9296c75521ec8aff5bc2285c347f"></a><!-- doxytag: member="OGRGeometry::Contains" ref="a5e2c9296c75521ec8aff5bc2285c347f" args="(const OGRGeometry *) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRBoolean OGRGeometry::Contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td>
          <td class="paramname"> <em>poOtherGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test for containment. </p>
<p>Tests if actual geometry object contains the passed geometry.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ad87e37380f0320faddbe5e67e23312f8" title="Test for containment.">OGR_G_Contains()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poOtherGeom</em>&nbsp;</td><td>the geometry to compare to this geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if poOtherGeom contains this geometry, otherwise FALSE. </dd></dl>

</div>
</div>
<a class="anchor" id="ac906abd9b1cd9dd2b208a10c6e9d1bf0"></a><!-- doxytag: member="OGRGeometry::ConvexHull" ref="ac906abd9b1cd9dd2b208a10c6e9d1bf0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::ConvexHull </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute convex hull. </p>
<p>A new geometry object is created and returned containing the convex hull of the geometry on which the method is invoked.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a7a93026cfae8ee6ce25546dba1b2df7d" title="Compute convex hull.">OGR_G_ConvexHull()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a newly allocated geometry now owned by the caller, or NULL on failure. </dd></dl>

<p>References <a class="el" href="classOGRGeometry.html#a4308e3549c65aa12cc2ba41be15d99a0">assignSpatialReference()</a>, and <a class="el" href="classOGRGeometry.html#a194f0bbdae896539852106cafbffbe87">getSpatialReference()</a>.</p>

</div>
</div>
<a class="anchor" id="ad5656df62f0857852519bea1486ab1ff"></a><!-- doxytag: member="OGRGeometry::Crosses" ref="ad5656df62f0857852519bea1486ab1ff" args="(const OGRGeometry *) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRBoolean OGRGeometry::Crosses </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td>
          <td class="paramname"> <em>poOtherGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test for crossing. </p>
<p>Tests if this geometry and the other passed into the method are crossing.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a7af82e14406879c08841331b2a4cfe7c" title="Test for crossing.">OGR_G_Crosses()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poOtherGeom</em>&nbsp;</td><td>the geometry to compare to this geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if they are crossing, otherwise FALSE. </dd></dl>

</div>
</div>
<a class="anchor" id="ac92e1ca0e8b108ee920147d4894bde3a"></a><!-- doxytag: member="OGRGeometry::Difference" ref="ac92e1ca0e8b108ee920147d4894bde3a" args="(const OGRGeometry *) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::Difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td>
          <td class="paramname"> <em>poOtherGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute difference. </p>
<p>Generates a new geometry which is the region of this geometry with the region of the second geometry removed.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a497977bec6ecd9dade7a9694f776be64" title="Compute difference.">OGR_G_Difference()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poOtherGeom</em>&nbsp;</td><td>the other geometry removed from "this" geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new geometry representing the difference or NULL if the difference is empty or an error occurs. </dd></dl>

<p>References <a class="el" href="classOGRGeometry.html#a4308e3549c65aa12cc2ba41be15d99a0">assignSpatialReference()</a>, <a class="el" href="classOGRGeometry.html#a194f0bbdae896539852106cafbffbe87">getSpatialReference()</a>, and <a class="el" href="classOGRSpatialReference.html#a17fd82b2f58a976a30358b076a2fc966">OGRSpatialReference::IsSame()</a>.</p>

<p>Referenced by <a class="el" href="classOGRLayer.html#ae8fcf55ffa259f32df35edcb05274439">OGRLayer::Erase()</a>, <a class="el" href="classOGRLayer.html#acac6a0bde9737555b22c6ac7fa967431">OGRLayer::Identity()</a>, <a class="el" href="classOGRLayer.html#a781aa76c6b44b19de09f61816e32245b">OGRLayer::SymDifference()</a>, <a class="el" href="classOGRLayer.html#aeb8ab475561f2aca2c0e605cfb810b22">OGRLayer::Union()</a>, and <a class="el" href="classOGRLayer.html#aa1c5dc5ca195956c46d35a85b0b21d9b">OGRLayer::Update()</a>.</p>

</div>
</div>
<a class="anchor" id="a45f683761d57c8bea40e4ca1d832760a"></a><!-- doxytag: member="OGRGeometry::Disjoint" ref="a45f683761d57c8bea40e4ca1d832760a" args="(const OGRGeometry *) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRBoolean OGRGeometry::Disjoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td>
          <td class="paramname"> <em>poOtherGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test for disjointness. </p>
<p>Tests if this geometry and the other passed into the method are disjoint.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a7980d65f3d82d5a5442c5141efe3f503" title="Test for disjointness.">OGR_G_Disjoint()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poOtherGeom</em>&nbsp;</td><td>the geometry to compare to this geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if they are disjoint, otherwise FALSE. </dd></dl>

</div>
</div>
<a class="anchor" id="a24fb51e9b419e97f14964e5a00ae3fb4"></a><!-- doxytag: member="OGRGeometry::Distance" ref="a24fb51e9b419e97f14964e5a00ae3fb4" args="(const OGRGeometry *) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGRGeometry::Distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td>
          <td class="paramname"> <em>poOtherGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute distance between two geometries. </p>
<p>Returns the shortest distance between the two geometries. The distance is expressed into the same unit as the coordinates of the geometries.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ab01002a9fd4175832af965930f069401" title="Compute distance between two geometries.">OGR_G_Distance()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poOtherGeom</em>&nbsp;</td><td>the other geometry to compare against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the distance between the geometries or -1 if an error occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="a2e70f05d61566a5ddaa29b44f637cfff"></a><!-- doxytag: member="OGRGeometry::dumpReadable" ref="a2e70f05d61566a5ddaa29b44f637cfff" args="(FILE *, const char *=NULL, char **papszOptions=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::dumpReadable </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszPrefix</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszOptions</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dump geometry in well known text format to indicated output file. </p>
<p>A few options can be defined to change the default dump : </p>
<ul>
<li>
DISPLAY_GEOMETRY=NO : to hide the dump of the geometry </li>
<li>
DISPLAY_GEOMETRY=WKT or YES (default) : dump the geometry as a WKT </li>
<li>
DISPLAY_GEOMETRY=SUMMARY : to get only a summary of the geometry </li>
</ul>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a3a99330bd108940f8a33036c0f83119f" title="Dump geometry in well known text format to indicated output file.">OGR_G_DumpReadable()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fp</em>&nbsp;</td><td>the text file to write the geometry to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszPrefix</em>&nbsp;</td><td>the prefix to put on each line of output. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>papszOptions</em>&nbsp;</td><td>NULL terminated list of options (may be NULL) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classOGRGeometry.html#a2e70f05d61566a5ddaa29b44f637cfff">dumpReadable()</a>, <a class="el" href="classOGRGeometry.html#a0c941d5efdff84666af5a6f6b540aafb">exportToWkt()</a>, <a class="el" href="classOGRPolygon.html#ad4ba927fb74871bf029e6a3efec3586c">OGRPolygon::getExteriorRing()</a>, <a class="el" href="classOGRGeometry.html#aba109e1c53ce1452942f85eae66d88b8">getGeometryName()</a>, <a class="el" href="classOGRGeometryCollection.html#ad609f2c7886918a766dd3d3a4fa52ec3">OGRGeometryCollection::getGeometryRef()</a>, <a class="el" href="classOGRGeometry.html#a5c6bca18682cb933e3227552d480e1a5">getGeometryType()</a>, <a class="el" href="classOGRPolygon.html#af0bf0b1d1104e142b47637659518ad9c">OGRPolygon::getInteriorRing()</a>, <a class="el" href="classOGRGeometryCollection.html#a878ea43754b6c6dc824d3a0d1b3dd0e3">OGRGeometryCollection::getNumGeometries()</a>, <a class="el" href="classOGRPolygon.html#a3b996195adcf9fcd4f33570a37753dde">OGRPolygon::getNumInteriorRings()</a>, <a class="el" href="classOGRLineString.html#a7ea70605cd6ac71221177586c2ec5cfc">OGRLineString::getNumPoints()</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa7f299e8edaee30fd3c7a40baf19b48b1">wkbGeometryCollection</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa4f5e3e491182628c831ed8124ec64e96">wkbGeometryCollection25D</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa48a515899277ce8ccd0bb6041fd42bcc">wkbLinearRing</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa09fd8f51759a1cf351b04e786a2a9058">wkbLineString</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aacf06aa306a087638fa4bebb7caf01ce1">wkbLineString25D</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa2ecf4d40ab038779cbc1de22ddcb3429">wkbMultiLineString</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aaebb9eb043391cd9f4c98f465dcc5b41b">wkbMultiLineString25D</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa826c812d3551fa07feb4c3664517c29c">wkbMultiPoint</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa95019b3d8d9acf9730406a455e646e15">wkbMultiPoint25D</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa7ff2322e0696d383d7715b7e7be1a7b1">wkbMultiPolygon</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa222e72c0c3e89838350888948f2e6af2">wkbMultiPolygon25D</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa988c33f9e94f35d2081e5882d4167ec6">wkbNone</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa6f8377c5a4a9d36ae2384f4a5f45d77f">wkbPoint</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa18b9353087d48fa575fa0e3281b46f13">wkbPoint25D</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa11991cd1245f146f3efd694553433aeb">wkbPolygon</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa05fb2cddfbd20fb5c7c684cb765ef897">wkbPolygon25D</a>, and <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa3645f782f9b9f7632d7e7cdd0451d58f">wkbUnknown</a>.</p>

<p>Referenced by <a class="el" href="classOGRGeometry.html#a2e70f05d61566a5ddaa29b44f637cfff">dumpReadable()</a>, and <a class="el" href="classOGRFeature.html#a6c787aeb650bd03420309ca4f52c0083">OGRFeature::DumpReadable()</a>.</p>

</div>
</div>
<a class="anchor" id="a1702b5b8142abe761061a6cd44e50b05"></a><!-- doxytag: member="OGRGeometry::empty" ref="a1702b5b8142abe761061a6cd44e50b05" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::empty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear geometry information. This restores the geometry to it's initial state after construction, and before assignment of actual geometry. </p>
<p>This method relates to the SFCOM IGeometry::Empty() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a90cc83b0a3052b8fbe2ed77a86323bf2" title="Clear geometry information. This restores the geometry to it&#39;s initial state after construction...">OGR_G_Empty()</a>. </p>

<p>Implemented in <a class="el" href="classOGRPoint.html#a3f4973eec2851ff655b61c600f8bf2f9">OGRPoint</a>, <a class="el" href="classOGRLineString.html#a958cec2e062c6372131139be247aecdb">OGRLineString</a>, <a class="el" href="classOGRPolygon.html#a8e8ea1eb8916cf60a69650fd3a9025f9">OGRPolygon</a>, and <a class="el" href="classOGRGeometryCollection.html#a9aead953ce5cc3076d9d4e4a85c6f68d">OGRGeometryCollection</a>.</p>

</div>
</div>
<a class="anchor" id="ae751513a46c7e7b154796bfe494faf16"></a><!-- doxytag: member="OGRGeometry::Equals" ref="ae751513a46c7e7b154796bfe494faf16" args="(OGRGeometry *) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRGeometry::Equals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td>
          <td class="paramname"> <em>poOtherGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns TRUE if two geometries are equivalent. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#abaed0c4fb6f08abc280f91619e2e47d3" title="Returns TRUE if two geometries are equivalent.">OGR_G_Equals()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if equivalent or FALSE otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classOGRPoint.html#a4e04bfdd79cbf0c74d90ef20e99f13a3">OGRPoint</a>, <a class="el" href="classOGRLineString.html#a8568a09caf084295b39df28c31586c01">OGRLineString</a>, <a class="el" href="classOGRPolygon.html#a5daaf7cbfb1263a4b9fc126f5c51cf37">OGRPolygon</a>, and <a class="el" href="classOGRGeometryCollection.html#ae25defac0e02404820e7a8b6dc712f44">OGRGeometryCollection</a>.</p>

<p>Referenced by <a class="el" href="classOGRFeature.html#a738dfd54ecb6fb86e294929e91f90479">OGRFeature::Equal()</a>, and <a class="el" href="classOGRGeometryCollection.html#ae25defac0e02404820e7a8b6dc712f44">OGRGeometryCollection::Equals()</a>.</p>

</div>
</div>
<a class="anchor" id="aacfeca4beed34b58bed61de7cae36b4e"></a><!-- doxytag: member="OGRGeometry::exportToGML" ref="aacfeca4beed34b58bed61de7cae36b4e" args="(const char *const *papszOptions=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * OGRGeometry::exportToGML </td>
          <td>(</td>
          <td class="paramtype">const char *const *&nbsp;</td>
          <td class="paramname"> <em>papszOptions</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a geometry into GML format. </p>
<p>The GML geometry is expressed directly in terms of GML basic data types assuming the this is available in the gml namespace. The returned string should be freed with CPLFree() when no longer required.</p>
<p>The supported options in OGR 1.8.0 are : </p>
<ul>
<li>
FORMAT=GML3. Otherwise it will default to GML 2.1.2 output. </li>
<li>
GML3_LINESTRING_ELEMENT=curve. (Only valid for FORMAT=GML3) To use gml:Curve element for linestrings. Otherwise gml:LineString will be used . </li>
<li>
GML3_LONGSRS=YES/NO. (Only valid for FORMAT=GML3) Default to YES. If YES, SRS with EPSG authority will be written with the "urn:ogc:def:crs:EPSG::" prefix. In the case, if the SRS is a geographic SRS without explicit AXIS order, but that the same SRS authority code imported with ImportFromEPSGA() should be treated as lat/long, then the function will take care of coordinate order swapping. If set to NO, SRS with EPSG authority will be written with the "EPSG:" prefix, even if they are in lat/long order. </li>
</ul>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a06fc1cec4a17a2926640f95c6bf7a442" title="Convert a geometry into GML format.">OGR_G_ExportToGMLEx()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>papszOptions</em>&nbsp;</td><td>NULL-terminated list of options. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A GML fragment or NULL in case of error. </dd></dl>

</div>
</div>
<a class="anchor" id="a28609fce6bd422b16182eab58ff4e812"></a><!-- doxytag: member="OGRGeometry::exportToJson" ref="a28609fce6bd422b16182eab58ff4e812" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * OGRGeometry::exportToJson </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a geometry into GeoJSON format. </p>
<p>The returned string should be freed with CPLFree() when no longer required.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a9ebd5fa6a9b67ff6ce5a7e4cd0238a47" title="Convert a geometry into GeoJSON format.">OGR_G_ExportToJson()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A GeoJSON fragment or NULL in case of error. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a9ebd5fa6a9b67ff6ce5a7e4cd0238a47">OGR_G_ExportToJson()</a>.</p>

</div>
</div>
<a class="anchor" id="a579b67f04630b791a229b6a7c2914640"></a><!-- doxytag: member="OGRGeometry::exportToKML" ref="a579b67f04630b791a229b6a7c2914640" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * OGRGeometry::exportToKML </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a geometry into KML format. </p>
<p>The returned string should be freed with CPLFree() when no longer required.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a27b1389e05c84261a7b612aefedd0ed3" title="Convert a geometry into KML format.">OGR_G_ExportToKML()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A KML fragment or NULL in case of error. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a27b1389e05c84261a7b612aefedd0ed3">OGR_G_ExportToKML()</a>.</p>

</div>
</div>
<a class="anchor" id="ad46eeb33da8b6de99f1697f8de9cbea7"></a><!-- doxytag: member="OGRGeometry::exportToWkb" ref="ad46eeb33da8b6de99f1697f8de9cbea7" args="(OGRwkbByteOrder, unsigned char *, OGRwkbVariant=wkbVariantOgc) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRGeometry::exportToWkb </td>
          <td>(</td>
          <td class="paramtype">OGRwkbByteOrder&nbsp;</td>
          <td class="paramname"> <em>eByteOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>pabyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6">OGRwkbVariant</a>&nbsp;</td>
          <td class="paramname"> <em>eWkbVariant</em> = <code>wkbVariantOgc</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a geometry into well known binary format. </p>
<p>This method relates to the SFCOM IWks::ExportToWKB() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ad5c94ae76c09774dba8725c24daeefd6" title="Convert a geometry into well known binary format.">OGR_G_ExportToWkb()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>eByteOrder</em>&nbsp;</td><td>One of wkbXDR or wkbNDR indicating MSB or LSB byte order respectively. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pabyData</em>&nbsp;</td><td>a buffer into which the binary representation is written. This buffer must be at least <a class="el" href="classOGRGeometry.html#acd1a8164dae2e44e50990756ed6b8b4a" title="Returns size of related binary representation.">OGRGeometry::WkbSize()</a> byte in size. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eWkbVariant</em>&nbsp;</td><td>What standard to use when exporting geometries with three dimensions (or more). The default wkbVariantOgc is the historical OGR variant. wkbVariantIso is the variant defined in ISO SQL/MM and adopted by OGC for SFSQL 1.2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Currently OGRERR_NONE is always returned. </dd></dl>

<p>Implemented in <a class="el" href="classOGRPoint.html#a68ad925c5d179e239019ef8687a757af">OGRPoint</a>, <a class="el" href="classOGRLineString.html#a5f42f63e964b2dff78b7b5529de79731">OGRLineString</a>, <a class="el" href="classOGRLinearRing.html#ad76cb37e03397d966c76855c422f3975">OGRLinearRing</a>, <a class="el" href="classOGRPolygon.html#acad2d60fac70ce252616ce8bcff006d5">OGRPolygon</a>, and <a class="el" href="classOGRGeometryCollection.html#abbd2d1f722a5f0b8d56c0f648867241e">OGRGeometryCollection</a>.</p>

<p>Referenced by <a class="el" href="classOGRGeometryCollection.html#abbd2d1f722a5f0b8d56c0f648867241e">OGRGeometryCollection::exportToWkb()</a>.</p>

</div>
</div>
<a class="anchor" id="a0c941d5efdff84666af5a6f6b540aafb"></a><!-- doxytag: member="OGRGeometry::exportToWkt" ref="a0c941d5efdff84666af5a6f6b540aafb" args="(char **ppszDstText) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRGeometry::exportToWkt </td>
          <td>(</td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>ppszDstText</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a geometry into well known text format. </p>
<p>This method relates to the SFCOM IWks::ExportToWKT() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a3bc9310302e2dbfaab1690de9e2fd2fb" title="Convert a geometry into well known text format.">OGR_G_ExportToWkt()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ppszDstText</em>&nbsp;</td><td>a text buffer is allocated by the program, and assigned to the passed pointer. After use, *ppszDstText should be freed with OGRFree().</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Currently OGRERR_NONE is always returned. </dd></dl>

<p>Implemented in <a class="el" href="classOGRPoint.html#a2cb15e548a3d3ecaf8c2acfc1e03b40a">OGRPoint</a>, <a class="el" href="classOGRLineString.html#a80aa40481584eca17808d1abacb435f9">OGRLineString</a>, <a class="el" href="classOGRPolygon.html#ade6a6d5d628f3ad57d0ce9dca8e26618">OGRPolygon</a>, <a class="el" href="classOGRGeometryCollection.html#a6612b05d85871c92b24015457883de1c">OGRGeometryCollection</a>, <a class="el" href="classOGRMultiPolygon.html#a21f4a8e2e947c55e9e83b563240bf63e">OGRMultiPolygon</a>, <a class="el" href="classOGRMultiPoint.html#ad8ece50b6411e915bf53d8f31de041ff">OGRMultiPoint</a>, and <a class="el" href="classOGRMultiLineString.html#ad26a712732139dbec7d827a65e273d68">OGRMultiLineString</a>.</p>

<p>Referenced by <a class="el" href="classOGRGeometry.html#a2e70f05d61566a5ddaa29b44f637cfff">dumpReadable()</a>, <a class="el" href="classOGRMultiPolygon.html#a21f4a8e2e947c55e9e83b563240bf63e">OGRMultiPolygon::exportToWkt()</a>, <a class="el" href="classOGRMultiLineString.html#ad26a712732139dbec7d827a65e273d68">OGRMultiLineString::exportToWkt()</a>, and <a class="el" href="classOGRGeometryCollection.html#a6612b05d85871c92b24015457883de1c">OGRGeometryCollection::exportToWkt()</a>.</p>

</div>
</div>
<a class="anchor" id="aaae1a2ced937a5900b2bfeb717bad6c9"></a><!-- doxytag: member="OGRGeometry::flattenTo2D" ref="aaae1a2ced937a5900b2bfeb717bad6c9" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::flattenTo2D </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert geometry to strictly 2D. In a sense this converts all Z coordinates to 0.0. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#afdb7354b55c7448b60b44cd9e36073b8" title="Convert geometry to strictly 2D. In a sense this converts all Z coordinates to 0.0.">OGR_G_FlattenTo2D()</a>. </p>

<p>Implemented in <a class="el" href="classOGRPoint.html#aefb1c9e09c101735d8617f30109b3685">OGRPoint</a>, <a class="el" href="classOGRLineString.html#a79882a4aba981daf0f2af80d1fbb9b21">OGRLineString</a>, <a class="el" href="classOGRPolygon.html#a3b8a81f9742e981c242668d2d4d4a69d">OGRPolygon</a>, and <a class="el" href="classOGRGeometryCollection.html#a954d008774d80ad0637bc25088746eea">OGRGeometryCollection</a>.</p>

</div>
</div>
<a class="anchor" id="af5148543fe79ff60c60793741c297346"></a><!-- doxytag: member="OGRGeometry::getBoundary" ref="af5148543fe79ff60c60793741c297346" args="() const CPL_WARN_DEPRECATED(&quot;Non standard method. Use Boundary() instead&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::getBoundary </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute boundary (deprecated). </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOGRGeometry.html#a0cea06bf68f632c68a54f7356722fb1d" title="Compute boundary.">Boundary()</a> </dd></dl>

<p>References <a class="el" href="classOGRGeometry.html#a0cea06bf68f632c68a54f7356722fb1d">Boundary()</a>.</p>

</div>
</div>
<a class="anchor" id="a2a93f43a3b66462195b46f7fd2196dfc"></a><!-- doxytag: member="OGRGeometry::getCoordinateDimension" ref="a2a93f43a3b66462195b46f7fd2196dfc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRGeometry::getCoordinateDimension </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the dimension of the coordinates in this object. </p>
<p>This method corresponds to the SFCOM IGeometry::GetDimension() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a8a5e78b0753339d1cdd282b0e151d28f" title="Get the dimension of the coordinates in this geometry.">OGR_G_GetCoordinateDimension()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>in practice this will return 2 or 3. It can also return 0 in the case of an empty point. </dd></dl>

<p>Referenced by <a class="el" href="classOGRGeometryCollection.html#a8422907a01d088ec5ef916382bea8eb3">OGRGeometryCollection::addGeometryDirectly()</a>, <a class="el" href="classOGRLineString.html#aeadb4c3f26162e12eadc311d8ec8ef9f">OGRLineString::addPoint()</a>, <a class="el" href="classOGRPolygon.html#a6a2400d013a7538169b6f610499d9e30">OGRPolygon::addRing()</a>, <a class="el" href="classOGRPolygon.html#a17f7fca852efca8155fba7cbad7572c0">OGRPolygon::addRingDirectly()</a>, <a class="el" href="classOGRLineString.html#aa3274a231b53c920584257e15119b0f6">OGRLineString::clone()</a>, <a class="el" href="classOGRPolygon.html#acad2d60fac70ce252616ce8bcff006d5">OGRPolygon::exportToWkb()</a>, <a class="el" href="classOGRLineString.html#a5f42f63e964b2dff78b7b5529de79731">OGRLineString::exportToWkb()</a>, <a class="el" href="classOGRPolygon.html#ade6a6d5d628f3ad57d0ce9dca8e26618">OGRPolygon::exportToWkt()</a>, <a class="el" href="classOGRMultiPoint.html#ad8ece50b6411e915bf53d8f31de041ff">OGRMultiPoint::exportToWkt()</a>, <a class="el" href="classOGRLineString.html#a80aa40481584eca17808d1abacb435f9">OGRLineString::exportToWkt()</a>, <a class="el" href="classOGRMultiPolygon.html#a3d06dca158cbe0375bfe1baf0927b13b">OGRMultiPolygon::getGeometryType()</a>, <a class="el" href="classOGRMultiPoint.html#a1608a1b94dfb29122c42a4ac8f1b77d4">OGRMultiPoint::getGeometryType()</a>, <a class="el" href="classOGRMultiLineString.html#a960c59e32e54ca010393e5c749c64b50">OGRMultiLineString::getGeometryType()</a>, <a class="el" href="classOGRGeometryCollection.html#ac0ce5876364a826479eb2a10815fea60">OGRGeometryCollection::getGeometryType()</a>, <a class="el" href="classOGRLineString.html#aab63760022e49a795477f2fd31da059f">OGRLineString::getPoint()</a>, <a class="el" href="classOGRLineString.html#ac1f06067f941e08a4446014be51cdae6">OGRLineString::getSubLine()</a>, <a class="el" href="classOGRLineString.html#aee1a3d911818f745cf22e30d53ed160d">OGRLineString::segmentize()</a>, <a class="el" href="classOGRLineString.html#a7d7d288f869c9431a88d2012d96132b9">OGRLineString::setNumPoints()</a>, <a class="el" href="classOGRLineString.html#a68fe89e30ccbfaf76c481349c13968c4">OGRLineString::setPoint()</a>, <a class="el" href="classOGRLineString.html#a49a2c161f48b2bd5ad6c7e2832c0cf15">OGRLineString::setPoints()</a>, <a class="el" href="classOGRLineString.html#a1298b99690b359cc37aa7314a6c150a0">OGRLineString::Value()</a>, <a class="el" href="classOGRPolygon.html#ad8193c4d42032c4106bdccb907bc66ab">OGRPolygon::WkbSize()</a>, and <a class="el" href="classOGRLineString.html#a1aabd7032d6579f4fa17fc3849c6a353">OGRLineString::WkbSize()</a>.</p>

</div>
</div>
<a class="anchor" id="aadca09471fa9917452e087ba12d73eeb"></a><!-- doxytag: member="OGRGeometry::getDimension" ref="aadca09471fa9917452e087ba12d73eeb" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRGeometry::getDimension </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the dimension of this object. </p>
<p>This method corresponds to the SFCOM IGeometry::GetDimension() method. It indicates the dimension of the object, but does not indicate the dimension of the underlying space (as indicated by <a class="el" href="classOGRGeometry.html#a2a93f43a3b66462195b46f7fd2196dfc" title="Get the dimension of the coordinates in this object.">OGRGeometry::getCoordinateDimension()</a>).</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a94b633e1acd208c258ad49f8d4fd4104" title="Get the dimension of this geometry.">OGR_G_GetDimension()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 for points, 1 for lines and 2 for surfaces. </dd></dl>

<p>Implemented in <a class="el" href="classOGRPoint.html#a0466937038d945f8f1f35c6ca1dfd4ca">OGRPoint</a>, <a class="el" href="classOGRLineString.html#a9ef03e6376a2dbaa10181f282f2b1f42">OGRLineString</a>, <a class="el" href="classOGRPolygon.html#ad395f8c5a45dfa639b3c9aa71a303fae">OGRPolygon</a>, <a class="el" href="classOGRGeometryCollection.html#a611f61007e92d5e5807748b48450880c">OGRGeometryCollection</a>, <a class="el" href="classOGRMultiPolygon.html#aef30f371895a820c4795b89a35caa0bd">OGRMultiPolygon</a>, <a class="el" href="classOGRMultiPoint.html#a8523d38e7abe21e3276a0ed1fe02508e">OGRMultiPoint</a>, and <a class="el" href="classOGRMultiLineString.html#a88555179485b08a4d528cf97aa247699">OGRMultiLineString</a>.</p>

<p>Referenced by <a class="el" href="classOGRGeometryCollection.html#a611f61007e92d5e5807748b48450880c">OGRGeometryCollection::getDimension()</a>, <a class="el" href="classOGRLayer.html#acac6a0bde9737555b22c6ac7fa967431">OGRLayer::Identity()</a>, <a class="el" href="classOGRLayer.html#ac189f54996c2d6fd769889ec99e0f48a">OGRLayer::Intersection()</a>, and <a class="el" href="classOGRLayer.html#aeb8ab475561f2aca2c0e605cfb810b22">OGRLayer::Union()</a>.</p>

</div>
</div>
<a class="anchor" id="aa3d42b06ae6f7bbef6d1a2886da8d398"></a><!-- doxytag: member="OGRGeometry::getEnvelope" ref="aa3d42b06ae6f7bbef6d1a2886da8d398" args="(OGREnvelope *psEnvelope) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::getEnvelope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGREnvelope.html">OGREnvelope</a> *&nbsp;</td>
          <td class="paramname"> <em>psEnvelope</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a617a9c9ea85157661619a1d8f0a69cf9" title="Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure...">OGR_G_GetEnvelope()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psEnvelope</em>&nbsp;</td><td>the structure in which to place the results. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classOGRPoint.html#ac080db52ee9343fbaa448b2f038cdfe4">OGRPoint</a>, <a class="el" href="classOGRLineString.html#acd1805288a923f93a147b643f45e8e68">OGRLineString</a>, <a class="el" href="classOGRPolygon.html#a00a97e4a76eafe94b5cbb9d52d722457">OGRPolygon</a>, and <a class="el" href="classOGRGeometryCollection.html#a4319e7dea4967dfc1e5a7d4bcdb8e5ff">OGRGeometryCollection</a>.</p>

<p>Referenced by <a class="el" href="classOGRGeometryCollection.html#a4319e7dea4967dfc1e5a7d4bcdb8e5ff">OGRGeometryCollection::getEnvelope()</a>, <a class="el" href="classOGRLayer.html#ac189f54996c2d6fd769889ec99e0f48a">OGRLayer::Intersection()</a>, <a class="el" href="classOGRGeometry.html#a0829528c9ca29059f86399da954fc8ae">Intersects()</a>, <a class="el" href="classOGRGeometryFactory.html#afa3e76499553c3dc0a1621af98b88be6">OGRGeometryFactory::organizePolygons()</a>, and <a class="el" href="classOGRWarpedLayer.html#a50e1332a6d2bd495422e1ef83ca6a246">OGRWarpedLayer::SetSpatialFilter()</a>.</p>

</div>
</div>
<a class="anchor" id="a3926892dbde299ffd652ee109b5967c5"></a><!-- doxytag: member="OGRGeometry::getEnvelope" ref="a3926892dbde299ffd652ee109b5967c5" args="(OGREnvelope3D *psEnvelope) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::getEnvelope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGREnvelope3D.html">OGREnvelope3D</a> *&nbsp;</td>
          <td class="paramname"> <em>psEnvelope</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes and returns the bounding envelope (3D) for this geometry in the passed psEnvelope structure. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a9a950633ac824042b0afdb88c670c5ce" title="Computes and returns the bounding envelope (3D) for this geometry in the passed psEnvelope structure...">OGR_G_GetEnvelope3D()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psEnvelope</em>&nbsp;</td><td>the structure in which to place the results.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.9.0 </dd></dl>

<p>Implemented in <a class="el" href="classOGRPoint.html#a040858aeeaaea58073432b12e1597a5b">OGRPoint</a>, <a class="el" href="classOGRLineString.html#a5f955da6f1d8563a6690b4290c46ae85">OGRLineString</a>, <a class="el" href="classOGRPolygon.html#a8da89cab9c581a4665b183836f80ae20">OGRPolygon</a>, and <a class="el" href="classOGRGeometryCollection.html#a969082477d9d539072fafa846fa24e73">OGRGeometryCollection</a>.</p>

</div>
</div>
<a class="anchor" id="aba109e1c53ce1452942f85eae66d88b8"></a><!-- doxytag: member="OGRGeometry::getGeometryName" ref="aba109e1c53ce1452942f85eae66d88b8" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * OGRGeometry::getGeometryName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch WKT name for geometry type. </p>
<p>There is no SFCOM analog to this method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a18121f835b2fb724a0c1a87beb1a437a" title="Fetch WKT name for geometry type.">OGR_G_GetGeometryName()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>name used for this geometry type in well known text format. The returned pointer is to a static internal string and should not be modified or freed. </dd></dl>

<p>Implemented in <a class="el" href="classOGRPoint.html#ab343d46136b60283560f03f752dd2630">OGRPoint</a>, <a class="el" href="classOGRLineString.html#ab6f7736ff4bd435528b793374f9544ea">OGRLineString</a>, <a class="el" href="classOGRLinearRing.html#a1db244dfa8106d5068046f50c6b8dd37">OGRLinearRing</a>, <a class="el" href="classOGRPolygon.html#a12ddd81003dfabd7d3c977c41fa5f506">OGRPolygon</a>, <a class="el" href="classOGRGeometryCollection.html#ad8a37b8aaa8506c59a0f6e361e33cfea">OGRGeometryCollection</a>, <a class="el" href="classOGRMultiPolygon.html#a3819c81ad80e967decf4fd5896d54919">OGRMultiPolygon</a>, <a class="el" href="classOGRMultiPoint.html#ac71b8d5d56cc41fc4ead4946effd64a9">OGRMultiPoint</a>, and <a class="el" href="classOGRMultiLineString.html#aeb01456fae7b8953d9955c11313bd06f">OGRMultiLineString</a>.</p>

<p>Referenced by <a class="el" href="classOGRGeometry.html#a2e70f05d61566a5ddaa29b44f637cfff">dumpReadable()</a>, and <a class="el" href="classOGRFeature.html#ac7a0224e13dce1f9479a6bf2111ea766">OGRFeature::GetFieldAsString()</a>.</p>

</div>
</div>
<a class="anchor" id="a5c6bca18682cb933e3227552d480e1a5"></a><!-- doxytag: member="OGRGeometry::getGeometryType" ref="a5c6bca18682cb933e3227552d480e1a5" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a> OGRGeometry::getGeometryType </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch geometry type. </p>
<p>Note that the geometry type may include the 2.5D flag. To get a 2D flattened version of the geometry type apply the wkbFlatten() macro to the return result.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a8fae58102f5c4a4cf2526e5ca8369a76" title="Fetch geometry type.">OGR_G_GetGeometryType()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the geometry type code. </dd></dl>

<p>Implemented in <a class="el" href="classOGRPoint.html#a0629a8049b94f9ad86939ba0c7a40bed">OGRPoint</a>, <a class="el" href="classOGRLineString.html#a5654b3123a1b296d09f32ee3c5c68bfa">OGRLineString</a>, <a class="el" href="classOGRPolygon.html#a2e23fcc24129c50c2245f707938fdf4d">OGRPolygon</a>, <a class="el" href="classOGRGeometryCollection.html#ac0ce5876364a826479eb2a10815fea60">OGRGeometryCollection</a>, <a class="el" href="classOGRMultiPolygon.html#a3d06dca158cbe0375bfe1baf0927b13b">OGRMultiPolygon</a>, <a class="el" href="classOGRMultiPoint.html#a1608a1b94dfb29122c42a4ac8f1b77d4">OGRMultiPoint</a>, and <a class="el" href="classOGRMultiLineString.html#a960c59e32e54ca010393e5c749c64b50">OGRMultiLineString</a>.</p>

<p>Referenced by <a class="el" href="classOGRMultiPolygon.html#a246ff65cee942960a98f64539ebbf7ad">OGRMultiPolygon::addGeometryDirectly()</a>, <a class="el" href="classOGRMultiPoint.html#a976d4fb497d3b45bb210ab4bde7ecb67">OGRMultiPoint::addGeometryDirectly()</a>, <a class="el" href="classOGRMultiLineString.html#ac030cf7183a73d625320b4ab6e7a7fb9">OGRMultiLineString::addGeometryDirectly()</a>, <a class="el" href="classOGRGeometry.html#abc2cba699382fbb6a45229e4f5f6e792">Centroid()</a>, <a class="el" href="classOGRGeometry.html#a2e70f05d61566a5ddaa29b44f637cfff">dumpReadable()</a>, <a class="el" href="classOGRPolygon.html#a5daaf7cbfb1263a4b9fc126f5c51cf37">OGRPolygon::Equals()</a>, <a class="el" href="classOGRPoint.html#a4e04bfdd79cbf0c74d90ef20e99f13a3">OGRPoint::Equals()</a>, <a class="el" href="classOGRLineString.html#a8568a09caf084295b39df28c31586c01">OGRLineString::Equals()</a>, <a class="el" href="classOGRGeometryCollection.html#ae25defac0e02404820e7a8b6dc712f44">OGRGeometryCollection::Equals()</a>, <a class="el" href="classOGRGeometryFactory.html#adcae79ea28620e332a3d1df87f1180f3">OGRGeometryFactory::forceToLineString()</a>, <a class="el" href="classOGRGeometryFactory.html#a1c00a78cec110d71175726d6f26b1b39">OGRGeometryFactory::forceToMultiLineString()</a>, <a class="el" href="classOGRGeometryFactory.html#aa97b7837101f6c56e476520d10a9f3c3">OGRGeometryFactory::forceToMultiPoint()</a>, <a class="el" href="classOGRGeometryFactory.html#a2a40032fa65cc71c028516bf8fc0df3e">OGRGeometryFactory::forceToMultiPolygon()</a>, <a class="el" href="classOGRGeometryFactory.html#afd61936e41ea69831b3196e817658d08">OGRGeometryFactory::forceToPolygon()</a>, <a class="el" href="classOGRGeometryCollection.html#af39e7629c39cd27ce00a1ff750bda088">OGRGeometryCollection::get_Area()</a>, <a class="el" href="classOGRGeometryCollection.html#a9b3c5d1d2947611a1cb9400fba827ab7">OGRGeometryCollection::get_Length()</a>, <a class="el" href="ogr__api_8h.html#af89dc63f138aee453cf8ff3e2b1c0833">OGR_G_PointOnSurface()</a>, <a class="el" href="ogr__api_8h.html#a74f64386be8d675e8da33d289ccc9892">OGRBuildPolygonFromEdges()</a>, and <a class="el" href="classOGRGeometry.html#a674319670e735bf6d4049300096157ec">Polygonize()</a>.</p>

</div>
</div>
<a class="anchor" id="a194f0bbdae896539852106cafbffbe87"></a><!-- doxytag: member="OGRGeometry::getSpatialReference" ref="a194f0bbdae896539852106cafbffbe87" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> * OGRGeometry::getSpatialReference </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns spatial reference system for object. </p>
<p>This method relates to the SFCOM IGeometry::get_SpatialReference() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#abc393e40282eec3801fb4a4abc9e25bf" title="Returns spatial reference system for geometry.">OGR_G_GetSpatialReference()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to the spatial reference object. The object may be shared with many geometry objects, and should not be modified. </dd></dl>

<p>Referenced by <a class="el" href="classOGRGeometry.html#a0cea06bf68f632c68a54f7356722fb1d">Boundary()</a>, <a class="el" href="classOGRGeometry.html#ab34b27e2c8812a0fc1dccf055b11d1a2">Buffer()</a>, <a class="el" href="classOGRGeometry.html#abc2cba699382fbb6a45229e4f5f6e792">Centroid()</a>, <a class="el" href="classOGRPolygon.html#a723ac02b4551c683ab7ad88e6616c16b">OGRPolygon::clone()</a>, <a class="el" href="classOGRPoint.html#adacecce9c5c6a7ef7d09842827565eae">OGRPoint::clone()</a>, <a class="el" href="classOGRMultiPolygon.html#a4ef6848b2988b29c9387897debc85cc0">OGRMultiPolygon::clone()</a>, <a class="el" href="classOGRMultiPoint.html#a62e4056dc08502ac1161d8e44c434d80">OGRMultiPoint::clone()</a>, <a class="el" href="classOGRMultiLineString.html#a00cb2d7be778ad436530834bdc3cda38">OGRMultiLineString::clone()</a>, <a class="el" href="classOGRLineString.html#aa3274a231b53c920584257e15119b0f6">OGRLineString::clone()</a>, <a class="el" href="classOGRLinearRing.html#a7f64b5d73de1fc1df6e0de938e5fac63">OGRLinearRing::clone()</a>, <a class="el" href="classOGRGeometryCollection.html#ae007573cfec375b0fbb246a758b20b4c">OGRGeometryCollection::clone()</a>, <a class="el" href="classOGRGeometry.html#ac906abd9b1cd9dd2b208a10c6e9d1bf0">ConvexHull()</a>, <a class="el" href="classOGRGeometry.html#ac92e1ca0e8b108ee920147d4894bde3a">Difference()</a>, <a class="el" href="classOGRGeometryFactory.html#a1c00a78cec110d71175726d6f26b1b39">OGRGeometryFactory::forceToMultiLineString()</a>, <a class="el" href="classOGRGeometryFactory.html#aa97b7837101f6c56e476520d10a9f3c3">OGRGeometryFactory::forceToMultiPoint()</a>, <a class="el" href="classOGRGeometryFactory.html#a2a40032fa65cc71c028516bf8fc0df3e">OGRGeometryFactory::forceToMultiPolygon()</a>, <a class="el" href="classOGRGeometryFactory.html#afd61936e41ea69831b3196e817658d08">OGRGeometryFactory::forceToPolygon()</a>, <a class="el" href="classOGRLineString.html#ac1f06067f941e08a4446014be51cdae6">OGRLineString::getSubLine()</a>, <a class="el" href="classOGRGeometry.html#a202ad4c29487ca046c4a2b055042cb6a">Intersection()</a>, <a class="el" href="ogr__api_8h.html#af89dc63f138aee453cf8ff3e2b1c0833">OGR_G_PointOnSurface()</a>, <a class="el" href="classOGRGeometry.html#a674319670e735bf6d4049300096157ec">Polygonize()</a>, <a class="el" href="classOGRGeometry.html#afd3ea0ffa1e2994427032d0212206ccf">Simplify()</a>, <a class="el" href="classOGRGeometry.html#a6b770f62585c9e6081fda50d270ffbd9">SimplifyPreserveTopology()</a>, <a class="el" href="classOGRGeometry.html#ac76b3046de873ada2ae7ba4de75b9ccb">SymDifference()</a>, <a class="el" href="classOGRGeometry.html#ae3f0b441fbf2f66ce3ef3571268ab10f">transformTo()</a>, <a class="el" href="classOGRGeometry.html#a15fb98d101f5887f7c3af40b6da5a3c4">Union()</a>, and <a class="el" href="classOGRGeometry.html#a2ba2d777083c60fe707a40d2adc36f20">UnionCascaded()</a>.</p>

</div>
</div>
<a class="anchor" id="ab2c6583c2b7c3e526dcfe54a61470c1f"></a><!-- doxytag: member="OGRGeometry::importFromWkb" ref="ab2c6583c2b7c3e526dcfe54a61470c1f" args="(unsigned char *, int=&#45;1)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRGeometry::importFromWkb </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>pabyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nSize</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assign geometry from well known binary data. </p>
<p>The object must have already been instantiated as the correct derived type of geometry object to match the binaries type. This method is used by the <a class="el" href="classOGRGeometryFactory.html">OGRGeometryFactory</a> class, but not normally called by application code.</p>
<p>This method relates to the SFCOM IWks::ImportFromWKB() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#afa5a9173aa3b10a4db09ed696a92ba4a" title="Assign geometry from well known binary data.">OGR_G_ImportFromWkb()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pabyData</em>&nbsp;</td><td>the binary input data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nSize</em>&nbsp;</td><td>the size of pabyData in bytes, or zero if not known.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE if all goes well, otherwise any of OGRERR_NOT_ENOUGH_DATA, OGRERR_UNSUPPORTED_GEOMETRY_TYPE, or OGRERR_CORRUPT_DATA may be returned. </dd></dl>

<p>Implemented in <a class="el" href="classOGRPoint.html#a5c5679f8fcc254562e36a8fce316b646">OGRPoint</a>, <a class="el" href="classOGRLineString.html#ae594aeb14deec56cf957ce54a9f299a7">OGRLineString</a>, <a class="el" href="classOGRLinearRing.html#a80fa5c79e98e92a1b58f30b9904c272c">OGRLinearRing</a>, <a class="el" href="classOGRPolygon.html#a46b833f19bf35fcea113233310a245ce">OGRPolygon</a>, and <a class="el" href="classOGRGeometryCollection.html#a1f06b21c6ec0a0500eb7e3a815283ccf">OGRGeometryCollection</a>.</p>

<p>Referenced by <a class="el" href="classOGRGeometryFactory.html#a699688dba97260f2eb29f802e39cb0ec">OGRGeometryFactory::createFromWkb()</a>.</p>

</div>
</div>
<a class="anchor" id="a30561a301d44b1f90393ea4a78a5b0a5"></a><!-- doxytag: member="OGRGeometry::importFromWkt" ref="a30561a301d44b1f90393ea4a78a5b0a5" args="(char **ppszInput)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRGeometry::importFromWkt </td>
          <td>(</td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>ppszInput</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assign geometry from well known text data. </p>
<p>The object must have already been instantiated as the correct derived type of geometry object to match the text type. This method is used by the <a class="el" href="classOGRGeometryFactory.html">OGRGeometryFactory</a> class, but not normally called by application code.</p>
<p>This method relates to the SFCOM IWks::ImportFromWKT() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a4286ba243fb05a831a49f52aabcbc6f8" title="Assign geometry from well known text data.">OGR_G_ImportFromWkt()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ppszInput</em>&nbsp;</td><td>pointer to a pointer to the source text. The pointer is updated to pointer after the consumed text.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE if all goes well, otherwise any of OGRERR_NOT_ENOUGH_DATA, OGRERR_UNSUPPORTED_GEOMETRY_TYPE, or OGRERR_CORRUPT_DATA may be returned. </dd></dl>

<p>Implemented in <a class="el" href="classOGRPoint.html#a46cd8cdb216be9538d22b5aae9b9be1c">OGRPoint</a>, <a class="el" href="classOGRLineString.html#ada0f0873c302eee9e1c763e06ff9d788">OGRLineString</a>, <a class="el" href="classOGRPolygon.html#a84d3b6e0ee2b098528a537bb874b4856">OGRPolygon</a>, <a class="el" href="classOGRGeometryCollection.html#a72381b58185cf0851db54067e3f3f2df">OGRGeometryCollection</a>, <a class="el" href="classOGRMultiPolygon.html#a23b4a553c2b3ccde257359c78782eaf8">OGRMultiPolygon</a>, <a class="el" href="classOGRMultiPoint.html#a283b992718022f5e400e455efe835360">OGRMultiPoint</a>, and <a class="el" href="classOGRMultiLineString.html#a1a71908c13cbe25e4c7b8e2d9cc99af3">OGRMultiLineString</a>.</p>

<p>Referenced by <a class="el" href="classOGRGeometryFactory.html#a9418f71bcfb1e334173882c38d89d070">OGRGeometryFactory::createFromWkt()</a>.</p>

</div>
</div>
<a class="anchor" id="a202ad4c29487ca046c4a2b055042cb6a"></a><!-- doxytag: member="OGRGeometry::Intersection" ref="a202ad4c29487ca046c4a2b055042cb6a" args="(const OGRGeometry *) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::Intersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td>
          <td class="paramname"> <em>poOtherGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute intersection. </p>
<p>Generates a new geometry which is the region of intersection of the two geometries operated on. The <a class="el" href="classOGRGeometry.html#a0829528c9ca29059f86399da954fc8ae" title="Do these features intersect?">Intersects()</a> method can be used to test if two geometries intersect.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a5a271b5c7b72994120e7a6bbc7e7e5cb" title="Compute intersection.">OGR_G_Intersection()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poOtherGeom</em>&nbsp;</td><td>the other geometry intersected with "this" geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new geometry representing the intersection or NULL if there is no intersection or an error occurs. </dd></dl>

<p>References <a class="el" href="classOGRGeometry.html#a4308e3549c65aa12cc2ba41be15d99a0">assignSpatialReference()</a>, <a class="el" href="classOGRGeometry.html#a194f0bbdae896539852106cafbffbe87">getSpatialReference()</a>, and <a class="el" href="classOGRSpatialReference.html#a17fd82b2f58a976a30358b076a2fc966">OGRSpatialReference::IsSame()</a>.</p>

<p>Referenced by <a class="el" href="classOGRLayer.html#a56d7ee3b2020e53c730d67ee4f1e2fb6">OGRLayer::Clip()</a>, <a class="el" href="classOGRLayer.html#acac6a0bde9737555b22c6ac7fa967431">OGRLayer::Identity()</a>, <a class="el" href="classOGRLayer.html#ac189f54996c2d6fd769889ec99e0f48a">OGRLayer::Intersection()</a>, and <a class="el" href="classOGRLayer.html#aeb8ab475561f2aca2c0e605cfb810b22">OGRLayer::Union()</a>.</p>

</div>
</div>
<a class="anchor" id="a0829528c9ca29059f86399da954fc8ae"></a><!-- doxytag: member="OGRGeometry::Intersects" ref="a0829528c9ca29059f86399da954fc8ae" args="(OGRGeometry *) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRBoolean OGRGeometry::Intersects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td>
          <td class="paramname"> <em>poOtherGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Do these features intersect? </p>
<p>Determines whether two geometries intersect. If GEOS is enabled, then this is done in rigerous fashion otherwise TRUE is returned if the envelopes (bounding boxes) of the two features overlap.</p>
<p>The poOtherGeom argument may be safely NULL, but in this case the method will always return TRUE. That is, a NULL geometry is treated as being everywhere.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#acaed6926b75cd33a42b284c10def6e87" title="Do these features intersect?">OGR_G_Intersects()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poOtherGeom</em>&nbsp;</td><td>the other geometry to test against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the geometries intersect, otherwise FALSE. </dd></dl>

<p>References <a class="el" href="classOGRGeometry.html#aa3d42b06ae6f7bbef6d1a2886da8d398">getEnvelope()</a>.</p>

</div>
</div>
<a class="anchor" id="ac8653ba97e53f3e3b041946ca2acc111"></a><!-- doxytag: member="OGRGeometry::IsEmpty" ref="ac8653ba97e53f3e3b041946ca2acc111" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRBoolean OGRGeometry::IsEmpty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns TRUE (non-zero) if the object has no points. </p>
<p>Normally this returns FALSE except between when an object is instantiated and points have been assigned.</p>
<p>This method relates to the SFCOM IGeometry::IsEmpty() method.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if object is empty, otherwise FALSE. </dd></dl>

<p>Implemented in <a class="el" href="classOGRPoint.html#a3d25537f07a1e7dd51868f82ad7df52f">OGRPoint</a>, <a class="el" href="classOGRLineString.html#aae5521135ad94d8ea523b9d4d614ffee">OGRLineString</a>, <a class="el" href="classOGRPolygon.html#a1e14ee632878f6af3a4c93d7bf82a433">OGRPolygon</a>, and <a class="el" href="classOGRGeometryCollection.html#ae7f7a6da1812c2d8aaf71966468d6c37">OGRGeometryCollection</a>.</p>

<p>Referenced by <a class="el" href="classOGRLayer.html#a56d7ee3b2020e53c730d67ee4f1e2fb6">OGRLayer::Clip()</a>, <a class="el" href="classOGRPolygon.html#a5daaf7cbfb1263a4b9fc126f5c51cf37">OGRPolygon::Equals()</a>, <a class="el" href="classOGRPoint.html#a4e04bfdd79cbf0c74d90ef20e99f13a3">OGRPoint::Equals()</a>, <a class="el" href="classOGRLineString.html#a8568a09caf084295b39df28c31586c01">OGRLineString::Equals()</a>, <a class="el" href="classOGRGeometryCollection.html#ae25defac0e02404820e7a8b6dc712f44">OGRGeometryCollection::Equals()</a>, <a class="el" href="classOGRLayer.html#ae8fcf55ffa259f32df35edcb05274439">OGRLayer::Erase()</a>, <a class="el" href="classOGRLayer.html#acac6a0bde9737555b22c6ac7fa967431">OGRLayer::Identity()</a>, <a class="el" href="classOGRLayer.html#ac189f54996c2d6fd769889ec99e0f48a">OGRLayer::Intersection()</a>, <a class="el" href="classOGRLayer.html#a781aa76c6b44b19de09f61816e32245b">OGRLayer::SymDifference()</a>, <a class="el" href="classOGRLayer.html#aeb8ab475561f2aca2c0e605cfb810b22">OGRLayer::Union()</a>, and <a class="el" href="classOGRLayer.html#aa1c5dc5ca195956c46d35a85b0b21d9b">OGRLayer::Update()</a>.</p>

</div>
</div>
<a class="anchor" id="ad15ffdcae4351112b3106d4f87b2a3bf"></a><!-- doxytag: member="OGRGeometry::IsRing" ref="ad15ffdcae4351112b3106d4f87b2a3bf" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRBoolean OGRGeometry::IsRing </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if the geometry is a ring. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ab9e99b4792042aca861866cb29bdf826" title="Test if the geometry is a ring.">OGR_G_IsRing()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always return FALSE.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the geometry has no points, otherwise FALSE. </dd></dl>

</div>
</div>
<a class="anchor" id="ab72b0c5c673d8b1cf6f870fabbeffe26"></a><!-- doxytag: member="OGRGeometry::IsSimple" ref="ab72b0c5c673d8b1cf6f870fabbeffe26" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRBoolean OGRGeometry::IsSimple </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if the geometry is simple. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a3cb66472d7e302d16aacf0d66c01ac73" title="Returns TRUE if the geometry is simple.">OGR_G_IsSimple()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always return FALSE.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the geometry has no points, otherwise FALSE. </dd></dl>

</div>
</div>
<a class="anchor" id="a7bbb194937466a6127b5436ac2ae99d9"></a><!-- doxytag: member="OGRGeometry::IsValid" ref="a7bbb194937466a6127b5436ac2ae99d9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRBoolean OGRGeometry::IsValid </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if the geometry is valid. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a4df68924f3b41fd377c5b4aa6631a00b" title="Test if the geometry is valid.">OGR_G_IsValid()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always return FALSE.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the geometry has no points, otherwise FALSE. </dd></dl>

</div>
</div>
<a class="anchor" id="afc672c524568f3ee6ee5257b250d2b12"></a><!-- doxytag: member="OGRGeometry::Overlaps" ref="afc672c524568f3ee6ee5257b250d2b12" args="(const OGRGeometry *) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRBoolean OGRGeometry::Overlaps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td>
          <td class="paramname"> <em>poOtherGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test for overlap. </p>
<p>Tests if this geometry and the other passed into the method overlap, that is their intersection has a non-zero area.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a07acfe1bef39cd2cd1ad4a5ec26f2ceb" title="Test for overlap.">OGR_G_Overlaps()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poOtherGeom</em>&nbsp;</td><td>the geometry to compare to this geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if they are overlapping, otherwise FALSE. </dd></dl>

<p>Referenced by <a class="el" href="classOGRGeometryFactory.html#afa3e76499553c3dc0a1621af98b88be6">OGRGeometryFactory::organizePolygons()</a>.</p>

</div>
</div>
<a class="anchor" id="a674319670e735bf6d4049300096157ec"></a><!-- doxytag: member="OGRGeometry::Polygonize" ref="a674319670e735bf6d4049300096157ec" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::Polygonize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Polygonizes a set of sparse edges. </p>
<p>A new geometry object is created and returned containing a collection of reassembled Polygons: NULL will be returned if the input collection doesn't corresponds to a MultiLinestring, or when reassembling Edges into Polygons is impossible due to topogical inconsistencies.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a673c6c4745d5092fb250ae5342bc1b3b" title="Polygonizes a set of sparse edges.">OGR_G_Polygonize()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a newly allocated geometry now owned by the caller, or NULL on failure.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.9.0 </dd></dl>

<p>References <a class="el" href="classOGRGeometry.html#a4308e3549c65aa12cc2ba41be15d99a0">assignSpatialReference()</a>, <a class="el" href="classOGRGeometryCollection.html#ad609f2c7886918a766dd3d3a4fa52ec3">OGRGeometryCollection::getGeometryRef()</a>, <a class="el" href="classOGRGeometry.html#a5c6bca18682cb933e3227552d480e1a5">getGeometryType()</a>, <a class="el" href="classOGRGeometryCollection.html#a878ea43754b6c6dc824d3a0d1b3dd0e3">OGRGeometryCollection::getNumGeometries()</a>, <a class="el" href="classOGRGeometry.html#a194f0bbdae896539852106cafbffbe87">getSpatialReference()</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa7f299e8edaee30fd3c7a40baf19b48b1">wkbGeometryCollection</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa09fd8f51759a1cf351b04e786a2a9058">wkbLineString</a>, and <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa2ecf4d40ab038779cbc1de22ddcb3429">wkbMultiLineString</a>.</p>

</div>
</div>
<a class="anchor" id="a91685bd7c0bdd67cd073a8b4da3c06a5"></a><!-- doxytag: member="OGRGeometry::segmentize" ref="a91685bd7c0bdd67cd073a8b4da3c06a5" args="(double dfMaxLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::segmentize </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfMaxLength</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modify the geometry such it has no segment longer then the given distance. </p>
<p>Interpolated points will have Z and M values (if needed) set to 0. Distance computation is performed in 2d only</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#ade9f08c8d63bc0e726cb20c201c86423" title="Modify the geometry such it has no segment longer then the given distance.">OGR_G_Segmentize()</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dfMaxLength</em>&nbsp;</td><td>the maximum distance between 2 points after segmentization </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classOGRLineString.html#aee1a3d911818f745cf22e30d53ed160d">OGRLineString</a>, <a class="el" href="classOGRPolygon.html#a51fa8080389d47784fdb6a8ae097b5fa">OGRPolygon</a>, and <a class="el" href="classOGRGeometryCollection.html#a9dd126d6cbe87f34eef6de9b9748874b">OGRGeometryCollection</a>.</p>

</div>
</div>
<a class="anchor" id="a79f84a2b948d511f28c47c47577dea49"></a><!-- doxytag: member="OGRGeometry::setCoordinateDimension" ref="a79f84a2b948d511f28c47c47577dea49" args="(int nDimension)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::setCoordinateDimension </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nNewDimension</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the coordinate dimension. </p>
<p>This method sets the explicit coordinate dimension. Setting the coordinate dimension of a geometry to 2 should zero out any existing Z values. Setting the dimension of a geometry collection will not necessarily affect the children geometries.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nNewDimension</em>&nbsp;</td><td>New coordinate dimension value, either 2 or 3. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classOGRPoint.html#ab1bdccd2a5fe4886a07f345d9af94b28">OGRPoint</a>, <a class="el" href="classOGRLineString.html#aed2edaf7e5af02f2724ec073f0957ee0">OGRLineString</a>, <a class="el" href="classOGRPolygon.html#aae4be814a04641d5ad9f8c79e00b3c35">OGRPolygon</a>, and <a class="el" href="classOGRGeometryCollection.html#a815199fda3d141eb52e7237dafade6fe">OGRGeometryCollection</a>.</p>

<p>Referenced by <a class="el" href="classOGRGeometryCollection.html#a815199fda3d141eb52e7237dafade6fe">OGRGeometryCollection::setCoordinateDimension()</a>.</p>

</div>
</div>
<a class="anchor" id="afd3ea0ffa1e2994427032d0212206ccf"></a><!-- doxytag: member="OGRGeometry::Simplify" ref="afd3ea0ffa1e2994427032d0212206ccf" args="(double dTolerance) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::Simplify </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dTolerance</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Simplify the geometry. </p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#a0453f97e9d4fc44e13787ad1a8439c0c" title="Compute a simplified geometry.">OGR_G_Simplify()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dTolerance</em>&nbsp;</td><td>the distance tolerance for the simplification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the simplified geometry or NULL if an error occurs.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.8.0 </dd></dl>

<p>References <a class="el" href="classOGRGeometry.html#a4308e3549c65aa12cc2ba41be15d99a0">assignSpatialReference()</a>, and <a class="el" href="classOGRGeometry.html#a194f0bbdae896539852106cafbffbe87">getSpatialReference()</a>.</p>

</div>
</div>
<a class="anchor" id="a6b770f62585c9e6081fda50d270ffbd9"></a><!-- doxytag: member="OGRGeometry::SimplifyPreserveTopology" ref="a6b770f62585c9e6081fda50d270ffbd9" args="(double dTolerance) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::SimplifyPreserveTopology </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dTolerance</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Simplify the geometry while preserving topology. </p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#a8e19e9cfa01744db6a2e8eee710611b6" title="Simplify the geometry while preserving topology.">OGR_G_SimplifyPreserveTopology()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dTolerance</em>&nbsp;</td><td>the distance tolerance for the simplification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the simplified geometry or NULL if an error occurs.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.9.0 </dd></dl>

<p>References <a class="el" href="classOGRGeometry.html#a4308e3549c65aa12cc2ba41be15d99a0">assignSpatialReference()</a>, and <a class="el" href="classOGRGeometry.html#a194f0bbdae896539852106cafbffbe87">getSpatialReference()</a>.</p>

</div>
</div>
<a class="anchor" id="a3ffd51d4998a8e2ae422c69b6adf480a"></a><!-- doxytag: member="OGRGeometry::swapXY" ref="a3ffd51d4998a8e2ae422c69b6adf480a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::swapXY </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swap x and y coordinates. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.8.0 </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRPoint.html#a5b3f9a80c2aca6acbbfc462fba75e199">OGRPoint</a>, <a class="el" href="classOGRLineString.html#a31c99de8c53fbd8c3e719dd1b56d915d">OGRLineString</a>, <a class="el" href="classOGRPolygon.html#a0aeea5e4fa4f33e3723ec51db9b0661c">OGRPolygon</a>, and <a class="el" href="classOGRGeometryCollection.html#a51a0a0a16ff9e1328b4775bb92c20954">OGRGeometryCollection</a>.</p>

</div>
</div>
<a class="anchor" id="ac76b3046de873ada2ae7ba4de75b9ccb"></a><!-- doxytag: member="OGRGeometry::SymDifference" ref="ac76b3046de873ada2ae7ba4de75b9ccb" args="(const OGRGeometry *) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::SymDifference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td>
          <td class="paramname"> <em>poOtherGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute symmetric difference. </p>
<p>Generates a new geometry which is the symmetric difference of this geometry and the second geometry passed into the method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a2b047fca89d06a08a5c34f210c4c97d5" title="Compute symmetric difference.">OGR_G_SymDifference()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poOtherGeom</em>&nbsp;</td><td>the other geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new geometry representing the symmetric difference or NULL if the difference is empty or an error occurs.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.8.0 </dd></dl>

<p>References <a class="el" href="classOGRGeometry.html#a4308e3549c65aa12cc2ba41be15d99a0">assignSpatialReference()</a>, <a class="el" href="classOGRGeometry.html#a194f0bbdae896539852106cafbffbe87">getSpatialReference()</a>, and <a class="el" href="classOGRSpatialReference.html#a17fd82b2f58a976a30358b076a2fc966">OGRSpatialReference::IsSame()</a>.</p>

<p>Referenced by <a class="el" href="classOGRGeometry.html#a61d73b46cfa6488167dd4005f85c7ca0">SymmetricDifference()</a>.</p>

</div>
</div>
<a class="anchor" id="a61d73b46cfa6488167dd4005f85c7ca0"></a><!-- doxytag: member="OGRGeometry::SymmetricDifference" ref="a61d73b46cfa6488167dd4005f85c7ca0" args="(const OGRGeometry *) const CPL_WARN_DEPRECATED(&quot;Non standard method. Use SymDifference() instead&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::SymmetricDifference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td>
          <td class="paramname"> <em>poOtherGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute symmetric difference (deprecated). </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOGRGeometry.html#ac76b3046de873ada2ae7ba4de75b9ccb" title="Compute symmetric difference.">OGRGeometry::SymDifference()</a> </dd></dl>

<p>References <a class="el" href="classOGRGeometry.html#ac76b3046de873ada2ae7ba4de75b9ccb">SymDifference()</a>.</p>

</div>
</div>
<a class="anchor" id="a5d3e23c20b51ceb5a56d397f812a81a2"></a><!-- doxytag: member="OGRGeometry::Touches" ref="a5d3e23c20b51ceb5a56d397f812a81a2" args="(const OGRGeometry *) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRBoolean OGRGeometry::Touches </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td>
          <td class="paramname"> <em>poOtherGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test for touching. </p>
<p>Tests if this geometry and the other passed into the method are touching.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a6f67616eb88f479eba50f9783c8494d9" title="Test for touching.">OGR_G_Touches()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poOtherGeom</em>&nbsp;</td><td>the geometry to compare to this geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if they are touching, otherwise FALSE. </dd></dl>

</div>
</div>
<a class="anchor" id="aa9e8bfb3c2129f25cf622660f734e1ba"></a><!-- doxytag: member="OGRGeometry::transform" ref="aa9e8bfb3c2129f25cf622660f734e1ba" args="(OGRCoordinateTransformation *poCT)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRGeometry::transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRCoordinateTransformation.html">OGRCoordinateTransformation</a> *&nbsp;</td>
          <td class="paramname"> <em>poCT</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply arbitrary coordinate transformation to geometry. </p>
<p>This method will transform the coordinates of a geometry from their current spatial reference system to a new target spatial reference system. Normally this means reprojecting the vectors, but it could include datum shifts, and changes of units.</p>
<p>Note that this method does not require that the geometry already have a spatial reference system. It will be assumed that they can be treated as having the source spatial reference system of the <a class="el" href="classOGRCoordinateTransformation.html">OGRCoordinateTransformation</a> object, and the actual SRS of the geometry will be ignored. On successful completion the output <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> of the <a class="el" href="classOGRCoordinateTransformation.html">OGRCoordinateTransformation</a> will be assigned to the geometry.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a59a5b3f954b11cfbf6e78807c28d6090" title="Apply arbitrary coordinate transformation to geometry.">OGR_G_Transform()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poCT</em>&nbsp;</td><td>the transformation to apply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE on success or an error code. </dd></dl>

<p>Implemented in <a class="el" href="classOGRPoint.html#a351482d4852285a214ac1d55ec046356">OGRPoint</a>, <a class="el" href="classOGRLineString.html#a75675b1f158fd1d5d35cc431227ed000">OGRLineString</a>, <a class="el" href="classOGRPolygon.html#aa974efb0dd2bdc7b62fa23dfdc4f8c72">OGRPolygon</a>, and <a class="el" href="classOGRGeometryCollection.html#a39e5d3d2fbfbfccd7cdf5275f0373816">OGRGeometryCollection</a>.</p>

<p>Referenced by <a class="el" href="classOGRGeometryCollection.html#a39e5d3d2fbfbfccd7cdf5275f0373816">OGRGeometryCollection::transform()</a>, and <a class="el" href="classOGRGeometry.html#ae3f0b441fbf2f66ce3ef3571268ab10f">transformTo()</a>.</p>

</div>
</div>
<a class="anchor" id="ae3f0b441fbf2f66ce3ef3571268ab10f"></a><!-- doxytag: member="OGRGeometry::transformTo" ref="ae3f0b441fbf2f66ce3ef3571268ab10f" args="(OGRSpatialReference *poSR)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRGeometry::transformTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&nbsp;</td>
          <td class="paramname"> <em>poSR</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transform geometry to new spatial reference system. </p>
<p>This method will transform the coordinates of a geometry from their current spatial reference system to a new target spatial reference system. Normally this means reprojecting the vectors, but it could include datum shifts, and changes of units.</p>
<p>This method will only work if the geometry already has an assigned spatial reference system, and if it is transformable to the target coordinate system.</p>
<p>Because this method requires internal creation and initialization of an <a class="el" href="classOGRCoordinateTransformation.html">OGRCoordinateTransformation</a> object it is significantly more expensive to use this method to transform many geometries than it is to create the <a class="el" href="classOGRCoordinateTransformation.html">OGRCoordinateTransformation</a> in advance, and call <a class="el" href="classOGRGeometry.html#aa9e8bfb3c2129f25cf622660f734e1ba" title="Apply arbitrary coordinate transformation to geometry.">transform()</a> with that transformation. This method exists primarily for convenience when only transforming a single geometry.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a43af4c2127cea0a5059692a62c0feb63" title="Transform geometry to new spatial reference system.">OGR_G_TransformTo()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poSR</em>&nbsp;</td><td>spatial reference system to transform to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE on success, or an error code. </dd></dl>

<p>References <a class="el" href="classOGRGeometry.html#a194f0bbdae896539852106cafbffbe87">getSpatialReference()</a>, <a class="el" href="ogr__spatialref_8h.html#aae11bd08e45cdb2e71e1d9c31f1e550f">OGRCreateCoordinateTransformation()</a>, and <a class="el" href="classOGRGeometry.html#aa9e8bfb3c2129f25cf622660f734e1ba">transform()</a>.</p>

</div>
</div>
<a class="anchor" id="a15fb98d101f5887f7c3af40b6da5a3c4"></a><!-- doxytag: member="OGRGeometry::Union" ref="a15fb98d101f5887f7c3af40b6da5a3c4" args="(const OGRGeometry *) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::Union </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td>
          <td class="paramname"> <em>poOtherGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute union. </p>
<p>Generates a new geometry which is the region of union of the two geometries operated on.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#af58f2cfbdb2497659d2eabea73d3b8a0" title="Compute union.">OGR_G_Union()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poOtherGeom</em>&nbsp;</td><td>the other geometry unioned with "this" geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new geometry representing the union or NULL if an error occurs. </dd></dl>

<p>References <a class="el" href="classOGRGeometry.html#a4308e3549c65aa12cc2ba41be15d99a0">assignSpatialReference()</a>, <a class="el" href="classOGRGeometry.html#a194f0bbdae896539852106cafbffbe87">getSpatialReference()</a>, and <a class="el" href="classOGRSpatialReference.html#a17fd82b2f58a976a30358b076a2fc966">OGRSpatialReference::IsSame()</a>.</p>

<p>Referenced by <a class="el" href="classOGRLayer.html#a56d7ee3b2020e53c730d67ee4f1e2fb6">OGRLayer::Clip()</a>, and <a class="el" href="classOGRLayer.html#ae8fcf55ffa259f32df35edcb05274439">OGRLayer::Erase()</a>.</p>

</div>
</div>
<a class="anchor" id="a2ba2d777083c60fe707a40d2adc36f20"></a><!-- doxytag: member="OGRGeometry::UnionCascaded" ref="a2ba2d777083c60fe707a40d2adc36f20" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::UnionCascaded </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute union using cascading. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a2bb45d7d6ca9641be5f0773f1d60aa0f" title="Compute union using cascading.">OGR_G_UnionCascaded()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new geometry representing the union or NULL if an error occurs.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.8.0 </dd></dl>

<p>References <a class="el" href="classOGRGeometry.html#a4308e3549c65aa12cc2ba41be15d99a0">assignSpatialReference()</a>, and <a class="el" href="classOGRGeometry.html#a194f0bbdae896539852106cafbffbe87">getSpatialReference()</a>.</p>

</div>
</div>
<a class="anchor" id="abb4bb4687de9b6f23e61b686177b2856"></a><!-- doxytag: member="OGRGeometry::Within" ref="abb4bb4687de9b6f23e61b686177b2856" args="(const OGRGeometry *) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRBoolean OGRGeometry::Within </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td>
          <td class="paramname"> <em>poOtherGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test for containment. </p>
<p>Tests if actual geometry object is within the passed geometry.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a80ba9e516ccae381ae7240cc9684eb72" title="Test for containment.">OGR_G_Within()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poOtherGeom</em>&nbsp;</td><td>the geometry to compare to this geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if poOtherGeom is within this geometry, otherwise FALSE. </dd></dl>

</div>
</div>
<a class="anchor" id="acd1a8164dae2e44e50990756ed6b8b4a"></a><!-- doxytag: member="OGRGeometry::WkbSize" ref="acd1a8164dae2e44e50990756ed6b8b4a" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRGeometry::WkbSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns size of related binary representation. </p>
<p>This method returns the exact number of bytes required to hold the well known binary representation of this geometry object. Its computation may be slightly expensive for complex geometries.</p>
<p>This method relates to the SFCOM IWks::WkbSize() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a5f7035a933b957a9d453184c154c237c" title="Returns size of related binary representation.">OGR_G_WkbSize()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>size of binary representation in bytes. </dd></dl>

<p>Implemented in <a class="el" href="classOGRPoint.html#a52c7e9871c785d5bb0952d3f9f176cbd">OGRPoint</a>, <a class="el" href="classOGRLineString.html#a1aabd7032d6579f4fa17fc3849c6a353">OGRLineString</a>, <a class="el" href="classOGRLinearRing.html#a87b3bfc9b96b5d86e3cc6df4cc5e98ab">OGRLinearRing</a>, <a class="el" href="classOGRPolygon.html#ad8193c4d42032c4106bdccb907bc66ab">OGRPolygon</a>, and <a class="el" href="classOGRGeometryCollection.html#abbd3a441c99163025c72cb6b8642d44d">OGRGeometryCollection</a>.</p>

<p>Referenced by <a class="el" href="classOGRGeometryCollection.html#abbd2d1f722a5f0b8d56c0f648867241e">OGRGeometryCollection::exportToWkb()</a>, and <a class="el" href="classOGRGeometryCollection.html#abbd3a441c99163025c72cb6b8642d44d">OGRGeometryCollection::WkbSize()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="ogr__geometry_8h_source.html">ogr_geometry.h</a></li>
<li>ogrgeometry.cpp</li>
</ul>
</div>
<hr>

Generated for GDAL by 
<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.7.1.
</body>
</html>

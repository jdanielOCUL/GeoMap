<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OGR: ogr_api.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>ogr_api.h File Reference</h1>  </div>
</div>
<div class="contents">
<code>#include &quot;cpl_progress.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="ogr__core_8h_source.html">ogr_core.h</a>&quot;</code><br/>

<p><a href="ogr__api_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a3172c8e5b8a094b8ce97fa5d44bcd204">OGR_G_CreateFromWkb</a> (unsigned char *, OGRSpatialReferenceH, OGRGeometryH *, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a geometry object of the appropriate type from it's well known binary representation.  <a href="#a3172c8e5b8a094b8ce97fa5d44bcd204"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac02c3ed5f7ebd5039dc2ae70154fd94a">OGR_G_CreateFromWkt</a> (char **, OGRSpatialReferenceH, OGRGeometryH *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a geometry object of the appropriate type from it's well known text representation.  <a href="#ac02c3ed5f7ebd5039dc2ae70154fd94a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac4e665f5f9690c4fa0c190b930fe9492">OGR_G_DestroyGeometry</a> (OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy geometry object.  <a href="#ac4e665f5f9690c4fa0c190b930fe9492"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRGeometryH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4e47710cf70e5bc72216704ddfead0dd">OGR_G_CreateGeometry</a> (<a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an empty geometry of desired type.  <a href="#a4e47710cf70e5bc72216704ddfead0dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRGeometryH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a7c9ee71d0030dc30bdd595c37ab71062">OGR_G_ApproximateArcAngles</a> (double dfCenterX, double dfCenterY, double dfZ, double dfPrimaryRadius, double dfSecondaryAxis, double dfRotation, double dfStartAngle, double dfEndAngle, double dfMaxAngleStepSizeDegrees)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRGeometryH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac4d5e3d348db62e46ebba718edb36abe">OGR_G_ForceToPolygon</a> (OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert to polygon.  <a href="#ac4d5e3d348db62e46ebba718edb36abe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRGeometryH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a670481ed69704f2be0c2c24a304d3bf5">OGR_G_ForceToLineString</a> (OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert to line string.  <a href="#a670481ed69704f2be0c2c24a304d3bf5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRGeometryH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#abea3d494951ab99e72b59cbd5318e8c4">OGR_G_ForceToMultiPolygon</a> (OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert to multipolygon.  <a href="#abea3d494951ab99e72b59cbd5318e8c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRGeometryH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aedd1952b5cde54253746d9da1a2b0500">OGR_G_ForceToMultiPoint</a> (OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert to multipoint.  <a href="#aedd1952b5cde54253746d9da1a2b0500"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRGeometryH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac3d8424596b90664b7280a9e7c89dc96">OGR_G_ForceToMultiLineString</a> (OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert to multilinestring.  <a href="#ac3d8424596b90664b7280a9e7c89dc96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a94b633e1acd208c258ad49f8d4fd4104">OGR_G_GetDimension</a> (OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the dimension of this geometry.  <a href="#a94b633e1acd208c258ad49f8d4fd4104"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a8a5e78b0753339d1cdd282b0e151d28f">OGR_G_GetCoordinateDimension</a> (OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the dimension of the coordinates in this geometry.  <a href="#a8a5e78b0753339d1cdd282b0e151d28f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac6bcad9553f488f7d8b6c8674cf7771c">OGR_G_SetCoordinateDimension</a> (OGRGeometryH, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the coordinate dimension.  <a href="#ac6bcad9553f488f7d8b6c8674cf7771c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRGeometryH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a1725918932da7d59f9ee72829ac171fa">OGR_G_Clone</a> (OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a copy of this object.  <a href="#a1725918932da7d59f9ee72829ac171fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a617a9c9ea85157661619a1d8f0a69cf9">OGR_G_GetEnvelope</a> (OGRGeometryH, <a class="el" href="classOGREnvelope.html">OGREnvelope</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure.  <a href="#a617a9c9ea85157661619a1d8f0a69cf9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9a950633ac824042b0afdb88c670c5ce">OGR_G_GetEnvelope3D</a> (OGRGeometryH, <a class="el" href="classOGREnvelope3D.html">OGREnvelope3D</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes and returns the bounding envelope (3D) for this geometry in the passed psEnvelope structure.  <a href="#a9a950633ac824042b0afdb88c670c5ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#afa5a9173aa3b10a4db09ed696a92ba4a">OGR_G_ImportFromWkb</a> (OGRGeometryH, unsigned char *, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign geometry from well known binary data.  <a href="#afa5a9173aa3b10a4db09ed696a92ba4a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad5c94ae76c09774dba8725c24daeefd6">OGR_G_ExportToWkb</a> (OGRGeometryH, OGRwkbByteOrder, unsigned char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a geometry into well known binary format.  <a href="#ad5c94ae76c09774dba8725c24daeefd6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a5f7035a933b957a9d453184c154c237c">OGR_G_WkbSize</a> (OGRGeometryH hGeom)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns size of related binary representation.  <a href="#a5f7035a933b957a9d453184c154c237c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4286ba243fb05a831a49f52aabcbc6f8">OGR_G_ImportFromWkt</a> (OGRGeometryH, char **)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign geometry from well known text data.  <a href="#a4286ba243fb05a831a49f52aabcbc6f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a3bc9310302e2dbfaab1690de9e2fd2fb">OGR_G_ExportToWkt</a> (OGRGeometryH, char **)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a geometry into well known text format.  <a href="#a3bc9310302e2dbfaab1690de9e2fd2fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a8fae58102f5c4a4cf2526e5ca8369a76">OGR_G_GetGeometryType</a> (OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch geometry type.  <a href="#a8fae58102f5c4a4cf2526e5ca8369a76"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a18121f835b2fb724a0c1a87beb1a437a">OGR_G_GetGeometryName</a> (OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch WKT name for geometry type.  <a href="#a18121f835b2fb724a0c1a87beb1a437a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a3a99330bd108940f8a33036c0f83119f">OGR_G_DumpReadable</a> (OGRGeometryH, FILE *, const char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dump geometry in well known text format to indicated output file.  <a href="#a3a99330bd108940f8a33036c0f83119f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#afdb7354b55c7448b60b44cd9e36073b8">OGR_G_FlattenTo2D</a> (OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert geometry to strictly 2D. In a sense this converts all Z coordinates to 0.0.  <a href="#afdb7354b55c7448b60b44cd9e36073b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#acfeb849dcfd4fdf4d6dab66e6ea697c0">OGR_G_CloseRings</a> (OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Force rings to be closed.  <a href="#acfeb849dcfd4fdf4d6dab66e6ea697c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRGeometryH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aef37aa4d89f303fee679f97d32461d69">OGR_G_CreateFromGML</a> (const char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create geometry from GML.  <a href="#aef37aa4d89f303fee679f97d32461d69"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a3c473bd75c553d2bbae1aed480f8c34d">OGR_G_ExportToGML</a> (OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a geometry into GML format.  <a href="#a3c473bd75c553d2bbae1aed480f8c34d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a06fc1cec4a17a2926640f95c6bf7a442">OGR_G_ExportToGMLEx</a> (OGRGeometryH, char **papszOptions)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a geometry into GML format.  <a href="#a06fc1cec4a17a2926640f95c6bf7a442"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a27b1389e05c84261a7b612aefedd0ed3">OGR_G_ExportToKML</a> (OGRGeometryH, const char *pszAltitudeMode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a geometry into KML format.  <a href="#a27b1389e05c84261a7b612aefedd0ed3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9ebd5fa6a9b67ff6ce5a7e4cd0238a47">OGR_G_ExportToJson</a> (OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a geometry into GeoJSON format.  <a href="#a9ebd5fa6a9b67ff6ce5a7e4cd0238a47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a97f1713300ac83c3cf31f40b419b9c0d">OGR_G_ExportToJsonEx</a> (OGRGeometryH, char **papszOptions)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a geometry into GeoJSON format.  <a href="#a97f1713300ac83c3cf31f40b419b9c0d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4dfbd5861e1cd20b372d090539fa4536">OGR_G_AssignSpatialReference</a> (OGRGeometryH, OGRSpatialReferenceH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign spatial reference to this object.  <a href="#a4dfbd5861e1cd20b372d090539fa4536"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRSpatialReferenceH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#abc393e40282eec3801fb4a4abc9e25bf">OGR_G_GetSpatialReference</a> (OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns spatial reference system for geometry.  <a href="#abc393e40282eec3801fb4a4abc9e25bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a59a5b3f954b11cfbf6e78807c28d6090">OGR_G_Transform</a> (OGRGeometryH, OGRCoordinateTransformationH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Apply arbitrary coordinate transformation to geometry.  <a href="#a59a5b3f954b11cfbf6e78807c28d6090"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a43af4c2127cea0a5059692a62c0feb63">OGR_G_TransformTo</a> (OGRGeometryH, OGRSpatialReferenceH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transform geometry to new spatial reference system.  <a href="#a43af4c2127cea0a5059692a62c0feb63"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRGeometryH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a0453f97e9d4fc44e13787ad1a8439c0c">OGR_G_Simplify</a> (OGRGeometryH hThis, double tolerance)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute a simplified geometry.  <a href="#a0453f97e9d4fc44e13787ad1a8439c0c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRGeometryH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a8e19e9cfa01744db6a2e8eee710611b6">OGR_G_SimplifyPreserveTopology</a> (OGRGeometryH hThis, double tolerance)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simplify the geometry while preserving topology.  <a href="#a8e19e9cfa01744db6a2e8eee710611b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ade9f08c8d63bc0e726cb20c201c86423">OGR_G_Segmentize</a> (OGRGeometryH hGeom, double dfMaxLength)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modify the geometry such it has no segment longer then the given distance.  <a href="#ade9f08c8d63bc0e726cb20c201c86423"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#acaed6926b75cd33a42b284c10def6e87">OGR_G_Intersects</a> (OGRGeometryH, OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Do these features intersect?  <a href="#acaed6926b75cd33a42b284c10def6e87"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#abaed0c4fb6f08abc280f91619e2e47d3">OGR_G_Equals</a> (OGRGeometryH, OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns TRUE if two geometries are equivalent.  <a href="#abaed0c4fb6f08abc280f91619e2e47d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a7980d65f3d82d5a5442c5141efe3f503">OGR_G_Disjoint</a> (OGRGeometryH, OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test for disjointness.  <a href="#a7980d65f3d82d5a5442c5141efe3f503"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6f67616eb88f479eba50f9783c8494d9">OGR_G_Touches</a> (OGRGeometryH, OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test for touching.  <a href="#a6f67616eb88f479eba50f9783c8494d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a7af82e14406879c08841331b2a4cfe7c">OGR_G_Crosses</a> (OGRGeometryH, OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test for crossing.  <a href="#a7af82e14406879c08841331b2a4cfe7c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a80ba9e516ccae381ae7240cc9684eb72">OGR_G_Within</a> (OGRGeometryH, OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test for containment.  <a href="#a80ba9e516ccae381ae7240cc9684eb72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad87e37380f0320faddbe5e67e23312f8">OGR_G_Contains</a> (OGRGeometryH, OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test for containment.  <a href="#ad87e37380f0320faddbe5e67e23312f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a07acfe1bef39cd2cd1ad4a5ec26f2ceb">OGR_G_Overlaps</a> (OGRGeometryH, OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test for overlap.  <a href="#a07acfe1bef39cd2cd1ad4a5ec26f2ceb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRGeometryH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a95447f722f907b7143a1fc19005dd20b">OGR_G_Boundary</a> (OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute boundary.  <a href="#a95447f722f907b7143a1fc19005dd20b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRGeometryH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a7a93026cfae8ee6ce25546dba1b2df7d">OGR_G_ConvexHull</a> (OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute convex hull.  <a href="#a7a93026cfae8ee6ce25546dba1b2df7d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRGeometryH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a1ca0bd5c0fcb4b1af3c3973e467b0ec0">OGR_G_Buffer</a> (OGRGeometryH, double, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute buffer of geometry.  <a href="#a1ca0bd5c0fcb4b1af3c3973e467b0ec0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRGeometryH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a5a271b5c7b72994120e7a6bbc7e7e5cb">OGR_G_Intersection</a> (OGRGeometryH, OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute intersection.  <a href="#a5a271b5c7b72994120e7a6bbc7e7e5cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRGeometryH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#af58f2cfbdb2497659d2eabea73d3b8a0">OGR_G_Union</a> (OGRGeometryH, OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute union.  <a href="#af58f2cfbdb2497659d2eabea73d3b8a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRGeometryH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a2bb45d7d6ca9641be5f0773f1d60aa0f">OGR_G_UnionCascaded</a> (OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute union using cascading.  <a href="#a2bb45d7d6ca9641be5f0773f1d60aa0f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRGeometryH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#af89dc63f138aee453cf8ff3e2b1c0833">OGR_G_PointOnSurface</a> (OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a point guaranteed to lie on the surface.  <a href="#af89dc63f138aee453cf8ff3e2b1c0833"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRGeometryH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a497977bec6ecd9dade7a9694f776be64">OGR_G_Difference</a> (OGRGeometryH, OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute difference.  <a href="#a497977bec6ecd9dade7a9694f776be64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRGeometryH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a2b047fca89d06a08a5c34f210c4c97d5">OGR_G_SymDifference</a> (OGRGeometryH, OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute symmetric difference.  <a href="#a2b047fca89d06a08a5c34f210c4c97d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ab01002a9fd4175832af965930f069401">OGR_G_Distance</a> (OGRGeometryH, OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute distance between two geometries.  <a href="#ab01002a9fd4175832af965930f069401"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a5eb038c3271dbf41ac7ebc02fad3907f">OGR_G_Length</a> (OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute length of a geometry.  <a href="#a5eb038c3271dbf41ac7ebc02fad3907f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a2a849c584cd22a199bcfb9b34b9a1a8f">OGR_G_Area</a> (OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute geometry area.  <a href="#a2a849c584cd22a199bcfb9b34b9a1a8f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a23f5a19a81628af7f9cc59a37378cb2b">OGR_G_Centroid</a> (OGRGeometryH, OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the geometry centroid.  <a href="#a23f5a19a81628af7f9cc59a37378cb2b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a90cc83b0a3052b8fbe2ed77a86323bf2">OGR_G_Empty</a> (OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear geometry information. This restores the geometry to it's initial state after construction, and before assignment of actual geometry.  <a href="#a90cc83b0a3052b8fbe2ed77a86323bf2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a737b0c4d73928e7406d69c658209dbbf">OGR_G_IsEmpty</a> (OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if the geometry is empty.  <a href="#a737b0c4d73928e7406d69c658209dbbf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4df68924f3b41fd377c5b4aa6631a00b">OGR_G_IsValid</a> (OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if the geometry is valid.  <a href="#a4df68924f3b41fd377c5b4aa6631a00b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a3cb66472d7e302d16aacf0d66c01ac73">OGR_G_IsSimple</a> (OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns TRUE if the geometry is simple.  <a href="#a3cb66472d7e302d16aacf0d66c01ac73"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ab9e99b4792042aca861866cb29bdf826">OGR_G_IsRing</a> (OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if the geometry is a ring.  <a href="#ab9e99b4792042aca861866cb29bdf826"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRGeometryH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a673c6c4745d5092fb250ae5342bc1b3b">OGR_G_Polygonize</a> (OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Polygonizes a set of sparse edges.  <a href="#a673c6c4745d5092fb250ae5342bc1b3b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRGeometryH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aed147010bb540b4710c68d30c62da50f">OGR_G_SymmetricDifference</a> (OGRGeometryH, OGRGeometryH) CPL_WARN_DEPRECATED(&quot;Non standard method. Use OGR_G_SymDifference() instead&quot;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute symmetric difference (deprecated).  <a href="#aed147010bb540b4710c68d30c62da50f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a660b737a75579daf2cc78d24ccd4311d">OGR_G_GetArea</a> (OGRGeometryH) CPL_WARN_DEPRECATED(&quot;Non standard method. Use OGR_G_Area() instead&quot;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute geometry area (deprecated).  <a href="#a660b737a75579daf2cc78d24ccd4311d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRGeometryH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a0d479e8f0e97d6244af8776d5ea6efbb">OGR_G_GetBoundary</a> (OGRGeometryH) CPL_WARN_DEPRECATED(&quot;Non standard method. Use OGR_G_Boundary() instead&quot;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute boundary (deprecated).  <a href="#a0d479e8f0e97d6244af8776d5ea6efbb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aec43cbe83609bc7b43739d67858846c1">OGR_G_GetPointCount</a> (OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch number of points from a geometry.  <a href="#aec43cbe83609bc7b43739d67858846c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6c22d91b27d7a42c225a7dfde28f09c4">OGR_G_GetPoints</a> (OGRGeometryH hGeom, void *pabyX, int nXStride, void *pabyY, int nYStride, void *pabyZ, int nZStride)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns all points of line string.  <a href="#a6c22d91b27d7a42c225a7dfde28f09c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a354146161d0a087b63ab6e350bae4d86">OGR_G_GetX</a> (OGRGeometryH, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the x coordinate of a point from a geometry.  <a href="#a354146161d0a087b63ab6e350bae4d86"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a8405350c9aea2ab7d0f759f0b09b926f">OGR_G_GetY</a> (OGRGeometryH, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the x coordinate of a point from a geometry.  <a href="#a8405350c9aea2ab7d0f759f0b09b926f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a1d8c6aeb013325f33b8e642003fc17ad">OGR_G_GetZ</a> (OGRGeometryH, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the z coordinate of a point from a geometry.  <a href="#a1d8c6aeb013325f33b8e642003fc17ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a67b897ffcd88a83832964c3735fa1dcb">OGR_G_GetPoint</a> (OGRGeometryH, int iPoint, double *, double *, double *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch a point in line string or a point geometry.  <a href="#a67b897ffcd88a83832964c3735fa1dcb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4f4f7bff0d685b2713504bd89b14d0fc">OGR_G_SetPointCount</a> (OGRGeometryH hGeom, int nNewPointCount)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set number of points in a geometry.  <a href="#a4f4f7bff0d685b2713504bd89b14d0fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a303fb1a2a94363c15f9e61dc46b710e8">OGR_G_SetPoint</a> (OGRGeometryH, int iPoint, double, double, double)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the location of a vertex in a point or linestring geometry.  <a href="#a303fb1a2a94363c15f9e61dc46b710e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ab14b9730d6f9fc829fe6be9bc2a5ec48">OGR_G_SetPoint_2D</a> (OGRGeometryH, int iPoint, double, double)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the location of a vertex in a point or linestring geometry.  <a href="#ab14b9730d6f9fc829fe6be9bc2a5ec48"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aa2702d812663bc767e3a8f8832fda089">OGR_G_AddPoint</a> (OGRGeometryH, double, double, double)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a point to a geometry (line string or point).  <a href="#aa2702d812663bc767e3a8f8832fda089"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a280275c1492d6426cfe0a918d4725374">OGR_G_AddPoint_2D</a> (OGRGeometryH, double, double)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a point to a geometry (line string or point).  <a href="#a280275c1492d6426cfe0a918d4725374"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a20abd3bb0d4a31b758883312db11cb70">OGR_G_SetPoints</a> (OGRGeometryH hGeom, int nPointsIn, void *pabyX, int nXStride, void *pabyY, int nYStride, void *pabyZ, int nZStride)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign all points in a point or a line string geometry.  <a href="#a20abd3bb0d4a31b758883312db11cb70"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a1fa07ddf969f97f6444de6ae5128d842">OGR_G_GetGeometryCount</a> (OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the number of elements in a geometry or number of geometries in container.  <a href="#a1fa07ddf969f97f6444de6ae5128d842"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRGeometryH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6bac93150529a5c98811db29e289dd66">OGR_G_GetGeometryRef</a> (OGRGeometryH, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch geometry from a geometry container.  <a href="#a6bac93150529a5c98811db29e289dd66"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4a15e130614cb4c66fc99bb93dc6b3b5">OGR_G_AddGeometry</a> (OGRGeometryH, OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a geometry to a geometry container.  <a href="#a4a15e130614cb4c66fc99bb93dc6b3b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aff56cae8305396a9c5b690d8356e39c9">OGR_G_AddGeometryDirectly</a> (OGRGeometryH, OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a geometry directly to an existing geometry container.  <a href="#aff56cae8305396a9c5b690d8356e39c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a54ea024bb659e48d3297404e53800237">OGR_G_RemoveGeometry</a> (OGRGeometryH, int, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a geometry from an exiting geometry container.  <a href="#a54ea024bb659e48d3297404e53800237"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRGeometryH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a74f64386be8d675e8da33d289ccc9892">OGRBuildPolygonFromEdges</a> (OGRGeometryH hLinesAsCollection, int bBestEffort, int bAutoClose, double dfTolerance, OGRErr *peErr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6d61898bb6267c18ff4a7ec909b0f040">OGRSetGenerate_DB2_V72_BYTE_ORDER</a> (int bGenerate_DB2_V72_BYTE_ORDER)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special entry point to enable the hack for generating DB2 V7.2 style WKB.  <a href="#a6d61898bb6267c18ff4a7ec909b0f040"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRFieldDefnH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a24af159359797a83c354fdf6cced3265">OGR_Fld_Create</a> (const char *, <a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a>) CPL_WARN_UNUSED_RESULT</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new field definition.  <a href="#a24af159359797a83c354fdf6cced3265"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a455fa4a2c2451b1748facb6b7126a822">OGR_Fld_Destroy</a> (OGRFieldDefnH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy a field definition.  <a href="#a455fa4a2c2451b1748facb6b7126a822"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6599fa42bad3aba26574ae3260c6984d">OGR_Fld_SetName</a> (OGRFieldDefnH, const char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset the name of this field.  <a href="#a6599fa42bad3aba26574ae3260c6984d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a8d7640a6b6a47a95d83415f9271ffe30">OGR_Fld_GetNameRef</a> (OGRFieldDefnH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch name of this field.  <a href="#a8d7640a6b6a47a95d83415f9271ffe30"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad8d150dfc678e0a2a7f5241ba38c5611">OGR_Fld_GetType</a> (OGRFieldDefnH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch type of this field.  <a href="#ad8d150dfc678e0a2a7f5241ba38c5611"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a76195990f814eb93e821c01ce0599a50">OGR_Fld_SetType</a> (OGRFieldDefnH, <a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the type of this field. This should never be done to an <a class="el" href="classOGRFieldDefn.html">OGRFieldDefn</a> that is already part of an <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a>.  <a href="#a76195990f814eb93e821c01ce0599a50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#a701976be938cd60a2fa96454f61d3600">OGRJustification</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a0cf8a09826e47763e6bf667af0dae1a7">OGR_Fld_GetJustify</a> (OGRFieldDefnH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the justification for this field.  <a href="#a0cf8a09826e47763e6bf667af0dae1a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ae4809f2fe957002b8e18aacc1bdca240">OGR_Fld_SetJustify</a> (OGRFieldDefnH, <a class="el" href="ogr__core_8h.html#a701976be938cd60a2fa96454f61d3600">OGRJustification</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the justification for this field.  <a href="#ae4809f2fe957002b8e18aacc1bdca240"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aa6500186e3f22761a615428c55bba0ce">OGR_Fld_GetWidth</a> (OGRFieldDefnH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the formatting width for this field.  <a href="#aa6500186e3f22761a615428c55bba0ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a1d7bf7c14a299448efac58f7bf364326">OGR_Fld_SetWidth</a> (OGRFieldDefnH, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the formatting width for this field in characters.  <a href="#a1d7bf7c14a299448efac58f7bf364326"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a120dd56ee23070922e4d84ed06b06e27">OGR_Fld_GetPrecision</a> (OGRFieldDefnH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the formatting precision for this field. This should normally be zero for fields of types other than OFTReal.  <a href="#a120dd56ee23070922e4d84ed06b06e27"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a13890f01f7d7e57bcd07e23f3e2947da">OGR_Fld_SetPrecision</a> (OGRFieldDefnH, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the formatting precision for this field in characters.  <a href="#a13890f01f7d7e57bcd07e23f3e2947da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a5922e599fe8746b81adf251be6b5ecf0">OGR_Fld_Set</a> (OGRFieldDefnH, const char *, <a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a>, int, int, <a class="el" href="ogr__core_8h.html#a701976be938cd60a2fa96454f61d3600">OGRJustification</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set defining parameters for a field in one call.  <a href="#a5922e599fe8746b81adf251be6b5ecf0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a29bec35ae5a4c232ad850315bdc2b675">OGR_Fld_IsIgnored</a> (OGRFieldDefnH hDefn)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return whether this field should be omitted when fetching features.  <a href="#a29bec35ae5a4c232ad850315bdc2b675"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aeddf9aa9767cd28c90dc66ed2a7a7332">OGR_Fld_SetIgnored</a> (OGRFieldDefnH hDefn, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set whether this field should be omitted when fetching features.  <a href="#aeddf9aa9767cd28c90dc66ed2a7a7332"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#af1e61b89ae2d799cf5e217d01ef7b415">OGR_GetFieldTypeName</a> (<a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch human readable name for a field type.  <a href="#af1e61b89ae2d799cf5e217d01ef7b415"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRGeomFieldDefnH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4681750642cae49933ba4fc962744b78">OGR_GFld_Create</a> (const char *, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>) CPL_WARN_UNUSED_RESULT</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new field geometry definition.  <a href="#a4681750642cae49933ba4fc962744b78"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a0f3e65993ea2b8b907e43ffa8b106871">OGR_GFld_Destroy</a> (OGRGeomFieldDefnH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy a geometry field definition.  <a href="#a0f3e65993ea2b8b907e43ffa8b106871"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6c9b9d56381cae346c5129943641f628">OGR_GFld_SetName</a> (OGRGeomFieldDefnH, const char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset the name of this field.  <a href="#a6c9b9d56381cae346c5129943641f628"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad9914366a6cc3b4169a3359c2b1ef614">OGR_GFld_GetNameRef</a> (OGRGeomFieldDefnH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch name of this field.  <a href="#ad9914366a6cc3b4169a3359c2b1ef614"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a323f4350c2e90c6e67df37f68d244a0d">OGR_GFld_GetType</a> (OGRGeomFieldDefnH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch geometry type of this field.  <a href="#a323f4350c2e90c6e67df37f68d244a0d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#affb3691474967ca5f0c9789e0626d55f">OGR_GFld_SetType</a> (OGRGeomFieldDefnH, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the geometry type of this field. This should never be done to an <a class="el" href="classOGRGeomFieldDefn.html">OGRGeomFieldDefn</a> that is already part of an <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a>.  <a href="#affb3691474967ca5f0c9789e0626d55f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRSpatialReferenceH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a7927b11a85659d8ce6da8857f52b05c4">OGR_GFld_GetSpatialRef</a> (OGRGeomFieldDefnH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch spatial reference system of this field.  <a href="#a7927b11a85659d8ce6da8857f52b05c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aa717acc8f4f5f33825334fe72edc2be9">OGR_GFld_SetSpatialRef</a> (OGRGeomFieldDefnH, OGRSpatialReferenceH hSRS)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the spatial reference of this field.  <a href="#aa717acc8f4f5f33825334fe72edc2be9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ab232798830d8dcae0742d83948e33d1a">OGR_GFld_IsIgnored</a> (OGRGeomFieldDefnH hDefn)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return whether this field should be omitted when fetching features.  <a href="#ab232798830d8dcae0742d83948e33d1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#af3a4e5e2af01140209e9d2814869eb41">OGR_GFld_SetIgnored</a> (OGRGeomFieldDefnH hDefn, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set whether this field should be omitted when fetching features.  <a href="#af3a4e5e2af01140209e9d2814869eb41"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRFeatureDefnH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a8cbc5146fcab99667f021c40c714628c">OGR_FD_Create</a> (const char *) CPL_WARN_UNUSED_RESULT</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new feature definition object to hold the field definitions.  <a href="#a8cbc5146fcab99667f021c40c714628c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a59d5cbb660cce8467a210caa4d68a011">OGR_FD_Destroy</a> (OGRFeatureDefnH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy a feature definition object and release all memory associated with it.  <a href="#a59d5cbb660cce8467a210caa4d68a011"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a0755b0360414095e15eaf2c1496f8c47">OGR_FD_Release</a> (OGRFeatureDefnH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Drop a reference, and destroy if unreferenced.  <a href="#a0755b0360414095e15eaf2c1496f8c47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a20f309bf10e5b76cc083848b710babb8">OGR_FD_GetName</a> (OGRFeatureDefnH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get name of the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> passed as an argument.  <a href="#a20f309bf10e5b76cc083848b710babb8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a586a14271a457387a2b5c0097a02c8da">OGR_FD_GetFieldCount</a> (OGRFeatureDefnH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch number of fields on the passed feature definition.  <a href="#a586a14271a457387a2b5c0097a02c8da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRFieldDefnH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a484456df86a01284769d0afe3beaa4f6">OGR_FD_GetFieldDefn</a> (OGRFeatureDefnH, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch field definition of the passed feature definition.  <a href="#a484456df86a01284769d0afe3beaa4f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a1e54c3271dce0562209d78ae6eaae330">OGR_FD_GetFieldIndex</a> (OGRFeatureDefnH, const char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find field by name.  <a href="#a1e54c3271dce0562209d78ae6eaae330"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a2a798e8d03299403418a7c87862f1acb">OGR_FD_AddFieldDefn</a> (OGRFeatureDefnH, OGRFieldDefnH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new field definition to the passed feature definition.  <a href="#a2a798e8d03299403418a7c87862f1acb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6283475163d911204f5ff45098c8479e">OGR_FD_DeleteFieldDefn</a> (OGRFeatureDefnH hDefn, int iField)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete an existing field definition.  <a href="#a6283475163d911204f5ff45098c8479e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#add0b3a6b6062122e4f4316d194d2a1cf">OGR_FD_GetGeomType</a> (OGRFeatureDefnH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the geometry base type of the passed feature definition.  <a href="#add0b3a6b6062122e4f4316d194d2a1cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a11ca3a84b54ac36c5f68a03821f1fa78">OGR_FD_SetGeomType</a> (OGRFeatureDefnH, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign the base geometry type for the passed layer (the same as the feature definition).  <a href="#a11ca3a84b54ac36c5f68a03821f1fa78"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad1208985f67db526136dbe74f490c8d3">OGR_FD_IsGeometryIgnored</a> (OGRFeatureDefnH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine whether the geometry can be omitted when fetching features.  <a href="#ad1208985f67db526136dbe74f490c8d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a1bbc85e1ba2378679e4ce6bf3523bf8e">OGR_FD_SetGeometryIgnored</a> (OGRFeatureDefnH, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set whether the geometry can be omitted when fetching features.  <a href="#a1bbc85e1ba2378679e4ce6bf3523bf8e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aa9490e3e5d25b780723ad3f0ab3302eb">OGR_FD_IsStyleIgnored</a> (OGRFeatureDefnH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine whether the style can be omitted when fetching features.  <a href="#aa9490e3e5d25b780723ad3f0ab3302eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6c09218e9ef9e49abcdd0b76858a514b">OGR_FD_SetStyleIgnored</a> (OGRFeatureDefnH, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set whether the style can be omitted when fetching features.  <a href="#a6c09218e9ef9e49abcdd0b76858a514b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6763104e7fafcab1b52d9b0f275e19e8">OGR_FD_Reference</a> (OGRFeatureDefnH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increments the reference count by one.  <a href="#a6763104e7fafcab1b52d9b0f275e19e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a107635936c90c7f4347d7b3f9fb06e6d">OGR_FD_Dereference</a> (OGRFeatureDefnH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decrements the reference count by one.  <a href="#a107635936c90c7f4347d7b3f9fb06e6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9e4e8867edeaf1a6f98e6ff284835811">OGR_FD_GetReferenceCount</a> (OGRFeatureDefnH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch current reference count.  <a href="#a9e4e8867edeaf1a6f98e6ff284835811"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a0b34027b691ea40e20b911290f863303">OGR_FD_GetGeomFieldCount</a> (OGRFeatureDefnH hFDefn)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch number of geometry fields on the passed feature definition.  <a href="#a0b34027b691ea40e20b911290f863303"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRGeomFieldDefnH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a82275ef1d2655817f6fe582f885c92c7">OGR_FD_GetGeomFieldDefn</a> (OGRFeatureDefnH hFDefn, int i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch geometry field definition of the passed feature definition.  <a href="#a82275ef1d2655817f6fe582f885c92c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a69be97ea100c50bdaad8a1d3c30e7b14">OGR_FD_GetGeomFieldIndex</a> (OGRFeatureDefnH hFDefn, const char *pszName)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find geometry field by name.  <a href="#a69be97ea100c50bdaad8a1d3c30e7b14"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aa080fdbe88c1829c1b7adcce208ec4b8">OGR_FD_AddGeomFieldDefn</a> (OGRFeatureDefnH hFDefn, OGRGeomFieldDefnH hGFldDefn)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new field definition to the passed feature definition.  <a href="#aa080fdbe88c1829c1b7adcce208ec4b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a1fb650102be3837fc220b086b17f4462">OGR_FD_DeleteGeomFieldDefn</a> (OGRFeatureDefnH hFDefn, int iGeomField)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete an existing geometry field definition.  <a href="#a1fb650102be3837fc220b086b17f4462"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ab07056d514160c26724f3a2d5319185f">OGR_FD_IsSame</a> (OGRFeatureDefnH hFDefn, OGRFeatureDefnH hOtherFDefn)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if the feature definition is identical to the other one.  <a href="#ab07056d514160c26724f3a2d5319185f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRFeatureH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a335fbf2220d7f93437621cae723558ac">OGR_F_Create</a> (OGRFeatureDefnH) CPL_WARN_UNUSED_RESULT</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Feature factory.  <a href="#a335fbf2220d7f93437621cae723558ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a16fb8126aa932f4b4acdaca5ea99bbbb">OGR_F_Destroy</a> (OGRFeatureH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy feature.  <a href="#a16fb8126aa932f4b4acdaca5ea99bbbb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRFeatureDefnH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a123dfa431bf655aafd2dbd42247dd7be">OGR_F_GetDefnRef</a> (OGRFeatureH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch feature definition.  <a href="#a123dfa431bf655aafd2dbd42247dd7be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad391d3197728bb6d12a6b0c2e2661aa4">OGR_F_SetGeometryDirectly</a> (OGRFeatureH, OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set feature geometry.  <a href="#ad391d3197728bb6d12a6b0c2e2661aa4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a7b9c524f5c01a6a4b4e50e351d03299f">OGR_F_SetGeometry</a> (OGRFeatureH, OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set feature geometry.  <a href="#a7b9c524f5c01a6a4b4e50e351d03299f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRGeometryH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a1bf9596756aeacec4da502383c378f5c">OGR_F_GetGeometryRef</a> (OGRFeatureH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch an handle to feature geometry.  <a href="#a1bf9596756aeacec4da502383c378f5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRGeometryH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a5a6a61d39a67b1990ce92bd65de4bc6f">OGR_F_StealGeometry</a> (OGRFeatureH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Take away ownership of geometry.  <a href="#a5a6a61d39a67b1990ce92bd65de4bc6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRFeatureH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a90c0adfd518b71571d9ce8d976fab320">OGR_F_Clone</a> (OGRFeatureH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Duplicate feature.  <a href="#a90c0adfd518b71571d9ce8d976fab320"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a8b6a502ec0b70f3de50e7184a087a264">OGR_F_Equal</a> (OGRFeatureH, OGRFeatureH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if two features are the same.  <a href="#a8b6a502ec0b70f3de50e7184a087a264"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#af6c1440956ee56c0c160394bccf96990">OGR_F_GetFieldCount</a> (OGRFeatureH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch number of fields on this feature This will always be the same as the field count for the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a>.  <a href="#af6c1440956ee56c0c160394bccf96990"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRFieldDefnH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6f8fc7fd6ecca789ad90db6d28391623">OGR_F_GetFieldDefnRef</a> (OGRFeatureH, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch definition for this field.  <a href="#a6f8fc7fd6ecca789ad90db6d28391623"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9a8a6b93ab97204b94f5c2b358f8f98e">OGR_F_GetFieldIndex</a> (OGRFeatureH, const char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the field index given field name.  <a href="#a9a8a6b93ab97204b94f5c2b358f8f98e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#abb018a9030ed76353ae26082deaaef11">OGR_F_IsFieldSet</a> (OGRFeatureH, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if a field has ever been assigned a value or not.  <a href="#abb018a9030ed76353ae26082deaaef11"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aa70b7675a003141e63f9603c752ee22e">OGR_F_UnsetField</a> (OGRFeatureH, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear a field, marking it as unset.  <a href="#aa70b7675a003141e63f9603c752ee22e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="unionOGRField.html">OGRField</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#af7043e9dfadbdeca8059ace336875d4c">OGR_F_GetRawFieldRef</a> (OGRFeatureH, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch an handle to the internal field value given the index.  <a href="#af7043e9dfadbdeca8059ace336875d4c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#acfb4d2c0001af379e396021ecbdaf275">OGR_F_GetFieldAsInteger</a> (OGRFeatureH, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch field value as integer.  <a href="#acfb4d2c0001af379e396021ecbdaf275"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a62252a0d4538c695d41956a96cdc6978">OGR_F_GetFieldAsDouble</a> (OGRFeatureH, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch field value as a double.  <a href="#a62252a0d4538c695d41956a96cdc6978"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a42acfd1f4b49dddc1c308462ae800c26">OGR_F_GetFieldAsString</a> (OGRFeatureH, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch field value as a string.  <a href="#a42acfd1f4b49dddc1c308462ae800c26"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const int *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac671852e05692c584b493b2acbd6b8ce">OGR_F_GetFieldAsIntegerList</a> (OGRFeatureH, int, int *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch field value as a list of integers.  <a href="#ac671852e05692c584b493b2acbd6b8ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4a27f74a38506ac492ec8b6e00eb58c9">OGR_F_GetFieldAsDoubleList</a> (OGRFeatureH, int, int *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch field value as a list of doubles.  <a href="#a4a27f74a38506ac492ec8b6e00eb58c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a3e55ba4a06d4c4a392206518b390ac38">OGR_F_GetFieldAsStringList</a> (OGRFeatureH, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch field value as a list of strings.  <a href="#a3e55ba4a06d4c4a392206518b390ac38"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GByte *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a72727f2f59d1defa01cedfb884df1a09">OGR_F_GetFieldAsBinary</a> (OGRFeatureH, int, int *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch field value as binary.  <a href="#a72727f2f59d1defa01cedfb884df1a09"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a47ca681bb6099eb8c18004d1f7112d95">OGR_F_GetFieldAsDateTime</a> (OGRFeatureH, int, int *, int *, int *, int *, int *, int *, int *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch field value as date and time.  <a href="#a47ca681bb6099eb8c18004d1f7112d95"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad902fb7c7fe459aacf0b2c26b8e6d1ee">OGR_F_SetFieldInteger</a> (OGRFeatureH, int, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set field to integer value.  <a href="#ad902fb7c7fe459aacf0b2c26b8e6d1ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9d28aa13b1b7c88f07066c36286d13b9">OGR_F_SetFieldDouble</a> (OGRFeatureH, int, double)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set field to double value.  <a href="#a9d28aa13b1b7c88f07066c36286d13b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad1a3e8b4a08f9558807389bcdde85bab">OGR_F_SetFieldString</a> (OGRFeatureH, int, const char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set field to string value.  <a href="#ad1a3e8b4a08f9558807389bcdde85bab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a2b7dee0dc057570af68a01ec0b5d3753">OGR_F_SetFieldIntegerList</a> (OGRFeatureH, int, int, int *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set field to list of integers value.  <a href="#a2b7dee0dc057570af68a01ec0b5d3753"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6ba075923f49a5abd6637183731cb6ab">OGR_F_SetFieldDoubleList</a> (OGRFeatureH, int, int, double *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set field to list of doubles value.  <a href="#a6ba075923f49a5abd6637183731cb6ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9f055dc02fa8f1047849f6e30b4b86d4">OGR_F_SetFieldStringList</a> (OGRFeatureH, int, char **)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set field to list of strings value.  <a href="#a9f055dc02fa8f1047849f6e30b4b86d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#af3cfe4f766f5579f670bb651c53a99ca">OGR_F_SetFieldRaw</a> (OGRFeatureH, int, <a class="el" href="unionOGRField.html">OGRField</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set field.  <a href="#af3cfe4f766f5579f670bb651c53a99ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a5dcaa7d3e71f078ae714831f7c5cae1d">OGR_F_SetFieldBinary</a> (OGRFeatureH, int, int, GByte *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set field to binary data.  <a href="#a5dcaa7d3e71f078ae714831f7c5cae1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a627970180a20e2a4b1c7ae694923fd73">OGR_F_SetFieldDateTime</a> (OGRFeatureH, int, int, int, int, int, int, int, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set field to datetime.  <a href="#a627970180a20e2a4b1c7ae694923fd73"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a7975076d4ab247189487c0fd50d8365c">OGR_F_GetGeomFieldCount</a> (OGRFeatureH hFeat)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch number of geometry fields on this feature This will always be the same as the geometry field count for the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a>.  <a href="#a7975076d4ab247189487c0fd50d8365c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRGeomFieldDefnH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a11c3d59a3854dad80c4257e788c5d881">OGR_F_GetGeomFieldDefnRef</a> (OGRFeatureH hFeat, int iField)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch definition for this geometry field.  <a href="#a11c3d59a3854dad80c4257e788c5d881"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a546acd0aad47128b1f178a8d01765e63">OGR_F_GetGeomFieldIndex</a> (OGRFeatureH hFeat, const char *pszName)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the geometry field index given geometry field name.  <a href="#a546acd0aad47128b1f178a8d01765e63"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRGeometryH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a37aa8b53b1fc8816c5b7bcbbcb6a46ca">OGR_F_GetGeomFieldRef</a> (OGRFeatureH hFeat, int iField)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch an handle to feature geometry.  <a href="#a37aa8b53b1fc8816c5b7bcbbcb6a46ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a01530e163973979cfd8248e3ecbf2640">OGR_F_SetGeomFieldDirectly</a> (OGRFeatureH hFeat, int iField, OGRGeometryH hGeom)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set feature geometry of a specified geometry field.  <a href="#a01530e163973979cfd8248e3ecbf2640"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad75b18930385432110aa8d3461854cce">OGR_F_SetGeomField</a> (OGRFeatureH hFeat, int iField, OGRGeometryH hGeom)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set feature geometry of a specified geometry field.  <a href="#ad75b18930385432110aa8d3461854cce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a95bc391bf7883a8732a523d525c26a00">OGR_F_GetFID</a> (OGRFeatureH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get feature identifier.  <a href="#a95bc391bf7883a8732a523d525c26a00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a09d01eea41746751db62da123887e787">OGR_F_SetFID</a> (OGRFeatureH, long)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the feature identifier.  <a href="#a09d01eea41746751db62da123887e787"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ae38d330f942798fcbaaf27e5807fb567">OGR_F_DumpReadable</a> (OGRFeatureH, FILE *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dump this feature in a human readable form.  <a href="#ae38d330f942798fcbaaf27e5807fb567"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad7f7057a7a3764c526a4a59e2b587fba">OGR_F_SetFrom</a> (OGRFeatureH, OGRFeatureH, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set one feature from another.  <a href="#ad7f7057a7a3764c526a4a59e2b587fba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a0f36f1fba9d148f467c8156a31bdd9be">OGR_F_SetFromWithMap</a> (OGRFeatureH, OGRFeatureH, int, int *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set one feature from another.  <a href="#a0f36f1fba9d148f467c8156a31bdd9be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a10fb5f53d99ccf46280e4c38afe4a5a5">OGR_F_GetStyleString</a> (OGRFeatureH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch style string for this feature.  <a href="#a10fb5f53d99ccf46280e4c38afe4a5a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#afbe436a7a48ad5bbfb3aa34f44791a68">OGR_F_SetStyleString</a> (OGRFeatureH, const char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set feature style string. This method operate exactly as <a class="el" href="ogr__api_8h.html#abc1ab2f6fb7937a8b927e4c1d3fd057c" title="Set feature style string. This method operate exactly as OGR_F_SetStyleString() except that it assume...">OGR_F_SetStyleStringDirectly()</a> except that it does not assume ownership of the passed string, but instead makes a copy of it.  <a href="#afbe436a7a48ad5bbfb3aa34f44791a68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#abc1ab2f6fb7937a8b927e4c1d3fd057c">OGR_F_SetStyleStringDirectly</a> (OGRFeatureH, char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set feature style string. This method operate exactly as <a class="el" href="ogr__api_8h.html#afbe436a7a48ad5bbfb3aa34f44791a68" title="Set feature style string. This method operate exactly as OGR_F_SetStyleStringDirectly() except that i...">OGR_F_SetStyleString()</a> except that it assumes ownership of the passed string.  <a href="#abc1ab2f6fb7937a8b927e4c1d3fd057c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a88facf4f8e8b32278101d52ae094255c">OGR_L_GetName</a> (OGRLayerH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the layer name.  <a href="#a88facf4f8e8b32278101d52ae094255c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a0adea8ce1ca795ce0a6a76505f90f078">OGR_L_GetGeomType</a> (OGRLayerH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the layer geometry type.  <a href="#a0adea8ce1ca795ce0a6a76505f90f078"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRGeometryH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a36d61f311c9f8c172ad118659358c60a">OGR_L_GetSpatialFilter</a> (OGRLayerH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function returns the current spatial filter for this layer.  <a href="#a36d61f311c9f8c172ad118659358c60a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a678d1735bc82533614ac005691d1138c">OGR_L_SetSpatialFilter</a> (OGRLayerH, OGRGeometryH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a new spatial filter.  <a href="#a678d1735bc82533614ac005691d1138c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a5cba569e0779a02a95327f041d9f7a13">OGR_L_SetSpatialFilterRect</a> (OGRLayerH, double, double, double, double)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a new rectangular spatial filter.  <a href="#a5cba569e0779a02a95327f041d9f7a13"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a00c8a1a968542d389f86ed1b4edd5823">OGR_L_SetSpatialFilterEx</a> (OGRLayerH, int iGeomField, OGRGeometryH hGeom)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a new spatial filter.  <a href="#a00c8a1a968542d389f86ed1b4edd5823"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a489241dfe65d6e089809d3258c4f79f5">OGR_L_SetSpatialFilterRectEx</a> (OGRLayerH, int iGeomField, double dfMinX, double dfMinY, double dfMaxX, double dfMaxY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a new rectangular spatial filter.  <a href="#a489241dfe65d6e089809d3258c4f79f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4000d426bf26ad7cc7d4012634c93f09">OGR_L_SetAttributeFilter</a> (OGRLayerH, const char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a new attribute query.  <a href="#a4000d426bf26ad7cc7d4012634c93f09"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ab0383004bf637171648a9d03a80f15a4">OGR_L_ResetReading</a> (OGRLayerH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset feature reading to start on the first feature.  <a href="#ab0383004bf637171648a9d03a80f15a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRFeatureH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6708c067521ab7b7f9c4ec0ebe221b5b">OGR_L_GetNextFeature</a> (OGRLayerH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the next available feature from this layer.  <a href="#a6708c067521ab7b7f9c4ec0ebe221b5b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a5bb3f366e3e6cd8cb586842193b4a7f9">OGR_L_SetNextByIndex</a> (OGRLayerH, long)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move read cursor to the nIndex'th feature in the current resultset.  <a href="#a5bb3f366e3e6cd8cb586842193b4a7f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRFeatureH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a7c628dce8939904154b50365306b06f9">OGR_L_GetFeature</a> (OGRLayerH, long)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch a feature by its identifier.  <a href="#a7c628dce8939904154b50365306b06f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a5b380520d0999422987f06b6e31b9b00">OGR_L_SetFeature</a> (OGRLayerH, OGRFeatureH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rewrite an existing feature.  <a href="#a5b380520d0999422987f06b6e31b9b00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a301d319111285a47fe6cda6e079214f8">OGR_L_CreateFeature</a> (OGRLayerH, OGRFeatureH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create and write a new feature within a layer.  <a href="#a301d319111285a47fe6cda6e079214f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a3525cc8e47db48f8968605d3f2d9a41a">OGR_L_DeleteFeature</a> (OGRLayerH, long)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete feature from layer.  <a href="#a3525cc8e47db48f8968605d3f2d9a41a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRFeatureDefnH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a7b67ea4ab5892c6720460dc7f66eca2d">OGR_L_GetLayerDefn</a> (OGRLayerH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the schema information for this layer.  <a href="#a7b67ea4ab5892c6720460dc7f66eca2d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRSpatialReferenceH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a8b2a10085f410aa84172eba413408c39">OGR_L_GetSpatialRef</a> (OGRLayerH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the spatial reference system for this layer.  <a href="#a8b2a10085f410aa84172eba413408c39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#affc3cef62be82ec4f811a89b1855cbd5">OGR_L_FindFieldIndex</a> (OGRLayerH, const char *, int bExactMatch)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the index of field in a layer.  <a href="#affc3cef62be82ec4f811a89b1855cbd5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#abfbba8f45edd5dc44ced91f9228f9124">OGR_L_GetFeatureCount</a> (OGRLayerH, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the feature count in this layer.  <a href="#abfbba8f45edd5dc44ced91f9228f9124"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aa6c495581900c8301dff91d8cd3ee12f">OGR_L_GetExtent</a> (OGRLayerH, <a class="el" href="classOGREnvelope.html">OGREnvelope</a> *, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the extent of this layer.  <a href="#aa6c495581900c8301dff91d8cd3ee12f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac3dbfd4443c80dca0d93574f0c00d376">OGR_L_GetExtentEx</a> (OGRLayerH, int iGeomField, <a class="el" href="classOGREnvelope.html">OGREnvelope</a> *psExtent, int bForce)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the extent of this layer, on the specified geometry field.  <a href="#ac3dbfd4443c80dca0d93574f0c00d376"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a480adc8b839b04597f49583371d366fd">OGR_L_TestCapability</a> (OGRLayerH, const char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this layer supported the named capability.  <a href="#a480adc8b839b04597f49583371d366fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aab585ef1166c61c4819f7fd46ee4a275">OGR_L_CreateField</a> (OGRLayerH, OGRFieldDefnH, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new field on a layer.  <a href="#aab585ef1166c61c4819f7fd46ee4a275"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#af6908931c4f3ad364fef8d6e831363bc">OGR_L_CreateGeomField</a> (OGRLayerH hLayer, OGRGeomFieldDefnH hFieldDefn, int bForce)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new geometry field on a layer.  <a href="#af6908931c4f3ad364fef8d6e831363bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#afc861413683418eba5d31e487da2f9e2">OGR_L_DeleteField</a> (OGRLayerH, int iField)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new field on a layer.  <a href="#afc861413683418eba5d31e487da2f9e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4cc576cb39e1dd4a1f074125199245bb">OGR_L_ReorderFields</a> (OGRLayerH, int *panMap)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reorder all the fields of a layer.  <a href="#a4cc576cb39e1dd4a1f074125199245bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad20a3796ee63935285976ee425878927">OGR_L_ReorderField</a> (OGRLayerH, int iOldFieldPos, int iNewFieldPos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reorder an existing field on a layer.  <a href="#ad20a3796ee63935285976ee425878927"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a679904d97c1084f309706ac3c6228cec">OGR_L_AlterFieldDefn</a> (OGRLayerH, int iField, OGRFieldDefnH hNewFieldDefn, int nFlags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Alter the definition of an existing field on a layer.  <a href="#a679904d97c1084f309706ac3c6228cec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a8180ea56ca7f677eb5da05c8cfcb77be">OGR_L_StartTransaction</a> (OGRLayerH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For datasources which support transactions, StartTransaction creates a transaction.  <a href="#a8180ea56ca7f677eb5da05c8cfcb77be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6135ef3b16c3cc974682365783603cc6">OGR_L_CommitTransaction</a> (OGRLayerH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For datasources which support transactions, CommitTransaction commits a transaction.  <a href="#a6135ef3b16c3cc974682365783603cc6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a823a6c351dccf751777f67801dd7f9c5">OGR_L_RollbackTransaction</a> (OGRLayerH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For datasources which support transactions, RollbackTransaction will roll back a datasource to its state before the start of the current transaction. If no transaction is active, or the rollback fails, will return OGRERR_FAILURE. Datasources which do not support transactions will always return OGRERR_NONE.  <a href="#a823a6c351dccf751777f67801dd7f9c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9d845a6cf6652756925530418905471a">OGR_L_SyncToDisk</a> (OGRLayerH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flush pending changes to disk.  <a href="#a9d845a6cf6652756925530418905471a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#abfeb6e1258f113c6c45c8d6a43c8cfa5">OGR_L_GetFIDColumn</a> (OGRLayerH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method returns the name of the underlying database column being used as the FID column, or "" if not supported.  <a href="#abfeb6e1258f113c6c45c8d6a43c8cfa5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ab060e07e277cebd1d8504c449d97b29f">OGR_L_GetGeometryColumn</a> (OGRLayerH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method returns the name of the underlying database column being used as the geometry column, or "" if not supported.  <a href="#ab060e07e277cebd1d8504c449d97b29f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6d43f1474201356bed2e6f92e7d37154">OGR_L_SetIgnoredFields</a> (OGRLayerH, const char **)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set which fields can be omitted when retrieving features from the layer.  <a href="#a6d43f1474201356bed2e6f92e7d37154"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a5c353cc32c9dd02967a7bed1450d2524">OGR_L_Intersection</a> (OGRLayerH, OGRLayerH, OGRLayerH, char **, GDALProgressFunc, void *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Intersection of two layers.  <a href="#a5c353cc32c9dd02967a7bed1450d2524"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac8edb8696c2b046370e29efdd73787f7">OGR_L_Union</a> (OGRLayerH, OGRLayerH, OGRLayerH, char **, GDALProgressFunc, void *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Union of two layers.  <a href="#ac8edb8696c2b046370e29efdd73787f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a03249311ff4c88b2fac5f728be63b549">OGR_L_SymDifference</a> (OGRLayerH, OGRLayerH, OGRLayerH, char **, GDALProgressFunc, void *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Symmetrical difference of two layers.  <a href="#a03249311ff4c88b2fac5f728be63b549"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a67948074f2e2942cebdd0f90bbec8aa9">OGR_L_Identity</a> (OGRLayerH, OGRLayerH, OGRLayerH, char **, GDALProgressFunc, void *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Identify the features of this layer with the ones from the identity layer.  <a href="#a67948074f2e2942cebdd0f90bbec8aa9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a87b478c971619145dee7d8d8deeac702">OGR_L_Update</a> (OGRLayerH, OGRLayerH, OGRLayerH, char **, GDALProgressFunc, void *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update this layer with features from the update layer.  <a href="#a87b478c971619145dee7d8d8deeac702"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ae12dcd5dc6dc5f930218573658f1b5c2">OGR_L_Clip</a> (OGRLayerH, OGRLayerH, OGRLayerH, char **, GDALProgressFunc, void *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clip off areas that are not covered by the method layer.  <a href="#ae12dcd5dc6dc5f930218573658f1b5c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a0f8c47bbeae70e609f4e51a239784285">OGR_L_Erase</a> (OGRLayerH, OGRLayerH, OGRLayerH, char **, GDALProgressFunc, void *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove areas that are covered by the method layer.  <a href="#a0f8c47bbeae70e609f4e51a239784285"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4823e7c3513cd9d57254364de9a1d021">OGR_DS_Destroy</a> (OGRDataSourceH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Closes opened datasource and releases allocated resources.  <a href="#a4823e7c3513cd9d57254364de9a1d021"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aea8cc826474b55371b1b4e24a24ba1db">OGR_DS_GetName</a> (OGRDataSourceH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the name of the data source.  <a href="#aea8cc826474b55371b1b4e24a24ba1db"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac6da541cb655ab631df729e71da2e762">OGR_DS_GetLayerCount</a> (OGRDataSourceH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of layers in this data source.  <a href="#ac6da541cb655ab631df729e71da2e762"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRLayerH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a03998029f904d1c3b12de40114e7503e">OGR_DS_GetLayer</a> (OGRDataSourceH, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch a layer by index.  <a href="#a03998029f904d1c3b12de40114e7503e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRLayerH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a74af4912b67bf2a7b6e3230711a40d0e">OGR_DS_GetLayerByName</a> (OGRDataSourceH, const char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch a layer by name.  <a href="#a74af4912b67bf2a7b6e3230711a40d0e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a85827a79cd2ddb5a55126e785bee427d">OGR_DS_DeleteLayer</a> (OGRDataSourceH, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete the indicated layer from the datasource.  <a href="#a85827a79cd2ddb5a55126e785bee427d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRSFDriverH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a5def9c0aa6f6f60ab96369203330e326">OGR_DS_GetDriver</a> (OGRDataSourceH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the driver that the dataset was opened with.  <a href="#a5def9c0aa6f6f60ab96369203330e326"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRLayerH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a424d383a37fbeaea58acaea11717f320">OGR_DS_CreateLayer</a> (OGRDataSourceH, const char *, OGRSpatialReferenceH, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>, char **)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function attempts to create a new layer on the data source with the indicated name, coordinate system, geometry type.  <a href="#a424d383a37fbeaea58acaea11717f320"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRLayerH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a628d34530517b618696c97b73de31df7">OGR_DS_CopyLayer</a> (OGRDataSourceH, OGRLayerH, const char *, char **)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Duplicate an existing layer.  <a href="#a628d34530517b618696c97b73de31df7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad0fefab726442fa71ab5ef74fe8549a6">OGR_DS_TestCapability</a> (OGRDataSourceH, const char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if capability is available.  <a href="#ad0fefab726442fa71ab5ef74fe8549a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRLayerH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9892ecb0bf61add295bd9decdb13797a">OGR_DS_ExecuteSQL</a> (OGRDataSourceH, const char *, OGRGeometryH, const char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute an SQL statement against the data store.  <a href="#a9892ecb0bf61add295bd9decdb13797a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#afc7b521a05c1207e298a2b9dbf4a1181">OGR_DS_ReleaseResultSet</a> (OGRDataSourceH, OGRLayerH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release results of <a class="el" href="ogr__api_8h.html#a9892ecb0bf61add295bd9decdb13797a" title="Execute an SQL statement against the data store.">OGR_DS_ExecuteSQL()</a>.  <a href="#afc7b521a05c1207e298a2b9dbf4a1181"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a139ab189c06d9f5f26e21b134928f882">OGR_DS_SyncToDisk</a> (OGRDataSourceH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flush pending changes to disk.  <a href="#a139ab189c06d9f5f26e21b134928f882"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#afd11ea603491207a89c75b6b9480e091">OGR_Dr_GetName</a> (OGRSFDriverH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch name of driver (file format). This name should be relatively short (10-40 characters), and should reflect the underlying file format. For instance "ESRI Shapefile".  <a href="#afd11ea603491207a89c75b6b9480e091"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRDataSourceH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a464b2210400d91fb9c6fa76595ea3681">OGR_Dr_Open</a> (OGRSFDriverH, const char *, int) CPL_WARN_UNUSED_RESULT</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to open file with this driver.  <a href="#a464b2210400d91fb9c6fa76595ea3681"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9010219bbc2e32627064ed860048d979">OGR_Dr_TestCapability</a> (OGRSFDriverH, const char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if capability is available.  <a href="#a9010219bbc2e32627064ed860048d979"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRDataSourceH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac2b628f8ddc674f72c798829c738bbdd">OGR_Dr_CreateDataSource</a> (OGRSFDriverH, const char *, char **) CPL_WARN_UNUSED_RESULT</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function attempts to create a new data source based on the passed driver.  <a href="#ac2b628f8ddc674f72c798829c738bbdd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRDataSourceH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ae94a7a1c0cb226c7ce04e0380a12a44e">OGR_Dr_CopyDataSource</a> (OGRSFDriverH, OGRDataSourceH, const char *, char **) CPL_WARN_UNUSED_RESULT</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function creates a new datasource by copying all the layers from the source datasource.  <a href="#ae94a7a1c0cb226c7ce04e0380a12a44e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4d2314e22acd846e7e31ff5a5c5ec27f">OGR_Dr_DeleteDataSource</a> (OGRSFDriverH, const char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a datasource.  <a href="#a4d2314e22acd846e7e31ff5a5c5ec27f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRDataSourceH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a2da3630231780d519543d1679c83e62f">OGROpen</a> (const char *, int, OGRSFDriverH *) CPL_WARN_UNUSED_RESULT</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a file / data source with one of the registered drivers.  <a href="#a2da3630231780d519543d1679c83e62f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad3abed0c3b232fe55a580726536fe6fa">OGRReleaseDataSource</a> (OGRDataSourceH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Drop a reference to this datasource, and if the reference count drops to zero close (destroy) the datasource.  <a href="#ad3abed0c3b232fe55a580726536fe6fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a7ace3e4b97b55b999e16557a75bf7226">OGRRegisterDriver</a> (OGRSFDriverH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a driver to the list of registered drivers.  <a href="#a7ace3e4b97b55b999e16557a75bf7226"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a18492d049ef3b65be20c12f5ad7e29a2">OGRDeregisterDriver</a> (OGRSFDriverH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the passed driver from the list of registered drivers.  <a href="#a18492d049ef3b65be20c12f5ad7e29a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad0f6d2bbd269b56a61d1c1841dac2575">OGRGetDriverCount</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the number of registered drivers.  <a href="#ad0f6d2bbd269b56a61d1c1841dac2575"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRSFDriverH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a3f8080605cad5aeef9519c38fe160b51">OGRGetDriver</a> (int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the indicated driver.  <a href="#a3f8080605cad5aeef9519c38fe160b51"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRSFDriverH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ae814db7e2212b9bbb0fd8c361bee11fe">OGRGetDriverByName</a> (const char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the indicated driver.  <a href="#ae814db7e2212b9bbb0fd8c361bee11fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a342fa7b65116145ed01f7e5888abb603">OGRGetOpenDSCount</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of opened datasources.  <a href="#a342fa7b65116145ed01f7e5888abb603"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRDataSourceH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a273626bc189e1734984afa66b5f76918">OGRGetOpenDS</a> (int iDS)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the iDS th datasource opened.  <a href="#a273626bc189e1734984afa66b5f76918"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae904632d0bc86ba5501921ca594e18da"></a><!-- doxytag: member="ogr_api.h::OGRRegisterAll" ref="ae904632d0bc86ba5501921ca594e18da" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ae904632d0bc86ba5501921ca594e18da">OGRRegisterAll</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register all drivers. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ae5d5a052ed1046ec85236fe4a92733e2">OGRCleanupAll</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cleanup all OGR related resources.  <a href="#ae5d5a052ed1046ec85236fe4a92733e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRStyleMgrH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aba4d31b48c3c9ea6c1edbe4f0aa65866">OGR_SM_Create</a> (OGRStyleTableH hStyleTable) CPL_WARN_UNUSED_RESULT</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classOGRStyleMgr.html">OGRStyleMgr</a> factory.  <a href="#aba4d31b48c3c9ea6c1edbe4f0aa65866"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a474fca7d9327da916305ec1276a57443">OGR_SM_Destroy</a> (OGRStyleMgrH hSM)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy Style Manager.  <a href="#a474fca7d9327da916305ec1276a57443"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#afca737ee6586ce8078b52108707b0b6a">OGR_SM_InitFromFeature</a> (OGRStyleMgrH hSM, OGRFeatureH hFeat)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize style manager from the style string of a feature.  <a href="#afca737ee6586ce8078b52108707b0b6a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ade49bffec1e796ddf4419f5cbe34fda8">OGR_SM_InitStyleString</a> (OGRStyleMgrH hSM, const char *pszStyleString)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize style manager from the style string.  <a href="#ade49bffec1e796ddf4419f5cbe34fda8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad272704a535c0fa8cfd7b097eb4968dc">OGR_SM_GetPartCount</a> (OGRStyleMgrH hSM, const char *pszStyleString)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of parts in a style.  <a href="#ad272704a535c0fa8cfd7b097eb4968dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRStyleToolH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a61d4e04abb6e3c59ed570c62dffc4164">OGR_SM_GetPart</a> (OGRStyleMgrH hSM, int nPartId, const char *pszStyleString)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch a part (style tool) from the current style.  <a href="#a61d4e04abb6e3c59ed570c62dffc4164"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#af358ec087124f355fca02bf33a1e0027">OGR_SM_AddPart</a> (OGRStyleMgrH hSM, OGRStyleToolH hST)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a part (style tool) to the current style.  <a href="#af358ec087124f355fca02bf33a1e0027"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a358c1558e61951b2e1e338ead8401ad8">OGR_SM_AddStyle</a> (OGRStyleMgrH hSM, const char *pszStyleName, const char *pszStyleString)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a style to the current style table.  <a href="#a358c1558e61951b2e1e338ead8401ad8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRStyleToolH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4cc7bc2b21febd7a78d44727ad7de30f">OGR_ST_Create</a> (<a class="el" href="ogr__core_8h.html#a109ea92417a0152008c7c11eeec4f028">OGRSTClassId</a> eClassId) CPL_WARN_UNUSED_RESULT</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classOGRStyleTool.html">OGRStyleTool</a> factory.  <a href="#a4cc7bc2b21febd7a78d44727ad7de30f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a5d1ecf398ee062f3f5a297f70244497a">OGR_ST_Destroy</a> (OGRStyleToolH hST)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy Style Tool.  <a href="#a5d1ecf398ee062f3f5a297f70244497a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#a109ea92417a0152008c7c11eeec4f028">OGRSTClassId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aae8d0ee36b82c9d1d8d1a0e9b36f2d35">OGR_ST_GetType</a> (OGRStyleToolH hST)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine type of Style Tool.  <a href="#aae8d0ee36b82c9d1d8d1a0e9b36f2d35"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#af945b904942ebc25abc8f685bb6b20e1">OGRSTUnitId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#afb52e40f289848d1f228849b6dae2463">OGR_ST_GetUnit</a> (OGRStyleToolH hST)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get Style Tool units.  <a href="#afb52e40f289848d1f228849b6dae2463"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac9c5b94e6ca32cd53c6a7a9ebc73012c">OGR_ST_SetUnit</a> (OGRStyleToolH hST, <a class="el" href="ogr__core_8h.html#af945b904942ebc25abc8f685bb6b20e1">OGRSTUnitId</a> eUnit, double dfGroundPaperScale)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set Style Tool units.  <a href="#ac9c5b94e6ca32cd53c6a7a9ebc73012c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aecadf5738c3b96093605b352a95869f1">OGR_ST_GetParamStr</a> (OGRStyleToolH hST, int eParam, int *bValueIsNull)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get Style Tool parameter value as string.  <a href="#aecadf5738c3b96093605b352a95869f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad4168832561881cb75dcc7c35935cdd3">OGR_ST_GetParamNum</a> (OGRStyleToolH hST, int eParam, int *bValueIsNull)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get Style Tool parameter value as an integer.  <a href="#ad4168832561881cb75dcc7c35935cdd3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a96082cdf432271acfa3b3777c3be853b">OGR_ST_GetParamDbl</a> (OGRStyleToolH hST, int eParam, int *bValueIsNull)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get Style Tool parameter value as a double.  <a href="#a96082cdf432271acfa3b3777c3be853b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a88e9561d9a62d6f8368d526eb0468b3a">OGR_ST_SetParamStr</a> (OGRStyleToolH hST, int eParam, const char *pszValue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set Style Tool parameter value from a string.  <a href="#a88e9561d9a62d6f8368d526eb0468b3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac0397850aed3282865b444d65d2deb0e">OGR_ST_SetParamNum</a> (OGRStyleToolH hST, int eParam, int nValue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set Style Tool parameter value from an integer.  <a href="#ac0397850aed3282865b444d65d2deb0e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a764f52f8a72e950d0a5d84b7a7b37fc8">OGR_ST_SetParamDbl</a> (OGRStyleToolH hST, int eParam, double dfValue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set Style Tool parameter value from a double.  <a href="#a764f52f8a72e950d0a5d84b7a7b37fc8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4089c70ce3b1cbea0e45c3375d5093f0">OGR_ST_GetStyleString</a> (OGRStyleToolH hST)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the style string for this Style Tool.  <a href="#a4089c70ce3b1cbea0e45c3375d5093f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a906f5e2b901413a0ab5fa35d649847fc">OGR_ST_GetRGBFromString</a> (OGRStyleToolH hST, const char *pszColor, int *pnRed, int *pnGreen, int *pnBlue, int *pnAlpha)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the r,g,b,a components of a color encoded in #RRGGBB[AA] format.  <a href="#a906f5e2b901413a0ab5fa35d649847fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OGRStyleTableH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9c2d216b17d9f09ad6285ce61dcbe826">OGR_STBL_Create</a> (void) CPL_WARN_UNUSED_RESULT</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classOGRStyleTable.html">OGRStyleTable</a> factory.  <a href="#a9c2d216b17d9f09ad6285ce61dcbe826"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a5cf4e22eb7ef07c4a3249c21dce48764">OGR_STBL_Destroy</a> (OGRStyleTableH hSTBL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy Style Table.  <a href="#a5cf4e22eb7ef07c4a3249c21dce48764"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aacd2a4f109627f282c42229eaad7cdfd">OGR_STBL_AddStyle</a> (OGRStyleTableH hStyleTable, const char *pszName, const char *pszStyleString)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new style in the table. No comparison will be done on the Style string, only on the name. This function is the same as the C++ method <a class="el" href="classOGRStyleTable.html#aff722d3fc7c167259dd79986a2574993" title="Add a new style in the table. No comparison will be done on the Style string, only on the name...">OGRStyleTable::AddStyle()</a>.  <a href="#aacd2a4f109627f282c42229eaad7cdfd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aa3e3aca0d4f3fefe3dd64da65814dda7">OGR_STBL_SaveStyleTable</a> (OGRStyleTableH hStyleTable, const char *pszFilename)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a style table to a file.  <a href="#aa3e3aca0d4f3fefe3dd64da65814dda7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aed731a5a6fbedde73ed5063d62f3004e">OGR_STBL_LoadStyleTable</a> (OGRStyleTableH hStyleTable, const char *pszFilename)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a style table from a file.  <a href="#aed731a5a6fbedde73ed5063d62f3004e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a57ca305147b3b5a6c3f5fafaee7bc06a">OGR_STBL_Find</a> (OGRStyleTableH hStyleTable, const char *pszName)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a style string by name.  <a href="#a57ca305147b3b5a6c3f5fafaee7bc06a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a69ccd53d6d374d66d42266b3543509f7">OGR_STBL_ResetStyleStringReading</a> (OGRStyleTableH hStyleTable)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset the next style pointer to 0.  <a href="#a69ccd53d6d374d66d42266b3543509f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad901a29f17b139108cc6390b9a075e89">OGR_STBL_GetNextStyle</a> (OGRStyleTableH hStyleTable)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the next style string from the table.  <a href="#ad901a29f17b139108cc6390b9a075e89"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#af8214328c6866f0eb85bba376d94a05e">OGR_STBL_GetLastStyleName</a> (OGRStyleTableH hStyleTable)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>C API and defines for <a class="el" href="classOGRFeature.html">OGRFeature</a>, <a class="el" href="classOGRGeometry.html">OGRGeometry</a>, and <a class="el" href="classOGRDataSource.html">OGRDataSource</a> related classes.</p>
<p>See also: <a class="el" href="ogr__geometry_8h.html">ogr_geometry.h</a>, <a class="el" href="ogr__feature_8h.html">ogr_feature.h</a>, <a class="el" href="ogrsf__frmts_8h.html">ogrsf_frmts.h</a>, <a class="el" href="ogr__featurestyle_8h.html">ogr_featurestyle.h</a> </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ae94a7a1c0cb226c7ce04e0380a12a44e"></a><!-- doxytag: member="ogr_api.h::OGR_Dr_CopyDataSource" ref="ae94a7a1c0cb226c7ce04e0380a12a44e" args="(OGRSFDriverH, OGRDataSourceH, const char *, char **) CPL_WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRDataSourceH OGR_Dr_CopyDataSource </td>
          <td>(</td>
          <td class="paramtype">OGRSFDriverH&nbsp;</td>
          <td class="paramname"> <em>hDriver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRDataSourceH&nbsp;</td>
          <td class="paramname"> <em>hSrcDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszNewName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszOptions</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function creates a new datasource by copying all the layers from the source datasource. </p>
<p>It is important to call <a class="el" href="ogr__api_8h.html#a4823e7c3513cd9d57254364de9a1d021" title="Closes opened datasource and releases allocated resources.">OGR_DS_Destroy()</a> when the datasource is no longer used to ensure that all data has been properly flushed to disk.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRSFDriver.html#a0b1f2c7944603bebac2dab96d1fee7c5" title="This method creates a new datasource by copying all the layers from the source datasource.">OGRSFDriver::CopyDataSource()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDriver</em>&nbsp;</td><td>handle to the driver on which data source creation is based. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hSrcDS</em>&nbsp;</td><td>source datasource </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszNewName</em>&nbsp;</td><td>the name for the new data source. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>papszOptions</em>&nbsp;</td><td>a StringList of name=value options. Options are driver specific, and driver information can be found at the following url: <a href="http://www.gdal.org/ogr/ogr_formats.html">http://www.gdal.org/ogr/ogr_formats.html</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NULL is returned on failure, or a new <a class="el" href="classOGRDataSource.html">OGRDataSource</a> handle on success. </dd></dl>

<p>References <a class="el" href="classOGRDataSource.html#ad269574d5e2f63c5b76e001df4a98ffb">OGRDataSource::GetDriver()</a>, <a class="el" href="ogr__api_8h.html#ae94a7a1c0cb226c7ce04e0380a12a44e">OGR_Dr_CopyDataSource()</a>, and <a class="el" href="classOGRDataSource.html#ada74eb42fd282aa285e9e527a5caeaed">OGRDataSource::SetDriver()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ae94a7a1c0cb226c7ce04e0380a12a44e">OGR_Dr_CopyDataSource()</a>.</p>

</div>
</div>
<a class="anchor" id="ac2b628f8ddc674f72c798829c738bbdd"></a><!-- doxytag: member="ogr_api.h::OGR_Dr_CreateDataSource" ref="ac2b628f8ddc674f72c798829c738bbdd" args="(OGRSFDriverH, const char *, char **) CPL_WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRDataSourceH OGR_Dr_CreateDataSource </td>
          <td>(</td>
          <td class="paramtype">OGRSFDriverH&nbsp;</td>
          <td class="paramname"> <em>hDriver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszOptions</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function attempts to create a new data source based on the passed driver. </p>
<p>The papszOptions argument can be used to control driver specific creation options. These options are normally documented in the format specific documentation.</p>
<p>It is important to call <a class="el" href="ogr__api_8h.html#a4823e7c3513cd9d57254364de9a1d021" title="Closes opened datasource and releases allocated resources.">OGR_DS_Destroy()</a> when the datasource is no longer used to ensure that all data has been properly flushed to disk.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRSFDriver.html#a4339101b2d0851e788b6bcfd248780f6" title="This method attempts to create a new data source based on the passed driver.">OGRSFDriver::CreateDataSource()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDriver</em>&nbsp;</td><td>handle to the driver on which data source creation is based. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszName</em>&nbsp;</td><td>the name for the new data source. UTF-8 encoded. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>papszOptions</em>&nbsp;</td><td>a StringList of name=value options. Options are driver specific, and driver information can be found at the following url: <a href="http://www.gdal.org/ogr/ogr_formats.html">http://www.gdal.org/ogr/ogr_formats.html</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NULL is returned on failure, or a new <a class="el" href="classOGRDataSource.html">OGRDataSource</a> handle on success. </dd></dl>

<p>References <a class="el" href="classOGRSFDriver.html#a4339101b2d0851e788b6bcfd248780f6">OGRSFDriver::CreateDataSource()</a>, <a class="el" href="classOGRDataSource.html#ad269574d5e2f63c5b76e001df4a98ffb">OGRDataSource::GetDriver()</a>, <a class="el" href="ogr__api_8h.html#ac2b628f8ddc674f72c798829c738bbdd">OGR_Dr_CreateDataSource()</a>, and <a class="el" href="classOGRDataSource.html#ada74eb42fd282aa285e9e527a5caeaed">OGRDataSource::SetDriver()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ac2b628f8ddc674f72c798829c738bbdd">OGR_Dr_CreateDataSource()</a>.</p>

</div>
</div>
<a class="anchor" id="a4d2314e22acd846e7e31ff5a5c5ec27f"></a><!-- doxytag: member="ogr_api.h::OGR_Dr_DeleteDataSource" ref="a4d2314e22acd846e7e31ff5a5c5ec27f" args="(OGRSFDriverH, const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_Dr_DeleteDataSource </td>
          <td>(</td>
          <td class="paramtype">OGRSFDriverH&nbsp;</td>
          <td class="paramname"> <em>hDriver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszDataSource</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete a datasource. </p>
<p>Delete (from the disk, in the database, ...) the named datasource. Normally it would be safest if the datasource was not open at the time.</p>
<p>Whether this is a supported operation on this driver case be tested using TestCapability() on ODrCDeleteDataSource.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRSFDriver.html#ad8d0872f7fe97e82a05dfbacc2c82be3" title="Delete a datasource.">OGRSFDriver::DeleteDataSource()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDriver</em>&nbsp;</td><td>handle to the driver on which data source deletion is based.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszDataSource</em>&nbsp;</td><td>the name of the datasource to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE on success, and OGRERR_UNSUPPORTED_OPERATION if this is not supported by this driver. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a4d2314e22acd846e7e31ff5a5c5ec27f">OGR_Dr_DeleteDataSource()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a4d2314e22acd846e7e31ff5a5c5ec27f">OGR_Dr_DeleteDataSource()</a>.</p>

</div>
</div>
<a class="anchor" id="afd11ea603491207a89c75b6b9480e091"></a><!-- doxytag: member="ogr_api.h::OGR_Dr_GetName" ref="afd11ea603491207a89c75b6b9480e091" args="(OGRSFDriverH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * OGR_Dr_GetName </td>
          <td>(</td>
          <td class="paramtype">OGRSFDriverH&nbsp;</td>
          <td class="paramname"> <em>hDriver</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch name of driver (file format). This name should be relatively short (10-40 characters), and should reflect the underlying file format. For instance "ESRI Shapefile". </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRSFDriver.html#a0e7f90e5c390bccc9e708b75235a2735" title="Fetch name of driver (file format). This name should be relatively short (10-40 characters), and should reflect the underlying file format. For instance &quot;ESRI Shapefile&quot;.">OGRSFDriver::GetName()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDriver</em>&nbsp;</td><td>handle to the the driver to get the name from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>driver name. This is an internal string and should not be modified or freed. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#afd11ea603491207a89c75b6b9480e091">OGR_Dr_GetName()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#afd11ea603491207a89c75b6b9480e091">OGR_Dr_GetName()</a>.</p>

</div>
</div>
<a class="anchor" id="a464b2210400d91fb9c6fa76595ea3681"></a><!-- doxytag: member="ogr_api.h::OGR_Dr_Open" ref="a464b2210400d91fb9c6fa76595ea3681" args="(OGRSFDriverH, const char *, int) CPL_WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRDataSourceH OGR_Dr_Open </td>
          <td>(</td>
          <td class="paramtype">OGRSFDriverH&nbsp;</td>
          <td class="paramname"> <em>hDriver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bUpdate</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attempt to open file with this driver. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRSFDriver.html#aee265c3b0a3d4fa3572020d255bb4564" title="Attempt to open file with this driver.">OGRSFDriver::Open()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDriver</em>&nbsp;</td><td>handle to the driver that is used to open file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszName</em>&nbsp;</td><td>the name of the file, or data source to try and open. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bUpdate</em>&nbsp;</td><td>TRUE if update access is required, otherwise FALSE (the default).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NULL on error or if the pass name is not supported by this driver, otherwise an handle to an <a class="el" href="classOGRDataSource.html">OGRDataSource</a>. This <a class="el" href="classOGRDataSource.html">OGRDataSource</a> should be closed by deleting the object when it is no longer needed. </dd></dl>

<p>References <a class="el" href="classOGRDataSource.html#ad269574d5e2f63c5b76e001df4a98ffb">OGRDataSource::GetDriver()</a>, <a class="el" href="ogr__api_8h.html#a464b2210400d91fb9c6fa76595ea3681">OGR_Dr_Open()</a>, and <a class="el" href="classOGRDataSource.html#ada74eb42fd282aa285e9e527a5caeaed">OGRDataSource::SetDriver()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a464b2210400d91fb9c6fa76595ea3681">OGR_Dr_Open()</a>.</p>

</div>
</div>
<a class="anchor" id="a9010219bbc2e32627064ed860048d979"></a><!-- doxytag: member="ogr_api.h::OGR_Dr_TestCapability" ref="a9010219bbc2e32627064ed860048d979" args="(OGRSFDriverH, const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_Dr_TestCapability </td>
          <td>(</td>
          <td class="paramtype">OGRSFDriverH&nbsp;</td>
          <td class="paramname"> <em>hDriver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszCap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if capability is available. </p>
<p>One of the following data source capability names can be passed into this function, and a TRUE or FALSE value will be returned indicating whether or not the capability is available for this object.</p>
<ul>
<li>
<p class="startli"><b>ODrCCreateDataSource</b>: True if this driver can support creating data sources.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>ODrCDeleteDataSource</b>: True if this driver supports deleting data sources.</p>
<p class="endli"></p>
</li>
</ul>
<p>The #define macro forms of the capability names should be used in preference to the strings themselves to avoid mispelling.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRSFDriver.html#a6c37cb7552902cd27cd6d4b904d7c744" title="Test if capability is available.">OGRSFDriver::TestCapability()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDriver</em>&nbsp;</td><td>handle to the driver to test the capability against. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszCap</em>&nbsp;</td><td>the capability to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if capability available otherwise FALSE. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a9010219bbc2e32627064ed860048d979">OGR_Dr_TestCapability()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a9010219bbc2e32627064ed860048d979">OGR_Dr_TestCapability()</a>.</p>

</div>
</div>
<a class="anchor" id="a628d34530517b618696c97b73de31df7"></a><!-- doxytag: member="ogr_api.h::OGR_DS_CopyLayer" ref="a628d34530517b618696c97b73de31df7" args="(OGRDataSourceH, OGRLayerH, const char *, char **)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRLayerH OGR_DS_CopyLayer </td>
          <td>(</td>
          <td class="paramtype">OGRDataSourceH&nbsp;</td>
          <td class="paramname"> <em>hDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>hSrcLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszNewName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszOptions</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Duplicate an existing layer. </p>
<p>This function creates a new layer, duplicate the field definitions of the source layer and then duplicate each features of the source layer. The papszOptions argument can be used to control driver specific creation options. These options are normally documented in the format specific documentation. The source layer may come from another dataset.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRDataSource.html#a42dc7f7f538cd4f083af350722fe53ae" title="Duplicate an existing layer.">OGRDataSource::CopyLayer</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDS</em>&nbsp;</td><td>handle to the data source where to create the new layer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hSrcLayer</em>&nbsp;</td><td>handle to the source layer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszNewName</em>&nbsp;</td><td>the name of the layer to create. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>papszOptions</em>&nbsp;</td><td>a StringList of name=value options. Options are driver specific.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an handle to the layer, or NULL if an error occurs. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a628d34530517b618696c97b73de31df7">OGR_DS_CopyLayer()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a628d34530517b618696c97b73de31df7">OGR_DS_CopyLayer()</a>.</p>

</div>
</div>
<a class="anchor" id="a424d383a37fbeaea58acaea11717f320"></a><!-- doxytag: member="ogr_api.h::OGR_DS_CreateLayer" ref="a424d383a37fbeaea58acaea11717f320" args="(OGRDataSourceH, const char *, OGRSpatialReferenceH, OGRwkbGeometryType, char **)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRLayerH OGR_DS_CreateLayer </td>
          <td>(</td>
          <td class="paramtype">OGRDataSourceH&nbsp;</td>
          <td class="paramname"> <em>hDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRSpatialReferenceH&nbsp;</td>
          <td class="paramname"> <em>hSpatialRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&nbsp;</td>
          <td class="paramname"> <em>eType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszOptions</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function attempts to create a new layer on the data source with the indicated name, coordinate system, geometry type. </p>
<p>The papszOptions argument can be used to control driver specific creation options. These options are normally documented in the format specific documentation.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRDataSource.html#a39cfc6e0ee790506d7638b0dce03c7da" title="This method attempts to create a new layer on the data source with the indicated name, coordinate system, geometry type.">OGRDataSource::CreateLayer()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDS</em>&nbsp;</td><td>The dataset handle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszName</em>&nbsp;</td><td>the name for the new layer. This should ideally not match any existing layer on the datasource. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hSpatialRef</em>&nbsp;</td><td>handle to the coordinate system to use for the new layer, or NULL if no coordinate system is available. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eType</em>&nbsp;</td><td>the geometry type for the layer. Use wkbUnknown if there are no constraints on the types geometry to be written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>papszOptions</em>&nbsp;</td><td>a StringList of name=value options. Options are driver specific, and driver information can be found at the following url: <a href="http://www.gdal.org/ogr/ogr_formats.html">http://www.gdal.org/ogr/ogr_formats.html</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NULL is returned on failure, or a new <a class="el" href="classOGRLayer.html">OGRLayer</a> handle on success.</dd></dl>
<p><b>Example:</b></p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &quot;<a class="code" href="ogrsf__frmts_8h.html">ogrsf_frmts.h</a>&quot;</span> 
<span class="preprocessor">#include &quot;<a class="code" href="cpl__string_8h.html">cpl_string.h</a>&quot;</span>

...

        OGRLayerH *hLayer;
        <span class="keywordtype">char</span>     **papszOptions;

        <span class="keywordflow">if</span>( <a class="code" href="ogr__api_8h.html#ad0fefab726442fa71ab5ef74fe8549a6" title="Test if capability is available.">OGR_DS_TestCapability</a>( hDS, ODsCCreateLayer ) )
        {
            ...
        }

        papszOptions = CSLSetNameValue( papszOptions, <span class="stringliteral">&quot;DIM&quot;</span>, <span class="stringliteral">&quot;2&quot;</span> );
        hLayer = <a class="code" href="ogr__api_8h.html#a424d383a37fbeaea58acaea11717f320" title="This function attempts to create a new layer on the data source with the indicated name...">OGR_DS_CreateLayer</a>( hDS, <span class="stringliteral">&quot;NewLayer&quot;</span>, NULL, <a class="code" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa3645f782f9b9f7632d7e7cdd0451d58f">wkbUnknown</a>,
                                     papszOptions );
        CSLDestroy( papszOptions );

        <span class="keywordflow">if</span>( hLayer == NULL )
        {
            ...
        }        
</pre></div> 
<p>References <a class="el" href="ogr__api_8h.html#a424d383a37fbeaea58acaea11717f320">OGR_DS_CreateLayer()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a424d383a37fbeaea58acaea11717f320">OGR_DS_CreateLayer()</a>.</p>

</div>
</div>
<a class="anchor" id="a85827a79cd2ddb5a55126e785bee427d"></a><!-- doxytag: member="ogr_api.h::OGR_DS_DeleteLayer" ref="a85827a79cd2ddb5a55126e785bee427d" args="(OGRDataSourceH, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_DS_DeleteLayer </td>
          <td>(</td>
          <td class="paramtype">OGRDataSourceH&nbsp;</td>
          <td class="paramname"> <em>hDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iLayer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete the indicated layer from the datasource. </p>
<p>If this method is supported the ODsCDeleteLayer capability will test TRUE on the <a class="el" href="classOGRDataSource.html">OGRDataSource</a>.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRDataSource.html#ae108ddad49607c80d3511071ffe248a5" title="Delete the indicated layer from the datasource.">OGRDataSource::DeleteLayer()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDS</em>&nbsp;</td><td>handle to the datasource </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iLayer</em>&nbsp;</td><td>the index of the layer to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE on success, or OGRERR_UNSUPPORTED_OPERATION if deleting layers is not supported for this datasource. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a85827a79cd2ddb5a55126e785bee427d">OGR_DS_DeleteLayer()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a85827a79cd2ddb5a55126e785bee427d">OGR_DS_DeleteLayer()</a>.</p>

</div>
</div>
<a class="anchor" id="a4823e7c3513cd9d57254364de9a1d021"></a><!-- doxytag: member="ogr_api.h::OGR_DS_Destroy" ref="a4823e7c3513cd9d57254364de9a1d021" args="(OGRDataSourceH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_DS_Destroy </td>
          <td>(</td>
          <td class="paramtype">OGRDataSourceH&nbsp;</td>
          <td class="paramname"> <em>hDataSource</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Closes opened datasource and releases allocated resources. </p>
<p>This method is the same as the C++ method <a class="el" href="classOGRDataSource.html#a77841576d07b24a01208e4125ccb40a5" title="Closes opened datasource and releases allocated resources.">OGRDataSource::DestroyDataSource()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDataSource</em>&nbsp;</td><td>handle to allocated datasource object. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#a4823e7c3513cd9d57254364de9a1d021">OGR_DS_Destroy()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a4823e7c3513cd9d57254364de9a1d021">OGR_DS_Destroy()</a>.</p>

</div>
</div>
<a class="anchor" id="a9892ecb0bf61add295bd9decdb13797a"></a><!-- doxytag: member="ogr_api.h::OGR_DS_ExecuteSQL" ref="a9892ecb0bf61add295bd9decdb13797a" args="(OGRDataSourceH, const char *, OGRGeometryH, const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRLayerH OGR_DS_ExecuteSQL </td>
          <td>(</td>
          <td class="paramtype">OGRDataSourceH&nbsp;</td>
          <td class="paramname"> <em>hDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszSQLCommand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hSpatialFilter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszDialect</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Execute an SQL statement against the data store. </p>
<p>The result of an SQL query is either NULL for statements that are in error, or that have no results set, or an <a class="el" href="classOGRLayer.html">OGRLayer</a> handle representing a results set from the query. Note that this <a class="el" href="classOGRLayer.html">OGRLayer</a> is in addition to the layers in the data store and must be destroyed with <a class="el" href="ogr__api_8h.html#afc7b521a05c1207e298a2b9dbf4a1181" title="Release results of OGR_DS_ExecuteSQL().">OGR_DS_ReleaseResultSet()</a> before the data source is closed (destroyed).</p>
<p>For more information on the SQL dialect supported internally by OGR review the <a href="ogr_sql.html">OGR SQL</a> document. Some drivers (ie. Oracle and PostGIS) pass the SQL directly through to the underlying RDBMS.</p>
<p>Starting with OGR 1.10, the <a href="ogr_sql_sqlite.html">SQLITE dialect</a> can also be used.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRDataSource.html#aa6acc228db6513784a56ce12334a8c33" title="Execute an SQL statement against the data store.">OGRDataSource::ExecuteSQL()</a>;</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDS</em>&nbsp;</td><td>handle to the data source on which the SQL query is executed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszSQLCommand</em>&nbsp;</td><td>the SQL statement to execute. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hSpatialFilter</em>&nbsp;</td><td>handle to a geometry which represents a spatial filter. Can be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszDialect</em>&nbsp;</td><td>allows control of the statement dialect. If set to NULL, the OGR SQL engine will be used, except for RDBMS drivers that will use their dedicated SQL engine, unless OGRSQL is explicitely passed as the dialect. Starting with OGR 1.10, the SQLITE dialect can also be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an handle to a <a class="el" href="classOGRLayer.html">OGRLayer</a> containing the results of the query. Deallocate with <a class="el" href="ogr__api_8h.html#afc7b521a05c1207e298a2b9dbf4a1181" title="Release results of OGR_DS_ExecuteSQL().">OGR_DS_ReleaseResultSet()</a>. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a9892ecb0bf61add295bd9decdb13797a">OGR_DS_ExecuteSQL()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a9892ecb0bf61add295bd9decdb13797a">OGR_DS_ExecuteSQL()</a>.</p>

</div>
</div>
<a class="anchor" id="a5def9c0aa6f6f60ab96369203330e326"></a><!-- doxytag: member="ogr_api.h::OGR_DS_GetDriver" ref="a5def9c0aa6f6f60ab96369203330e326" args="(OGRDataSourceH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRSFDriverH OGR_DS_GetDriver </td>
          <td>(</td>
          <td class="paramtype">OGRDataSourceH&nbsp;</td>
          <td class="paramname"> <em>hDS</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the driver that the dataset was opened with. </p>
<p>This method is the same as the C++ method <a class="el" href="classOGRDataSource.html#ad269574d5e2f63c5b76e001df4a98ffb" title="Returns the driver that the dataset was opened with.">OGRDataSource::GetDriver()</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDS</em>&nbsp;</td><td>handle to the datasource </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NULL if driver info is not available, or pointer to a driver owned by the OGRSFDriverManager. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a5def9c0aa6f6f60ab96369203330e326">OGR_DS_GetDriver()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a5def9c0aa6f6f60ab96369203330e326">OGR_DS_GetDriver()</a>.</p>

</div>
</div>
<a class="anchor" id="a03998029f904d1c3b12de40114e7503e"></a><!-- doxytag: member="ogr_api.h::OGR_DS_GetLayer" ref="a03998029f904d1c3b12de40114e7503e" args="(OGRDataSourceH, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRLayerH OGR_DS_GetLayer </td>
          <td>(</td>
          <td class="paramtype">OGRDataSourceH&nbsp;</td>
          <td class="paramname"> <em>hDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iLayer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch a layer by index. </p>
<p>The returned layer remains owned by the <a class="el" href="classOGRDataSource.html">OGRDataSource</a> and should not be deleted by the application.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRDataSource.html#a618c2fdb1067c9357ca2de9fa6cd5962" title="Fetch a layer by index.">OGRDataSource::GetLayer()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDS</em>&nbsp;</td><td>handle to the data source from which to get the layer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iLayer</em>&nbsp;</td><td>a layer number between 0 and <a class="el" href="ogr__api_8h.html#ac6da541cb655ab631df729e71da2e762" title="Get the number of layers in this data source.">OGR_DS_GetLayerCount()</a>-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an handle to the layer, or NULL if iLayer is out of range or an error occurs. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a03998029f904d1c3b12de40114e7503e">OGR_DS_GetLayer()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a03998029f904d1c3b12de40114e7503e">OGR_DS_GetLayer()</a>.</p>

</div>
</div>
<a class="anchor" id="a74af4912b67bf2a7b6e3230711a40d0e"></a><!-- doxytag: member="ogr_api.h::OGR_DS_GetLayerByName" ref="a74af4912b67bf2a7b6e3230711a40d0e" args="(OGRDataSourceH, const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRLayerH OGR_DS_GetLayerByName </td>
          <td>(</td>
          <td class="paramtype">OGRDataSourceH&nbsp;</td>
          <td class="paramname"> <em>hDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszLayerName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch a layer by name. </p>
<p>The returned layer remains owned by the <a class="el" href="classOGRDataSource.html">OGRDataSource</a> and should not be deleted by the application.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRDataSource.html#aa0fafafc83084ad140ecdf17d9e139f9" title="Fetch a layer by name.">OGRDataSource::GetLayerByName()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDS</em>&nbsp;</td><td>handle to the data source from which to get the layer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszLayerName</em>&nbsp;</td><td>Layer the layer name of the layer to fetch.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an handle to the layer, or NULL if the layer is not found or an error occurs. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a74af4912b67bf2a7b6e3230711a40d0e">OGR_DS_GetLayerByName()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a74af4912b67bf2a7b6e3230711a40d0e">OGR_DS_GetLayerByName()</a>.</p>

</div>
</div>
<a class="anchor" id="ac6da541cb655ab631df729e71da2e762"></a><!-- doxytag: member="ogr_api.h::OGR_DS_GetLayerCount" ref="ac6da541cb655ab631df729e71da2e762" args="(OGRDataSourceH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_DS_GetLayerCount </td>
          <td>(</td>
          <td class="paramtype">OGRDataSourceH&nbsp;</td>
          <td class="paramname"> <em>hDS</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the number of layers in this data source. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRDataSource.html#a031694429394662fd50353c5e2b68692" title="Get the number of layers in this data source.">OGRDataSource::GetLayerCount()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDS</em>&nbsp;</td><td>handle to the data source from which to get the number of layers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>layer count. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#ac6da541cb655ab631df729e71da2e762">OGR_DS_GetLayerCount()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ac6da541cb655ab631df729e71da2e762">OGR_DS_GetLayerCount()</a>.</p>

</div>
</div>
<a class="anchor" id="aea8cc826474b55371b1b4e24a24ba1db"></a><!-- doxytag: member="ogr_api.h::OGR_DS_GetName" ref="aea8cc826474b55371b1b4e24a24ba1db" args="(OGRDataSourceH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * OGR_DS_GetName </td>
          <td>(</td>
          <td class="paramtype">OGRDataSourceH&nbsp;</td>
          <td class="paramname"> <em>hDS</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the name of the data source. </p>
<p>This string should be sufficient to open the data source if passed to the same <a class="el" href="classOGRSFDriver.html">OGRSFDriver</a> that this data source was opened with, but it need not be exactly the same string that was used to open the data source. Normally this is a filename.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRDataSource.html#a682c885a30cbc3a35ed59ed39f316a55" title="Returns the name of the data source.">OGRDataSource::GetName()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDS</em>&nbsp;</td><td>handle to the data source to get the name from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to an internal name string which should not be modified or freed by the caller. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#aea8cc826474b55371b1b4e24a24ba1db">OGR_DS_GetName()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#aea8cc826474b55371b1b4e24a24ba1db">OGR_DS_GetName()</a>.</p>

</div>
</div>
<a class="anchor" id="afc7b521a05c1207e298a2b9dbf4a1181"></a><!-- doxytag: member="ogr_api.h::OGR_DS_ReleaseResultSet" ref="afc7b521a05c1207e298a2b9dbf4a1181" args="(OGRDataSourceH, OGRLayerH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_DS_ReleaseResultSet </td>
          <td>(</td>
          <td class="paramtype">OGRDataSourceH&nbsp;</td>
          <td class="paramname"> <em>hDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>hLayer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Release results of <a class="el" href="ogr__api_8h.html#a9892ecb0bf61add295bd9decdb13797a" title="Execute an SQL statement against the data store.">OGR_DS_ExecuteSQL()</a>. </p>
<p>This function should only be used to deallocate OGRLayers resulting from an <a class="el" href="ogr__api_8h.html#a9892ecb0bf61add295bd9decdb13797a" title="Execute an SQL statement against the data store.">OGR_DS_ExecuteSQL()</a> call on the same <a class="el" href="classOGRDataSource.html">OGRDataSource</a>. Failure to deallocate a results set before destroying the <a class="el" href="classOGRDataSource.html">OGRDataSource</a> may cause errors.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRDataSource.html#a7d3ee7601f510a87afc76de8a51aa9b1" title="Release results of ExecuteSQL().">OGRDataSource::ReleaseResultSet()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDS</em>&nbsp;</td><td>an handle to the data source on which was executed an SQL query. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hLayer</em>&nbsp;</td><td>handle to the result of a previous <a class="el" href="ogr__api_8h.html#a9892ecb0bf61add295bd9decdb13797a" title="Execute an SQL statement against the data store.">OGR_DS_ExecuteSQL()</a> call. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#afc7b521a05c1207e298a2b9dbf4a1181">OGR_DS_ReleaseResultSet()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#afc7b521a05c1207e298a2b9dbf4a1181">OGR_DS_ReleaseResultSet()</a>.</p>

</div>
</div>
<a class="anchor" id="a139ab189c06d9f5f26e21b134928f882"></a><!-- doxytag: member="ogr_api.h::OGR_DS_SyncToDisk" ref="a139ab189c06d9f5f26e21b134928f882" args="(OGRDataSourceH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_DS_SyncToDisk </td>
          <td>(</td>
          <td class="paramtype">OGRDataSourceH&nbsp;</td>
          <td class="paramname"> <em>hDS</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flush pending changes to disk. </p>
<p>This call is intended to force the datasource to flush any pending writes to disk, and leave the disk file in a consistent state. It would not normally have any effect on read-only datasources.</p>
<p>Some data sources do not implement this method, and will still return OGRERR_NONE. An error is only returned if an error occurs while attempting to flush to disk.</p>
<p>The default implementation of this method just calls the SyncToDisk() method on each of the layers. Conceptionally, calling SyncToDisk() on a datasource should include any work that might be accomplished by calling SyncToDisk() on layers in that data source.</p>
<p>In any event, you should always close any opened datasource with <a class="el" href="ogr__api_8h.html#a4823e7c3513cd9d57254364de9a1d021" title="Closes opened datasource and releases allocated resources.">OGR_DS_Destroy()</a> that will ensure all data is correctly flushed.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRDataSource.html#a1af1c7cf202f9a2ca2310bbfa3d00cca" title="Flush pending changes to disk.">OGRDataSource::SyncToDisk()</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDS</em>&nbsp;</td><td>handle to the data source</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE if no error occurs (even if nothing is done) or an error code. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a139ab189c06d9f5f26e21b134928f882">OGR_DS_SyncToDisk()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a139ab189c06d9f5f26e21b134928f882">OGR_DS_SyncToDisk()</a>.</p>

</div>
</div>
<a class="anchor" id="ad0fefab726442fa71ab5ef74fe8549a6"></a><!-- doxytag: member="ogr_api.h::OGR_DS_TestCapability" ref="ad0fefab726442fa71ab5ef74fe8549a6" args="(OGRDataSourceH, const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_DS_TestCapability </td>
          <td>(</td>
          <td class="paramtype">OGRDataSourceH&nbsp;</td>
          <td class="paramname"> <em>hDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszCapability</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if capability is available. </p>
<p>One of the following data source capability names can be passed into this function, and a TRUE or FALSE value will be returned indicating whether or not the capability is available for this object.</p>
<ul>
<li>
<b>ODsCCreateLayer</b>: True if this datasource can create new layers. </li>
<li>
<p class="startli"><b>ODsCDeleteLayer</b>: True if this datasource can delete existing layers.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>ODsCCreateGeomFieldAfterCreateLayer</b>: True if the layers of this datasource support CreateGeomField() just after layer creation.</p>
<p></p>
<p class="endli"></p>
</li>
</ul>
<p>The #define macro forms of the capability names should be used in preference to the strings themselves to avoid mispelling.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRDataSource.html#a3b7c054c376151e1a1f63861d7239c8b" title="Test if capability is available.">OGRDataSource::TestCapability()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDS</em>&nbsp;</td><td>handle to the data source against which to test the capability. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszCapability</em>&nbsp;</td><td>the capability to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if capability available otherwise FALSE. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#ad0fefab726442fa71ab5ef74fe8549a6">OGR_DS_TestCapability()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ad0fefab726442fa71ab5ef74fe8549a6">OGR_DS_TestCapability()</a>.</p>

</div>
</div>
<a class="anchor" id="a90c0adfd518b71571d9ce8d976fab320"></a><!-- doxytag: member="ogr_api.h::OGR_F_Clone" ref="a90c0adfd518b71571d9ce8d976fab320" args="(OGRFeatureH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRFeatureH OGR_F_Clone </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Duplicate feature. </p>
<p>The newly created feature is owned by the caller, and will have it's own reference to the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a>.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a580a742ae4952c3a4a0dd25ae2afb7e5" title="Duplicate feature.">OGRFeature::Clone()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature to clone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an handle to the new feature, exactly matching this feature. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a90c0adfd518b71571d9ce8d976fab320">OGR_F_Clone()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a90c0adfd518b71571d9ce8d976fab320">OGR_F_Clone()</a>.</p>

</div>
</div>
<a class="anchor" id="a335fbf2220d7f93437621cae723558ac"></a><!-- doxytag: member="ogr_api.h::OGR_F_Create" ref="a335fbf2220d7f93437621cae723558ac" args="(OGRFeatureDefnH) CPL_WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRFeatureH OGR_F_Create </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Feature factory. </p>
<p>Note that the <a class="el" href="classOGRFeature.html">OGRFeature</a> will increment the reference count of it's defining <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a>. Destruction of the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> before destruction of all OGRFeatures that depend on it is likely to result in a crash.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#ae6559a9f3c26274d1253e5d043b2e852" title="Constructor.">OGRFeature::OGRFeature()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the feature class (layer) definition to which the feature will adhere.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an handle to the new feature object with null fields and no geometry. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a335fbf2220d7f93437621cae723558ac">OGR_F_Create()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a335fbf2220d7f93437621cae723558ac">OGR_F_Create()</a>.</p>

</div>
</div>
<a class="anchor" id="a16fb8126aa932f4b4acdaca5ea99bbbb"></a><!-- doxytag: member="ogr_api.h::OGR_F_Destroy" ref="a16fb8126aa932f4b4acdaca5ea99bbbb" args="(OGRFeatureH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_Destroy </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy feature. </p>
<p>The feature is deleted, but within the context of the GDAL/OGR heap. This is necessary when higher level applications use GDAL/OGR from a DLL and they want to delete a feature created within the DLL. If the delete is done in the calling application the memory will be freed onto the application heap which is inappropriate.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a5d2602d11f21567119da0ca6b6c5ad45" title="Destroy feature.">OGRFeature::DestroyFeature()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature to destroy. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#a16fb8126aa932f4b4acdaca5ea99bbbb">OGR_F_Destroy()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a16fb8126aa932f4b4acdaca5ea99bbbb">OGR_F_Destroy()</a>.</p>

</div>
</div>
<a class="anchor" id="ae38d330f942798fcbaaf27e5807fb567"></a><!-- doxytag: member="ogr_api.h::OGR_F_DumpReadable" ref="ae38d330f942798fcbaaf27e5807fb567" args="(OGRFeatureH, FILE *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_DumpReadable </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>fpOut</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dump this feature in a human readable form. </p>
<p>This dumps the attributes, and geometry; however, it doesn't definition information (other than field types and names), nor does it report the geometry spatial reference system.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a6c787aeb650bd03420309ca4f52c0083" title="Dump this feature in a human readable form.">OGRFeature::DumpReadable()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature to dump. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fpOut</em>&nbsp;</td><td>the stream to write to, such as strout. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#ae38d330f942798fcbaaf27e5807fb567">OGR_F_DumpReadable()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ae38d330f942798fcbaaf27e5807fb567">OGR_F_DumpReadable()</a>.</p>

</div>
</div>
<a class="anchor" id="a8b6a502ec0b70f3de50e7184a087a264"></a><!-- doxytag: member="ogr_api.h::OGR_F_Equal" ref="a8b6a502ec0b70f3de50e7184a087a264" args="(OGRFeatureH, OGRFeatureH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_F_Equal </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hOtherFeat</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if two features are the same. </p>
<p>Two features are considered equal if the share them (handle equality) same <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a>, have the same field values, and the same geometry (as tested by OGR_G_Equal()) as well as the same feature id.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a738dfd54ecb6fb86e294929e91f90479" title="Test if two features are the same.">OGRFeature::Equal()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to one of the feature. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hOtherFeat</em>&nbsp;</td><td>handle to the other feature to test this one against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if they are equal, otherwise FALSE. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a8b6a502ec0b70f3de50e7184a087a264">OGR_F_Equal()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a8b6a502ec0b70f3de50e7184a087a264">OGR_F_Equal()</a>.</p>

</div>
</div>
<a class="anchor" id="a123dfa431bf655aafd2dbd42247dd7be"></a><!-- doxytag: member="ogr_api.h::OGR_F_GetDefnRef" ref="a123dfa431bf655aafd2dbd42247dd7be" args="(OGRFeatureH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRFeatureDefnH OGR_F_GetDefnRef </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch feature definition. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a01ef8d59265a7ab7a575387a8269bf92" title="Fetch feature definition.">OGRFeature::GetDefnRef()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature to get the feature definition from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an handle to the feature definition object on which feature depends. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a123dfa431bf655aafd2dbd42247dd7be">OGR_F_GetDefnRef()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a123dfa431bf655aafd2dbd42247dd7be">OGR_F_GetDefnRef()</a>.</p>

</div>
</div>
<a class="anchor" id="a95bc391bf7883a8732a523d525c26a00"></a><!-- doxytag: member="ogr_api.h::OGR_F_GetFID" ref="a95bc391bf7883a8732a523d525c26a00" args="(OGRFeatureH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long OGR_F_GetFID </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get feature identifier. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a23506b436ea8e88e65aaa6b57bbaa326" title="Get feature identifier.">OGRFeature::GetFID()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature from which to get the feature identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>feature id or OGRNullFID if none has been assigned. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a95bc391bf7883a8732a523d525c26a00">OGR_F_GetFID()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a95bc391bf7883a8732a523d525c26a00">OGR_F_GetFID()</a>.</p>

</div>
</div>
<a class="anchor" id="a72727f2f59d1defa01cedfb884df1a09"></a><!-- doxytag: member="ogr_api.h::OGR_F_GetFieldAsBinary" ref="a72727f2f59d1defa01cedfb884df1a09" args="(OGRFeatureH, int, int *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GByte* OGR_F_GetFieldAsBinary </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pnBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch field value as binary. </p>
<p>Currently this method only works for OFTBinary fields.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a0262d9d3f0f9e18a1e2101e1972aebae" title="Fetch field value as binary data.">OGRFeature::GetFieldAsBinary()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iField</em>&nbsp;</td><td>the field to fetch, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnBytes</em>&nbsp;</td><td>location to place count of bytes returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the field value. This list is internal, and should not be modified, or freed. Its lifetime may be very brief. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a72727f2f59d1defa01cedfb884df1a09">OGR_F_GetFieldAsBinary()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a72727f2f59d1defa01cedfb884df1a09">OGR_F_GetFieldAsBinary()</a>.</p>

</div>
</div>
<a class="anchor" id="a47ca681bb6099eb8c18004d1f7112d95"></a><!-- doxytag: member="ogr_api.h::OGR_F_GetFieldAsDateTime" ref="a47ca681bb6099eb8c18004d1f7112d95" args="(OGRFeatureH, int, int *, int *, int *, int *, int *, int *, int *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_F_GetFieldAsDateTime </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pnYear</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pnMonth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pnDay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pnHour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pnMinute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pnSecond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pnTZFlag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch field value as date and time. </p>
<p>Currently this method only works for OFTDate, OFTTime and OFTDateTime fields.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a6c5d2444407b07e07b79863c42ee7a49" title="Fetch field value as date and time.">OGRFeature::GetFieldAsDateTime()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iField</em>&nbsp;</td><td>the field to fetch, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnYear</em>&nbsp;</td><td>(including century) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnMonth</em>&nbsp;</td><td>(1-12) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnDay</em>&nbsp;</td><td>(1-31) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnHour</em>&nbsp;</td><td>(0-23) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnMinute</em>&nbsp;</td><td>(0-59) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnSecond</em>&nbsp;</td><td>(0-59) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnTZFlag</em>&nbsp;</td><td>(0=unknown, 1=localtime, 100=GMT, see data model for details)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success or FALSE on failure. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a47ca681bb6099eb8c18004d1f7112d95">OGR_F_GetFieldAsDateTime()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a47ca681bb6099eb8c18004d1f7112d95">OGR_F_GetFieldAsDateTime()</a>.</p>

</div>
</div>
<a class="anchor" id="a62252a0d4538c695d41956a96cdc6978"></a><!-- doxytag: member="ogr_api.h::OGR_F_GetFieldAsDouble" ref="a62252a0d4538c695d41956a96cdc6978" args="(OGRFeatureH, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGR_F_GetFieldAsDouble </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iField</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch field value as a double. </p>
<p>OFTString features will be translated using atof(). OFTInteger fields will be cast to double. Other field types, or errors will result in a return value of zero.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#ab8a57c94e8bb8ffac5e7048d896254b4" title="Fetch field value as a double.">OGRFeature::GetFieldAsDouble()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iField</em>&nbsp;</td><td>the field to fetch, from 0 to GetFieldCount()-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the field value. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a62252a0d4538c695d41956a96cdc6978">OGR_F_GetFieldAsDouble()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a62252a0d4538c695d41956a96cdc6978">OGR_F_GetFieldAsDouble()</a>.</p>

</div>
</div>
<a class="anchor" id="a4a27f74a38506ac492ec8b6e00eb58c9"></a><!-- doxytag: member="ogr_api.h::OGR_F_GetFieldAsDoubleList" ref="a4a27f74a38506ac492ec8b6e00eb58c9" args="(OGRFeatureH, int, int *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double* OGR_F_GetFieldAsDoubleList </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pnCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch field value as a list of doubles. </p>
<p>Currently this function only works for OFTRealList fields.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a8f799b9e9e44af526659b646bbfda870" title="Fetch field value as a list of doubles.">OGRFeature::GetFieldAsDoubleList()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iField</em>&nbsp;</td><td>the field to fetch, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnCount</em>&nbsp;</td><td>an integer to put the list count (number of doubles) into.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the field value. This list is internal, and should not be modified, or freed. Its lifetime may be very brief. If *pnCount is zero on return the returned pointer may be NULL or non-NULL. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a4a27f74a38506ac492ec8b6e00eb58c9">OGR_F_GetFieldAsDoubleList()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a4a27f74a38506ac492ec8b6e00eb58c9">OGR_F_GetFieldAsDoubleList()</a>.</p>

</div>
</div>
<a class="anchor" id="acfb4d2c0001af379e396021ecbdaf275"></a><!-- doxytag: member="ogr_api.h::OGR_F_GetFieldAsInteger" ref="acfb4d2c0001af379e396021ecbdaf275" args="(OGRFeatureH, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_F_GetFieldAsInteger </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iField</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch field value as integer. </p>
<p>OFTString features will be translated using atoi(). OFTReal fields will be cast to integer. Other field types, or errors will result in a return value of zero.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#add319b68ea27a4ee0602d3aa460ca3b5" title="Fetch field value as integer.">OGRFeature::GetFieldAsInteger()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iField</em>&nbsp;</td><td>the field to fetch, from 0 to GetFieldCount()-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the field value. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#acfb4d2c0001af379e396021ecbdaf275">OGR_F_GetFieldAsInteger()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#acfb4d2c0001af379e396021ecbdaf275">OGR_F_GetFieldAsInteger()</a>.</p>

</div>
</div>
<a class="anchor" id="ac671852e05692c584b493b2acbd6b8ce"></a><!-- doxytag: member="ogr_api.h::OGR_F_GetFieldAsIntegerList" ref="ac671852e05692c584b493b2acbd6b8ce" args="(OGRFeatureH, int, int *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int* OGR_F_GetFieldAsIntegerList </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pnCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch field value as a list of integers. </p>
<p>Currently this function only works for OFTIntegerList fields.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a3f153cf4e2e6513b7df60f46ae8440bd" title="Fetch field value as a list of integers.">OGRFeature::GetFieldAsIntegerList()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iField</em>&nbsp;</td><td>the field to fetch, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnCount</em>&nbsp;</td><td>an integer to put the list count (number of integers) into.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the field value. This list is internal, and should not be modified, or freed. Its lifetime may be very brief. If *pnCount is zero on return the returned pointer may be NULL or non-NULL. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#ac671852e05692c584b493b2acbd6b8ce">OGR_F_GetFieldAsIntegerList()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ac671852e05692c584b493b2acbd6b8ce">OGR_F_GetFieldAsIntegerList()</a>.</p>

</div>
</div>
<a class="anchor" id="a42acfd1f4b49dddc1c308462ae800c26"></a><!-- doxytag: member="ogr_api.h::OGR_F_GetFieldAsString" ref="a42acfd1f4b49dddc1c308462ae800c26" args="(OGRFeatureH, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_F_GetFieldAsString </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iField</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch field value as a string. </p>
<p>OFTReal and OFTInteger fields will be translated to string using sprintf(), but not necessarily using the established formatting rules. Other field types, or errors will result in a return value of zero.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#ac7a0224e13dce1f9479a6bf2111ea766" title="Fetch field value as a string.">OGRFeature::GetFieldAsString()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iField</em>&nbsp;</td><td>the field to fetch, from 0 to GetFieldCount()-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the field value. This string is internal, and should not be modified, or freed. Its lifetime may be very brief. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a42acfd1f4b49dddc1c308462ae800c26">OGR_F_GetFieldAsString()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a42acfd1f4b49dddc1c308462ae800c26">OGR_F_GetFieldAsString()</a>.</p>

</div>
</div>
<a class="anchor" id="a3e55ba4a06d4c4a392206518b390ac38"></a><!-- doxytag: member="ogr_api.h::OGR_F_GetFieldAsStringList" ref="a3e55ba4a06d4c4a392206518b390ac38" args="(OGRFeatureH, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char** OGR_F_GetFieldAsStringList </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iField</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch field value as a list of strings. </p>
<p>Currently this method only works for OFTStringList fields.</p>
<p>The returned list is terminated by a NULL pointer. The number of elements can also be calculated using <a class="el" href="cpl__string_8h.html#ac1ffd0e5baf9729f09388a38c07f5835">CSLCount()</a>.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#ac142f8ba9929f6c89133adbcbff39945" title="Fetch field value as a list of strings.">OGRFeature::GetFieldAsStringList()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iField</em>&nbsp;</td><td>the field to fetch, from 0 to GetFieldCount()-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the field value. This list is internal, and should not be modified, or freed. Its lifetime may be very brief. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a3e55ba4a06d4c4a392206518b390ac38">OGR_F_GetFieldAsStringList()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a3e55ba4a06d4c4a392206518b390ac38">OGR_F_GetFieldAsStringList()</a>.</p>

</div>
</div>
<a class="anchor" id="af6c1440956ee56c0c160394bccf96990"></a><!-- doxytag: member="ogr_api.h::OGR_F_GetFieldCount" ref="af6c1440956ee56c0c160394bccf96990" args="(OGRFeatureH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_F_GetFieldCount </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch number of fields on this feature This will always be the same as the field count for the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a>. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#ab7f4eb0c098a9456d4005828127cdde0" title="Fetch number of fields on this feature. This will always be the same as the field count for the OGRFe...">OGRFeature::GetFieldCount()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature to get the fields count from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>count of fields. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#af6c1440956ee56c0c160394bccf96990">OGR_F_GetFieldCount()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#af6c1440956ee56c0c160394bccf96990">OGR_F_GetFieldCount()</a>.</p>

</div>
</div>
<a class="anchor" id="a6f8fc7fd6ecca789ad90db6d28391623"></a><!-- doxytag: member="ogr_api.h::OGR_F_GetFieldDefnRef" ref="a6f8fc7fd6ecca789ad90db6d28391623" args="(OGRFeatureH, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRFieldDefnH OGR_F_GetFieldDefnRef </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch definition for this field. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a35aba5a674e9901eccf1e7d90d97d773" title="Fetch definition for this field.">OGRFeature::GetFieldDefnRef()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature on which the field is found. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>the field to fetch, from 0 to GetFieldCount()-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an handle to the field definition (from the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a>). This is an internal reference, and should not be deleted or modified. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a6f8fc7fd6ecca789ad90db6d28391623">OGR_F_GetFieldDefnRef()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a6f8fc7fd6ecca789ad90db6d28391623">OGR_F_GetFieldDefnRef()</a>.</p>

</div>
</div>
<a class="anchor" id="a9a8a6b93ab97204b94f5c2b358f8f98e"></a><!-- doxytag: member="ogr_api.h::OGR_F_GetFieldIndex" ref="a9a8a6b93ab97204b94f5c2b358f8f98e" args="(OGRFeatureH, const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_F_GetFieldIndex </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch the field index given field name. </p>
<p>This is a cover for the <a class="el" href="classOGRFeatureDefn.html#a4f7111e4c818f194932795e9c9593258" title="Find field by name.">OGRFeatureDefn::GetFieldIndex()</a> method.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#ab49421f777e56b7cb41169f1301a7b21" title="Fetch the field index given field name.">OGRFeature::GetFieldIndex()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature on which the field is found. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszName</em>&nbsp;</td><td>the name of the field to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the field index, or -1 if no matching field is found. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a9a8a6b93ab97204b94f5c2b358f8f98e">OGR_F_GetFieldIndex()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a9a8a6b93ab97204b94f5c2b358f8f98e">OGR_F_GetFieldIndex()</a>.</p>

</div>
</div>
<a class="anchor" id="a1bf9596756aeacec4da502383c378f5c"></a><!-- doxytag: member="ogr_api.h::OGR_F_GetGeometryRef" ref="a1bf9596756aeacec4da502383c378f5c" args="(OGRFeatureH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRGeometryH OGR_F_GetGeometryRef </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch an handle to feature geometry. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#acc966ce8c10ae3ddf9f14c2736fdce9a" title="Fetch pointer to feature geometry.">OGRFeature::GetGeometryRef()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature to get geometry from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an handle to internal feature geometry. This object should not be modified. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a1bf9596756aeacec4da502383c378f5c">OGR_F_GetGeometryRef()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a1bf9596756aeacec4da502383c378f5c">OGR_F_GetGeometryRef()</a>.</p>

</div>
</div>
<a class="anchor" id="a7975076d4ab247189487c0fd50d8365c"></a><!-- doxytag: member="ogr_api.h::OGR_F_GetGeomFieldCount" ref="a7975076d4ab247189487c0fd50d8365c" args="(OGRFeatureH hFeat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_F_GetGeomFieldCount </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch number of geometry fields on this feature This will always be the same as the geometry field count for the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a>. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#af673e46f318facbee14acec3d6db2caf" title="Fetch number of geometry fields on this feature. This will always be the same as the geometry field c...">OGRFeature::GetGeomFieldCount()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature to get the geometry fields count from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>count of geometry fields.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.11 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a7975076d4ab247189487c0fd50d8365c">OGR_F_GetGeomFieldCount()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a7975076d4ab247189487c0fd50d8365c">OGR_F_GetGeomFieldCount()</a>.</p>

</div>
</div>
<a class="anchor" id="a11c3d59a3854dad80c4257e788c5d881"></a><!-- doxytag: member="ogr_api.h::OGR_F_GetGeomFieldDefnRef" ref="a11c3d59a3854dad80c4257e788c5d881" args="(OGRFeatureH hFeat, int iField)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRGeomFieldDefnH OGR_F_GetGeomFieldDefnRef </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch definition for this geometry field. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#ab0416401dc7d6a7634c2a24ca1f7d255" title="Fetch definition for this geometry field.">OGRFeature::GetGeomFieldDefnRef()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature on which the field is found. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>the field to fetch, from 0 to GetGeomFieldCount()-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an handle to the field definition (from the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a>). This is an internal reference, and should not be deleted or modified.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.11 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a11c3d59a3854dad80c4257e788c5d881">OGR_F_GetGeomFieldDefnRef()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a11c3d59a3854dad80c4257e788c5d881">OGR_F_GetGeomFieldDefnRef()</a>.</p>

</div>
</div>
<a class="anchor" id="a546acd0aad47128b1f178a8d01765e63"></a><!-- doxytag: member="ogr_api.h::OGR_F_GetGeomFieldIndex" ref="a546acd0aad47128b1f178a8d01765e63" args="(OGRFeatureH hFeat, const char *pszName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_F_GetGeomFieldIndex </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch the geometry field index given geometry field name. </p>
<p>This is a cover for the <a class="el" href="classOGRFeatureDefn.html#a2aaea18e9bcfee39cee05d616de6e12c" title="Find geometry field by name.">OGRFeatureDefn::GetGeomFieldIndex()</a> method.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a97b0d91be90a05cf51d3e5f602a9d560" title="Fetch the geometry field index given geometry field name.">OGRFeature::GetGeomFieldIndex()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature on which the geometry field is found. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszName</em>&nbsp;</td><td>the name of the geometry field to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the geometry field index, or -1 if no matching geometry field is found.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.11 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a546acd0aad47128b1f178a8d01765e63">OGR_F_GetGeomFieldIndex()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a546acd0aad47128b1f178a8d01765e63">OGR_F_GetGeomFieldIndex()</a>.</p>

</div>
</div>
<a class="anchor" id="a37aa8b53b1fc8816c5b7bcbbcb6a46ca"></a><!-- doxytag: member="ogr_api.h::OGR_F_GetGeomFieldRef" ref="a37aa8b53b1fc8816c5b7bcbbcb6a46ca" args="(OGRFeatureH hFeat, int iField)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRGeometryH OGR_F_GetGeomFieldRef </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iField</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch an handle to feature geometry. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#ae54d999d4649730d5c7b37de731e4f69" title="Fetch pointer to feature geometry.">OGRFeature::GetGeomFieldRef()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature to get geometry from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iField</em>&nbsp;</td><td>geometry field to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an handle to internal feature geometry. This object should not be modified.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.11 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a37aa8b53b1fc8816c5b7bcbbcb6a46ca">OGR_F_GetGeomFieldRef()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a37aa8b53b1fc8816c5b7bcbbcb6a46ca">OGR_F_GetGeomFieldRef()</a>.</p>

</div>
</div>
<a class="anchor" id="af7043e9dfadbdeca8059ace336875d4c"></a><!-- doxytag: member="ogr_api.h::OGR_F_GetRawFieldRef" ref="af7043e9dfadbdeca8059ace336875d4c" args="(OGRFeatureH, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="unionOGRField.html">OGRField</a>* OGR_F_GetRawFieldRef </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iField</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch an handle to the internal field value given the index. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#ae7f676d5a8e1f62d80b438c13b159ee0" title="Fetch a pointer to the internal field value given the index.">OGRFeature::GetRawFieldRef()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature on which field is found. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iField</em>&nbsp;</td><td>the field to fetch, from 0 to GetFieldCount()-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the returned handle is to an internal data structure, and should not be freed, or modified. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#af7043e9dfadbdeca8059ace336875d4c">OGR_F_GetRawFieldRef()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#af7043e9dfadbdeca8059ace336875d4c">OGR_F_GetRawFieldRef()</a>.</p>

</div>
</div>
<a class="anchor" id="a10fb5f53d99ccf46280e4c38afe4a5a5"></a><!-- doxytag: member="ogr_api.h::OGR_F_GetStyleString" ref="a10fb5f53d99ccf46280e4c38afe4a5a5" args="(OGRFeatureH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_F_GetStyleString </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch style string for this feature. </p>
<p>Set the OGR Feature Style Specification for details on the format of this string, and <a class="el" href="ogr__featurestyle_8h.html">ogr_featurestyle.h</a> for services available to parse it.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a54c179e53eb6eddb657dd392a87cccab" title="Fetch style string for this feature.">OGRFeature::GetStyleString()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature to get the style from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to a representation in string format, or NULL if there isn't one. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a10fb5f53d99ccf46280e4c38afe4a5a5">OGR_F_GetStyleString()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a10fb5f53d99ccf46280e4c38afe4a5a5">OGR_F_GetStyleString()</a>.</p>

</div>
</div>
<a class="anchor" id="abb018a9030ed76353ae26082deaaef11"></a><!-- doxytag: member="ogr_api.h::OGR_F_IsFieldSet" ref="abb018a9030ed76353ae26082deaaef11" args="(OGRFeatureH, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_F_IsFieldSet </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iField</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if a field has ever been assigned a value or not. </p>
<p>This function is the same as the C++ method OGRFeature::IsFieldSet().</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature on which the field is. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iField</em>&nbsp;</td><td>the field to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the field has been set, otherwise false. </dd></dl>

<p>References <a class="el" href="classOGRFeature.html#ab7f4eb0c098a9456d4005828127cdde0">OGRFeature::GetFieldCount()</a>, and <a class="el" href="ogr__api_8h.html#abb018a9030ed76353ae26082deaaef11">OGR_F_IsFieldSet()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#abb018a9030ed76353ae26082deaaef11">OGR_F_IsFieldSet()</a>.</p>

</div>
</div>
<a class="anchor" id="a09d01eea41746751db62da123887e787"></a><!-- doxytag: member="ogr_api.h::OGR_F_SetFID" ref="a09d01eea41746751db62da123887e787" args="(OGRFeatureH, long)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_F_SetFID </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nFID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the feature identifier. </p>
<p>For specific types of features this operation may fail on illegal features ids. Generally it always succeeds. Feature ids should be greater than or equal to zero, with the exception of OGRNullFID (-1) indicating that the feature id is unknown.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a9abfc256b2d1758761fa54ca3395029b" title="Set the feature identifier.">OGRFeature::SetFID()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature to set the feature id to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nFID</em>&nbsp;</td><td>the new feature identifier value to assign.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>On success OGRERR_NONE, or on failure some other value. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a09d01eea41746751db62da123887e787">OGR_F_SetFID()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a09d01eea41746751db62da123887e787">OGR_F_SetFID()</a>.</p>

</div>
</div>
<a class="anchor" id="a5dcaa7d3e71f078ae714831f7c5cae1d"></a><!-- doxytag: member="ogr_api.h::OGR_F_SetFieldBinary" ref="a5dcaa7d3e71f078ae714831f7c5cae1d" args="(OGRFeatureH, int, int, GByte *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetFieldBinary </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GByte *&nbsp;</td>
          <td class="paramname"> <em>pabyData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set field to binary data. </p>
<p>This function currently on has an effect of OFTBinary fields.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a4abbe118cc2f3e48bbac7f710b71b531" title="Set field to integer value.">OGRFeature::SetField()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iField</em>&nbsp;</td><td>the field to set, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nBytes</em>&nbsp;</td><td>the number of bytes in pabyData array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pabyData</em>&nbsp;</td><td>the data to apply. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#a5dcaa7d3e71f078ae714831f7c5cae1d">OGR_F_SetFieldBinary()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a5dcaa7d3e71f078ae714831f7c5cae1d">OGR_F_SetFieldBinary()</a>.</p>

</div>
</div>
<a class="anchor" id="a627970180a20e2a4b1c7ae694923fd73"></a><!-- doxytag: member="ogr_api.h::OGR_F_SetFieldDateTime" ref="a627970180a20e2a4b1c7ae694923fd73" args="(OGRFeatureH, int, int, int, int, int, int, int, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetFieldDateTime </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nYear</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nMonth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nDay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nHour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nMinute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nSecond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nTZFlag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set field to datetime. </p>
<p>This method currently only has an effect for OFTDate, OFTTime and OFTDateTime fields.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iField</em>&nbsp;</td><td>the field to set, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nYear</em>&nbsp;</td><td>(including century) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nMonth</em>&nbsp;</td><td>(1-12) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nDay</em>&nbsp;</td><td>(1-31) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nHour</em>&nbsp;</td><td>(0-23) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nMinute</em>&nbsp;</td><td>(0-59) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nSecond</em>&nbsp;</td><td>(0-59) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nTZFlag</em>&nbsp;</td><td>(0=unknown, 1=localtime, 100=GMT, see data model for details) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#a627970180a20e2a4b1c7ae694923fd73">OGR_F_SetFieldDateTime()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a627970180a20e2a4b1c7ae694923fd73">OGR_F_SetFieldDateTime()</a>.</p>

</div>
</div>
<a class="anchor" id="a9d28aa13b1b7c88f07066c36286d13b9"></a><!-- doxytag: member="ogr_api.h::OGR_F_SetFieldDouble" ref="a9d28aa13b1b7c88f07066c36286d13b9" args="(OGRFeatureH, int, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetFieldDouble </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set field to double value. </p>
<p>OFTInteger and OFTReal fields will be set directly. OFTString fields will be assigned a string representation of the value, but not necessarily taking into account formatting constraints on this field. Other field types may be unaffected.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a4abbe118cc2f3e48bbac7f710b71b531" title="Set field to integer value.">OGRFeature::SetField()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iField</em>&nbsp;</td><td>the field to fetch, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfValue</em>&nbsp;</td><td>the value to assign. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#a9d28aa13b1b7c88f07066c36286d13b9">OGR_F_SetFieldDouble()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a9d28aa13b1b7c88f07066c36286d13b9">OGR_F_SetFieldDouble()</a>.</p>

</div>
</div>
<a class="anchor" id="a6ba075923f49a5abd6637183731cb6ab"></a><!-- doxytag: member="ogr_api.h::OGR_F_SetFieldDoubleList" ref="a6ba075923f49a5abd6637183731cb6ab" args="(OGRFeatureH, int, int, double *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetFieldDoubleList </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>padfValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set field to list of doubles value. </p>
<p>This function currently on has an effect of OFTRealList fields.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a4abbe118cc2f3e48bbac7f710b71b531" title="Set field to integer value.">OGRFeature::SetField()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iField</em>&nbsp;</td><td>the field to set, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nCount</em>&nbsp;</td><td>the number of values in the list being assigned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfValues</em>&nbsp;</td><td>the values to assign. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#a6ba075923f49a5abd6637183731cb6ab">OGR_F_SetFieldDoubleList()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a6ba075923f49a5abd6637183731cb6ab">OGR_F_SetFieldDoubleList()</a>.</p>

</div>
</div>
<a class="anchor" id="ad902fb7c7fe459aacf0b2c26b8e6d1ee"></a><!-- doxytag: member="ogr_api.h::OGR_F_SetFieldInteger" ref="ad902fb7c7fe459aacf0b2c26b8e6d1ee" args="(OGRFeatureH, int, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetFieldInteger </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set field to integer value. </p>
<p>OFTInteger and OFTReal fields will be set directly. OFTString fields will be assigned a string representation of the value, but not necessarily taking into account formatting constraints on this field. Other field types may be unaffected.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a4abbe118cc2f3e48bbac7f710b71b531" title="Set field to integer value.">OGRFeature::SetField()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iField</em>&nbsp;</td><td>the field to fetch, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nValue</em>&nbsp;</td><td>the value to assign. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#ad902fb7c7fe459aacf0b2c26b8e6d1ee">OGR_F_SetFieldInteger()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ad902fb7c7fe459aacf0b2c26b8e6d1ee">OGR_F_SetFieldInteger()</a>.</p>

</div>
</div>
<a class="anchor" id="a2b7dee0dc057570af68a01ec0b5d3753"></a><!-- doxytag: member="ogr_api.h::OGR_F_SetFieldIntegerList" ref="a2b7dee0dc057570af68a01ec0b5d3753" args="(OGRFeatureH, int, int, int *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetFieldIntegerList </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>panValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set field to list of integers value. </p>
<p>This function currently on has an effect of OFTIntegerList fields.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a4abbe118cc2f3e48bbac7f710b71b531" title="Set field to integer value.">OGRFeature::SetField()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iField</em>&nbsp;</td><td>the field to set, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nCount</em>&nbsp;</td><td>the number of values in the list being assigned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>panValues</em>&nbsp;</td><td>the values to assign. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#a2b7dee0dc057570af68a01ec0b5d3753">OGR_F_SetFieldIntegerList()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a2b7dee0dc057570af68a01ec0b5d3753">OGR_F_SetFieldIntegerList()</a>.</p>

</div>
</div>
<a class="anchor" id="af3cfe4f766f5579f670bb651c53a99ca"></a><!-- doxytag: member="ogr_api.h::OGR_F_SetFieldRaw" ref="af3cfe4f766f5579f670bb651c53a99ca" args="(OGRFeatureH, int, OGRField *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetFieldRaw </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionOGRField.html">OGRField</a> *&nbsp;</td>
          <td class="paramname"> <em>psValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set field. </p>
<p>The passed value <a class="el" href="unionOGRField.html">OGRField</a> must be of exactly the same type as the target field, or an application crash may occur. The passed value is copied, and will not be affected. It remains the responsibility of the caller.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a4abbe118cc2f3e48bbac7f710b71b531" title="Set field to integer value.">OGRFeature::SetField()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iField</em>&nbsp;</td><td>the field to fetch, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>psValue</em>&nbsp;</td><td>handle on the value to assign. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#af3cfe4f766f5579f670bb651c53a99ca">OGR_F_SetFieldRaw()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#af3cfe4f766f5579f670bb651c53a99ca">OGR_F_SetFieldRaw()</a>.</p>

</div>
</div>
<a class="anchor" id="ad1a3e8b4a08f9558807389bcdde85bab"></a><!-- doxytag: member="ogr_api.h::OGR_F_SetFieldString" ref="ad1a3e8b4a08f9558807389bcdde85bab" args="(OGRFeatureH, int, const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetFieldString </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set field to string value. </p>
<p>OFTInteger fields will be set based on an atoi() conversion of the string. OFTReal fields will be set based on an atof() conversion of the string. Other field types may be unaffected.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a4abbe118cc2f3e48bbac7f710b71b531" title="Set field to integer value.">OGRFeature::SetField()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iField</em>&nbsp;</td><td>the field to fetch, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszValue</em>&nbsp;</td><td>the value to assign. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#ad1a3e8b4a08f9558807389bcdde85bab">OGR_F_SetFieldString()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ad1a3e8b4a08f9558807389bcdde85bab">OGR_F_SetFieldString()</a>.</p>

</div>
</div>
<a class="anchor" id="a9f055dc02fa8f1047849f6e30b4b86d4"></a><!-- doxytag: member="ogr_api.h::OGR_F_SetFieldStringList" ref="a9f055dc02fa8f1047849f6e30b4b86d4" args="(OGRFeatureH, int, char **)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetFieldStringList </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set field to list of strings value. </p>
<p>This function currently on has an effect of OFTStringList fields.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a4abbe118cc2f3e48bbac7f710b71b531" title="Set field to integer value.">OGRFeature::SetField()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iField</em>&nbsp;</td><td>the field to set, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>papszValues</em>&nbsp;</td><td>the values to assign. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#a9f055dc02fa8f1047849f6e30b4b86d4">OGR_F_SetFieldStringList()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a9f055dc02fa8f1047849f6e30b4b86d4">OGR_F_SetFieldStringList()</a>.</p>

</div>
</div>
<a class="anchor" id="ad7f7057a7a3764c526a4a59e2b587fba"></a><!-- doxytag: member="ogr_api.h::OGR_F_SetFrom" ref="ad7f7057a7a3764c526a4a59e2b587fba" args="(OGRFeatureH, OGRFeatureH, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_F_SetFrom </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hOtherFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bForgiving</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set one feature from another. </p>
<p>Overwrite the contents of this feature from the geometry and attributes of another. The hOtherFeature does not need to have the same <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a>. Field values are copied by corresponding field names. Field types do not have to exactly match. OGR_F_SetField*() function conversion rules will be applied as needed.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a8ebc0999c4bce0b5073add16598dfc77" title="Set one feature from another.">OGRFeature::SetFrom()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature to set to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hOtherFeat</em>&nbsp;</td><td>handle to the feature from which geometry, and field values will be copied.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bForgiving</em>&nbsp;</td><td>TRUE if the operation should continue despite lacking output fields matching some of the source fields.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE if the operation succeeds, even if some values are not transferred, otherwise an error code. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#ad7f7057a7a3764c526a4a59e2b587fba">OGR_F_SetFrom()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ad7f7057a7a3764c526a4a59e2b587fba">OGR_F_SetFrom()</a>.</p>

</div>
</div>
<a class="anchor" id="a0f36f1fba9d148f467c8156a31bdd9be"></a><!-- doxytag: member="ogr_api.h::OGR_F_SetFromWithMap" ref="a0f36f1fba9d148f467c8156a31bdd9be" args="(OGRFeatureH, OGRFeatureH, int, int *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_F_SetFromWithMap </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hOtherFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bForgiving</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>panMap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set one feature from another. </p>
<p>Overwrite the contents of this feature from the geometry and attributes of another. The hOtherFeature does not need to have the same <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a>. Field values are copied according to the provided indices map. Field types do not have to exactly match. OGR_F_SetField*() function conversion rules will be applied as needed. This is more efficient than <a class="el" href="ogr__api_8h.html#ad7f7057a7a3764c526a4a59e2b587fba" title="Set one feature from another.">OGR_F_SetFrom()</a> in that this doesn't lookup the fields by their names. Particularly useful when the field names don't match.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a8ebc0999c4bce0b5073add16598dfc77" title="Set one feature from another.">OGRFeature::SetFrom()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature to set to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hOtherFeat</em>&nbsp;</td><td>handle to the feature from which geometry, and field values will be copied.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>panMap</em>&nbsp;</td><td>Array of the indices of the destination feature's fields stored at the corresponding index of the source feature's fields. A value of -1 should be used to ignore the source's field. The array should not be NULL and be as long as the number of fields in the source feature.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bForgiving</em>&nbsp;</td><td>TRUE if the operation should continue despite lacking output fields matching some of the source fields.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE if the operation succeeds, even if some values are not transferred, otherwise an error code. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a0f36f1fba9d148f467c8156a31bdd9be">OGR_F_SetFromWithMap()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a0f36f1fba9d148f467c8156a31bdd9be">OGR_F_SetFromWithMap()</a>.</p>

</div>
</div>
<a class="anchor" id="a7b9c524f5c01a6a4b4e50e351d03299f"></a><!-- doxytag: member="ogr_api.h::OGR_F_SetGeometry" ref="a7b9c524f5c01a6a4b4e50e351d03299f" args="(OGRFeatureH, OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_F_SetGeometry </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set feature geometry. </p>
<p>This function updates the features geometry, and operate exactly as SetGeometryDirectly(), except that this function does not assume ownership of the passed geometry, but instead makes a copy of it.</p>
<p>This function is the same as the C++ <a class="el" href="classOGRFeature.html#af1181ade837a52129ea25b46dd50cf30" title="Set feature geometry.">OGRFeature::SetGeometry()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature on which new geometry is applied to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle to the new geometry to apply to feature.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE if successful, or OGR_UNSUPPORTED_GEOMETRY_TYPE if the geometry type is illegal for the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> (checking not yet implemented). </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a7b9c524f5c01a6a4b4e50e351d03299f">OGR_F_SetGeometry()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a7b9c524f5c01a6a4b4e50e351d03299f">OGR_F_SetGeometry()</a>.</p>

</div>
</div>
<a class="anchor" id="ad391d3197728bb6d12a6b0c2e2661aa4"></a><!-- doxytag: member="ogr_api.h::OGR_F_SetGeometryDirectly" ref="ad391d3197728bb6d12a6b0c2e2661aa4" args="(OGRFeatureH, OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_F_SetGeometryDirectly </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set feature geometry. </p>
<p>This function updates the features geometry, and operate exactly as SetGeometry(), except that this function assumes ownership of the passed geometry.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a40a4ddb33f09a5f340b9139be72e277d" title="Set feature geometry.">OGRFeature::SetGeometryDirectly</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature on which to apply the geometry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle to the new geometry to apply to feature.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE if successful, or OGR_UNSUPPORTED_GEOMETRY_TYPE if the geometry type is illegal for the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> (checking not yet implemented). </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#ad391d3197728bb6d12a6b0c2e2661aa4">OGR_F_SetGeometryDirectly()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ad391d3197728bb6d12a6b0c2e2661aa4">OGR_F_SetGeometryDirectly()</a>.</p>

</div>
</div>
<a class="anchor" id="ad75b18930385432110aa8d3461854cce"></a><!-- doxytag: member="ogr_api.h::OGR_F_SetGeomField" ref="ad75b18930385432110aa8d3461854cce" args="(OGRFeatureH hFeat, int iField, OGRGeometryH hGeom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_F_SetGeomField </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set feature geometry of a specified geometry field. </p>
<p>This function updates the features geometry, and operate exactly as SetGeometryDirectly(), except that this function does not assume ownership of the passed geometry, but instead makes a copy of it.</p>
<p>This function is the same as the C++ <a class="el" href="classOGRFeature.html#a26d865b737d699a12f260ee0a75588b9" title="Set feature geometry of a specified geometry field.">OGRFeature::SetGeomField()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature on which new geometry is applied to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iField</em>&nbsp;</td><td>geometry field to set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle to the new geometry to apply to feature.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE if successful, or OGR_UNSUPPORTED_GEOMETRY_TYPE if the geometry type is illegal for the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> (checking not yet implemented). </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#ad75b18930385432110aa8d3461854cce">OGR_F_SetGeomField()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ad75b18930385432110aa8d3461854cce">OGR_F_SetGeomField()</a>.</p>

</div>
</div>
<a class="anchor" id="a01530e163973979cfd8248e3ecbf2640"></a><!-- doxytag: member="ogr_api.h::OGR_F_SetGeomFieldDirectly" ref="a01530e163973979cfd8248e3ecbf2640" args="(OGRFeatureH hFeat, int iField, OGRGeometryH hGeom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_F_SetGeomFieldDirectly </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set feature geometry of a specified geometry field. </p>
<p>This function updates the features geometry, and operate exactly as SetGeomField(), except that this function assumes ownership of the passed geometry.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#ae0ddbbc910727ada3b2cd00a357222da" title="Set feature geometry of a specified geometry field.">OGRFeature::SetGeomFieldDirectly</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature on which to apply the geometry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iField</em>&nbsp;</td><td>geometry field to set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle to the new geometry to apply to feature.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE if successful, or OGRERR_FAILURE if the index is invalid, or OGR_UNSUPPORTED_GEOMETRY_TYPE if the geometry type is illegal for the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> (checking not yet implemented).</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.11 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a01530e163973979cfd8248e3ecbf2640">OGR_F_SetGeomFieldDirectly()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a01530e163973979cfd8248e3ecbf2640">OGR_F_SetGeomFieldDirectly()</a>.</p>

</div>
</div>
<a class="anchor" id="afbe436a7a48ad5bbfb3aa34f44791a68"></a><!-- doxytag: member="ogr_api.h::OGR_F_SetStyleString" ref="afbe436a7a48ad5bbfb3aa34f44791a68" args="(OGRFeatureH, const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetStyleString </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszStyle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set feature style string. This method operate exactly as <a class="el" href="ogr__api_8h.html#abc1ab2f6fb7937a8b927e4c1d3fd057c" title="Set feature style string. This method operate exactly as OGR_F_SetStyleString() except that it assume...">OGR_F_SetStyleStringDirectly()</a> except that it does not assume ownership of the passed string, but instead makes a copy of it. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a5d2c15d00845820e6382d48227ed7ff7" title="Set feature style string. This method operate exactly as OGRFeature::SetStyleStringDirectly() except ...">OGRFeature::SetStyleString()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature to set style to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszStyle</em>&nbsp;</td><td>the style string to apply to this feature, cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#afbe436a7a48ad5bbfb3aa34f44791a68">OGR_F_SetStyleString()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#afbe436a7a48ad5bbfb3aa34f44791a68">OGR_F_SetStyleString()</a>.</p>

</div>
</div>
<a class="anchor" id="abc1ab2f6fb7937a8b927e4c1d3fd057c"></a><!-- doxytag: member="ogr_api.h::OGR_F_SetStyleStringDirectly" ref="abc1ab2f6fb7937a8b927e4c1d3fd057c" args="(OGRFeatureH, char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetStyleStringDirectly </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pszStyle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set feature style string. This method operate exactly as <a class="el" href="ogr__api_8h.html#afbe436a7a48ad5bbfb3aa34f44791a68" title="Set feature style string. This method operate exactly as OGR_F_SetStyleStringDirectly() except that i...">OGR_F_SetStyleString()</a> except that it assumes ownership of the passed string. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a7282982663cee5dd2fc18a093c3e386a" title="Set feature style string. This method operate exactly as OGRFeature::SetStyleString() except that it ...">OGRFeature::SetStyleStringDirectly()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature to set style to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszStyle</em>&nbsp;</td><td>the style string to apply to this feature, cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#abc1ab2f6fb7937a8b927e4c1d3fd057c">OGR_F_SetStyleStringDirectly()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#abc1ab2f6fb7937a8b927e4c1d3fd057c">OGR_F_SetStyleStringDirectly()</a>.</p>

</div>
</div>
<a class="anchor" id="a5a6a61d39a67b1990ce92bd65de4bc6f"></a><!-- doxytag: member="ogr_api.h::OGR_F_StealGeometry" ref="a5a6a61d39a67b1990ce92bd65de4bc6f" args="(OGRFeatureH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRGeometryH OGR_F_StealGeometry </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Take away ownership of geometry. </p>
<p>Fetch the geometry from this feature, and clear the reference to the geometry on the feature. This is a mechanism for the application to take over ownship of the geometry from the feature without copying. Sort of an inverse to OGR_FSetGeometryDirectly().</p>
<p>After this call the <a class="el" href="classOGRFeature.html">OGRFeature</a> will have a NULL geometry.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the pointer to the geometry. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a5a6a61d39a67b1990ce92bd65de4bc6f">OGR_F_StealGeometry()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a5a6a61d39a67b1990ce92bd65de4bc6f">OGR_F_StealGeometry()</a>.</p>

</div>
</div>
<a class="anchor" id="aa70b7675a003141e63f9603c752ee22e"></a><!-- doxytag: member="ogr_api.h::OGR_F_UnsetField" ref="aa70b7675a003141e63f9603c752ee22e" args="(OGRFeatureH, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_UnsetField </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iField</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear a field, marking it as unset. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a937b21e0137e40bc1473f354879975da" title="Clear a field, marking it as unset.">OGRFeature::UnsetField()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the feature on which the field is. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iField</em>&nbsp;</td><td>the field to unset. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#aa70b7675a003141e63f9603c752ee22e">OGR_F_UnsetField()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#aa70b7675a003141e63f9603c752ee22e">OGR_F_UnsetField()</a>.</p>

</div>
</div>
<a class="anchor" id="a2a798e8d03299403418a7c87862f1acb"></a><!-- doxytag: member="ogr_api.h::OGR_FD_AddFieldDefn" ref="a2a798e8d03299403418a7c87862f1acb" args="(OGRFeatureDefnH, OGRFieldDefnH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_FD_AddFieldDefn </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRFieldDefnH&nbsp;</td>
          <td class="paramname"> <em>hNewField</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a new field definition to the passed feature definition. </p>
<p>To add a new field definition to a layer definition, do not use this function directly, but use <a class="el" href="ogr__api_8h.html#aab585ef1166c61c4819f7fd46ee4a275" title="Create a new field on a layer.">OGR_L_CreateField()</a> instead.</p>
<p>This function should only be called while there are no <a class="el" href="classOGRFeature.html">OGRFeature</a> objects in existance based on this <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a>. The <a class="el" href="classOGRFieldDefn.html">OGRFieldDefn</a> passed in is copied, and remains the responsibility of the caller.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#a40e681d8464b42f1a1fac655f16ac3dd" title="Add a new field definition.">OGRFeatureDefn::AddFieldDefn()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the feature definition to add the field definition to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hNewField</em>&nbsp;</td><td>handle to the new field definition. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#a2a798e8d03299403418a7c87862f1acb">OGR_FD_AddFieldDefn()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a2a798e8d03299403418a7c87862f1acb">OGR_FD_AddFieldDefn()</a>.</p>

</div>
</div>
<a class="anchor" id="aa080fdbe88c1829c1b7adcce208ec4b8"></a><!-- doxytag: member="ogr_api.h::OGR_FD_AddGeomFieldDefn" ref="aa080fdbe88c1829c1b7adcce208ec4b8" args="(OGRFeatureDefnH hFDefn, OGRGeomFieldDefnH hGFldDefn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_FD_AddGeomFieldDefn </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRGeomFieldDefnH&nbsp;</td>
          <td class="paramname"> <em>hNewGeomField</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a new field definition to the passed feature definition. </p>
<p>To add a new field definition to a layer definition, do not use this function directly, but use <a class="el" href="ogr__api_8h.html#af6908931c4f3ad364fef8d6e831363bc" title="Create a new geometry field on a layer.">OGR_L_CreateGeomField()</a> instead.</p>
<p>This function should only be called while there are no <a class="el" href="classOGRFeature.html">OGRFeature</a> objects in existance based on this <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a>. The <a class="el" href="classOGRGeomFieldDefn.html">OGRGeomFieldDefn</a> passed in is copied, and remains the responsibility of the caller.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#a99700a7f755c91c3382eaa65bc49f4f9" title="Add a new geometry field definition.">OGRFeatureDefn::AddGeomFieldDefn()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the feature definition to add the geometry field definition to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hNewGeomField</em>&nbsp;</td><td>handle to the new field definition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.11 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#aa080fdbe88c1829c1b7adcce208ec4b8">OGR_FD_AddGeomFieldDefn()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#aa080fdbe88c1829c1b7adcce208ec4b8">OGR_FD_AddGeomFieldDefn()</a>.</p>

</div>
</div>
<a class="anchor" id="a8cbc5146fcab99667f021c40c714628c"></a><!-- doxytag: member="ogr_api.h::OGR_FD_Create" ref="a8cbc5146fcab99667f021c40c714628c" args="(const char *) CPL_WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRFeatureDefnH OGR_FD_Create </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszName</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new feature definition object to hold the field definitions. </p>
<p>The <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> maintains a reference count, but this starts at zero, and should normally be incremented by the owner.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#ab98552e676127d847582778d70b7e27b" title="Constructor.">OGRFeatureDefn::OGRFeatureDefn()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszName</em>&nbsp;</td><td>the name to be assigned to this layer/class. It does not need to be unique. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>handle to the newly created feature definition. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a8cbc5146fcab99667f021c40c714628c">OGR_FD_Create()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a8cbc5146fcab99667f021c40c714628c">OGR_FD_Create()</a>.</p>

</div>
</div>
<a class="anchor" id="a6283475163d911204f5ff45098c8479e"></a><!-- doxytag: member="ogr_api.h::OGR_FD_DeleteFieldDefn" ref="a6283475163d911204f5ff45098c8479e" args="(OGRFeatureDefnH hDefn, int iField)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_FD_DeleteFieldDefn </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iField</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete an existing field definition. </p>
<p>To delete an existing field definition from a layer definition, do not use this function directly, but use <a class="el" href="ogr__api_8h.html#afc861413683418eba5d31e487da2f9e2" title="Create a new field on a layer.">OGR_L_DeleteField()</a> instead.</p>
<p>This method should only be called while there are no <a class="el" href="classOGRFeature.html">OGRFeature</a> objects in existance based on this <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a>.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#ada48e1a3e90798bdccc2dd26f32f48cb" title="Delete an existing field definition.">OGRFeatureDefn::DeleteFieldDefn()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the feature definition. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iField</em>&nbsp;</td><td>the index of the field defintion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE in case of success. </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.9.0 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a6283475163d911204f5ff45098c8479e">OGR_FD_DeleteFieldDefn()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a6283475163d911204f5ff45098c8479e">OGR_FD_DeleteFieldDefn()</a>.</p>

</div>
</div>
<a class="anchor" id="a1fb650102be3837fc220b086b17f4462"></a><!-- doxytag: member="ogr_api.h::OGR_FD_DeleteGeomFieldDefn" ref="a1fb650102be3837fc220b086b17f4462" args="(OGRFeatureDefnH hFDefn, int iGeomField)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_FD_DeleteGeomFieldDefn </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iGeomField</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete an existing geometry field definition. </p>
<p>To delete an existing geometry field definition from a layer definition, do not use this function directly, but use OGR_L_DeleteGeomField() instead (*not implemented yet*)</p>
<p>This method should only be called while there are no <a class="el" href="classOGRFeature.html">OGRFeature</a> objects in existance based on this <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a>.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#a2c67a35c58cfd9ac384858d1b7b7ec48" title="Delete an existing geometry field definition.">OGRFeatureDefn::DeleteGeomFieldDefn()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the feature definition. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iGeomField</em>&nbsp;</td><td>the index of the geometry field defintion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE in case of success.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.11 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a1fb650102be3837fc220b086b17f4462">OGR_FD_DeleteGeomFieldDefn()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a1fb650102be3837fc220b086b17f4462">OGR_FD_DeleteGeomFieldDefn()</a>.</p>

</div>
</div>
<a class="anchor" id="a107635936c90c7f4347d7b3f9fb06e6d"></a><!-- doxytag: member="ogr_api.h::OGR_FD_Dereference" ref="a107635936c90c7f4347d7b3f9fb06e6d" args="(OGRFeatureDefnH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_FD_Dereference </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decrements the reference count by one. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#a87a280dd42634206dfbcfc47b1ecfea4" title="Decrements the reference count by one.">OGRFeatureDefn::Dereference()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the feature definition on witch <a class="el" href="classOGRFeature.html">OGRFeature</a> are based on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the updated reference count. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a107635936c90c7f4347d7b3f9fb06e6d">OGR_FD_Dereference()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a107635936c90c7f4347d7b3f9fb06e6d">OGR_FD_Dereference()</a>.</p>

</div>
</div>
<a class="anchor" id="a59d5cbb660cce8467a210caa4d68a011"></a><!-- doxytag: member="ogr_api.h::OGR_FD_Destroy" ref="a59d5cbb660cce8467a210caa4d68a011" args="(OGRFeatureDefnH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_FD_Destroy </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy a feature definition object and release all memory associated with it. </p>
<p>This function is the same as the C++ method OGRFeatureDefn::~OGRFeatureDefn().</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the feature definition to be destroyed. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#a59d5cbb660cce8467a210caa4d68a011">OGR_FD_Destroy()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a59d5cbb660cce8467a210caa4d68a011">OGR_FD_Destroy()</a>.</p>

</div>
</div>
<a class="anchor" id="a586a14271a457387a2b5c0097a02c8da"></a><!-- doxytag: member="ogr_api.h::OGR_FD_GetFieldCount" ref="a586a14271a457387a2b5c0097a02c8da" args="(OGRFeatureDefnH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_FD_GetFieldCount </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch number of fields on the passed feature definition. </p>
<p>This function is the same as the C++ <a class="el" href="classOGRFeatureDefn.html#ab400f9106e7544ebafa30b1fe59869b1" title="Fetch number of fields on this feature.">OGRFeatureDefn::GetFieldCount()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the feature definition to get the fields count from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>count of fields. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a586a14271a457387a2b5c0097a02c8da">OGR_FD_GetFieldCount()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a586a14271a457387a2b5c0097a02c8da">OGR_FD_GetFieldCount()</a>.</p>

</div>
</div>
<a class="anchor" id="a484456df86a01284769d0afe3beaa4f6"></a><!-- doxytag: member="ogr_api.h::OGR_FD_GetFieldDefn" ref="a484456df86a01284769d0afe3beaa4f6" args="(OGRFeatureDefnH, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRFieldDefnH OGR_FD_GetFieldDefn </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iField</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch field definition of the passed feature definition. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#a43b95ce699bbca73acb453cc959378e7" title="Fetch field definition.">OGRFeatureDefn::GetFieldDefn()</a>.</p>
<p>Starting with GDAL 1.7.0, this method will also issue an error if the index is not valid.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the feature definition to get the field definition from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iField</em>&nbsp;</td><td>the field to fetch, between 0 and GetFieldCount()-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an handle to an internal field definition object or NULL if invalid index. This object should not be modified or freed by the application. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a484456df86a01284769d0afe3beaa4f6">OGR_FD_GetFieldDefn()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a484456df86a01284769d0afe3beaa4f6">OGR_FD_GetFieldDefn()</a>.</p>

</div>
</div>
<a class="anchor" id="a1e54c3271dce0562209d78ae6eaae330"></a><!-- doxytag: member="ogr_api.h::OGR_FD_GetFieldIndex" ref="a1e54c3271dce0562209d78ae6eaae330" args="(OGRFeatureDefnH, const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_FD_GetFieldIndex </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszFieldName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find field by name. </p>
<p>The field index of the first field matching the passed field name (case insensitively) is returned.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#a4f7111e4c818f194932795e9c9593258" title="Find field by name.">OGRFeatureDefn::GetFieldIndex</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the feature definition to get field index from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszFieldName</em>&nbsp;</td><td>the field name to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the field index, or -1 if no match found. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a1e54c3271dce0562209d78ae6eaae330">OGR_FD_GetFieldIndex()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a1e54c3271dce0562209d78ae6eaae330">OGR_FD_GetFieldIndex()</a>.</p>

</div>
</div>
<a class="anchor" id="a0b34027b691ea40e20b911290f863303"></a><!-- doxytag: member="ogr_api.h::OGR_FD_GetGeomFieldCount" ref="a0b34027b691ea40e20b911290f863303" args="(OGRFeatureDefnH hFDefn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_FD_GetGeomFieldCount </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch number of geometry fields on the passed feature definition. </p>
<p>This function is the same as the C++ <a class="el" href="classOGRFeatureDefn.html#aa4a41bcd09868d325d214c28e17717eb" title="Fetch number of geometry fields on this feature.">OGRFeatureDefn::GetGeomFieldCount()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the feature definition to get the fields count from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>count of geometry fields.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.11 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a0b34027b691ea40e20b911290f863303">OGR_FD_GetGeomFieldCount()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a0b34027b691ea40e20b911290f863303">OGR_FD_GetGeomFieldCount()</a>.</p>

</div>
</div>
<a class="anchor" id="a82275ef1d2655817f6fe582f885c92c7"></a><!-- doxytag: member="ogr_api.h::OGR_FD_GetGeomFieldDefn" ref="a82275ef1d2655817f6fe582f885c92c7" args="(OGRFeatureDefnH hFDefn, int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRGeomFieldDefnH OGR_FD_GetGeomFieldDefn </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iGeomField</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch geometry field definition of the passed feature definition. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#acacca3de3718ae525565e5130b5474dc" title="Fetch geometry field definition.">OGRFeatureDefn::GetGeomFieldDefn()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the feature definition to get the field definition from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iGeomField</em>&nbsp;</td><td>the geometry field to fetch, between 0 and GetGeomFieldCount()-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an handle to an internal field definition object or NULL if invalid index. This object should not be modified or freed by the application.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.11 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a82275ef1d2655817f6fe582f885c92c7">OGR_FD_GetGeomFieldDefn()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a82275ef1d2655817f6fe582f885c92c7">OGR_FD_GetGeomFieldDefn()</a>.</p>

</div>
</div>
<a class="anchor" id="a69be97ea100c50bdaad8a1d3c30e7b14"></a><!-- doxytag: member="ogr_api.h::OGR_FD_GetGeomFieldIndex" ref="a69be97ea100c50bdaad8a1d3c30e7b14" args="(OGRFeatureDefnH hFDefn, const char *pszName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_FD_GetGeomFieldIndex </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszGeomFieldName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find geometry field by name. </p>
<p>The geometry field index of the first geometry field matching the passed field name (case insensitively) is returned.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#a2aaea18e9bcfee39cee05d616de6e12c" title="Find geometry field by name.">OGRFeatureDefn::GetGeomFieldIndex</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the feature definition to get field index from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszGeomFieldName</em>&nbsp;</td><td>the geometry field name to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the geometry field index, or -1 if no match found. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a69be97ea100c50bdaad8a1d3c30e7b14">OGR_FD_GetGeomFieldIndex()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a69be97ea100c50bdaad8a1d3c30e7b14">OGR_FD_GetGeomFieldIndex()</a>.</p>

</div>
</div>
<a class="anchor" id="add0b3a6b6062122e4f4316d194d2a1cf"></a><!-- doxytag: member="ogr_api.h::OGR_FD_GetGeomType" ref="add0b3a6b6062122e4f4316d194d2a1cf" args="(OGRFeatureDefnH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a> OGR_FD_GetGeomType </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch the geometry base type of the passed feature definition. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#a81a7dc7ed24fe9f2634bf447d1799e84" title="Fetch the geometry base type.">OGRFeatureDefn::GetGeomType()</a>.</p>
<p>Starting with GDAL 1.11, this method returns GetGeomFieldDefn(0)-&gt;GetType().</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the feature definition to get the geometry type from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the base type for all geometry related to this definition. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#add0b3a6b6062122e4f4316d194d2a1cf">OGR_FD_GetGeomType()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#add0b3a6b6062122e4f4316d194d2a1cf">OGR_FD_GetGeomType()</a>.</p>

</div>
</div>
<a class="anchor" id="a20f309bf10e5b76cc083848b710babb8"></a><!-- doxytag: member="ogr_api.h::OGR_FD_GetName" ref="a20f309bf10e5b76cc083848b710babb8" args="(OGRFeatureDefnH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_FD_GetName </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get name of the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> passed as an argument. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#a1efe6db724bb1c5fde13e5f3896e4a01" title="Get name of this OGRFeatureDefn.">OGRFeatureDefn::GetName()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the feature definition to get the name from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the name. This name is internal and should not be modified, or freed. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a20f309bf10e5b76cc083848b710babb8">OGR_FD_GetName()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a20f309bf10e5b76cc083848b710babb8">OGR_FD_GetName()</a>.</p>

</div>
</div>
<a class="anchor" id="a9e4e8867edeaf1a6f98e6ff284835811"></a><!-- doxytag: member="ogr_api.h::OGR_FD_GetReferenceCount" ref="a9e4e8867edeaf1a6f98e6ff284835811" args="(OGRFeatureDefnH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_FD_GetReferenceCount </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch current reference count. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#af28dd34d8e3ceee1cb1ba6798711b4e1" title="Fetch current reference count.">OGRFeatureDefn::GetReferenceCount()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the feature definition on witch <a class="el" href="classOGRFeature.html">OGRFeature</a> are based on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the current reference count. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a9e4e8867edeaf1a6f98e6ff284835811">OGR_FD_GetReferenceCount()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a9e4e8867edeaf1a6f98e6ff284835811">OGR_FD_GetReferenceCount()</a>.</p>

</div>
</div>
<a class="anchor" id="ad1208985f67db526136dbe74f490c8d3"></a><!-- doxytag: member="ogr_api.h::OGR_FD_IsGeometryIgnored" ref="ad1208985f67db526136dbe74f490c8d3" args="(OGRFeatureDefnH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_FD_IsGeometryIgnored </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine whether the geometry can be omitted when fetching features. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#a2a4888bec939c586e01f870bea1c09a6" title="Determine whether the geometry can be omitted when fetching features.">OGRFeatureDefn::IsGeometryIgnored()</a>.</p>
<p>Starting with GDAL 1.11, this method returns GetGeomFieldDefn(0)-&gt;IsIgnored().</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the feature definition on witch <a class="el" href="classOGRFeature.html">OGRFeature</a> are based on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>ignore state </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#ad1208985f67db526136dbe74f490c8d3">OGR_FD_IsGeometryIgnored()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ad1208985f67db526136dbe74f490c8d3">OGR_FD_IsGeometryIgnored()</a>.</p>

</div>
</div>
<a class="anchor" id="ab07056d514160c26724f3a2d5319185f"></a><!-- doxytag: member="ogr_api.h::OGR_FD_IsSame" ref="ab07056d514160c26724f3a2d5319185f" args="(OGRFeatureDefnH hFDefn, OGRFeatureDefnH hOtherFDefn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_FD_IsSame </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureDefnH&nbsp;</td>
          <td class="paramname"> <em>hFDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRFeatureDefnH&nbsp;</td>
          <td class="paramname"> <em>hOtherFDefn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if the feature definition is identical to the other one. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFDefn</em>&nbsp;</td><td>handle to the feature definition on witch <a class="el" href="classOGRFeature.html">OGRFeature</a> are based on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hOtherFDefn</em>&nbsp;</td><td>handle to the other feature definition to compare to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the feature definition is identical to the other one.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.11 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#ab07056d514160c26724f3a2d5319185f">OGR_FD_IsSame()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ab07056d514160c26724f3a2d5319185f">OGR_FD_IsSame()</a>.</p>

</div>
</div>
<a class="anchor" id="aa9490e3e5d25b780723ad3f0ab3302eb"></a><!-- doxytag: member="ogr_api.h::OGR_FD_IsStyleIgnored" ref="aa9490e3e5d25b780723ad3f0ab3302eb" args="(OGRFeatureDefnH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_FD_IsStyleIgnored </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine whether the style can be omitted when fetching features. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#a85b7c7e3f50a8519ef984dd36ac03c15" title="Determine whether the style can be omitted when fetching features.">OGRFeatureDefn::IsStyleIgnored()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the feature definition on which <a class="el" href="classOGRFeature.html">OGRFeature</a> are based on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>ignore state </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#aa9490e3e5d25b780723ad3f0ab3302eb">OGR_FD_IsStyleIgnored()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#aa9490e3e5d25b780723ad3f0ab3302eb">OGR_FD_IsStyleIgnored()</a>.</p>

</div>
</div>
<a class="anchor" id="a6763104e7fafcab1b52d9b0f275e19e8"></a><!-- doxytag: member="ogr_api.h::OGR_FD_Reference" ref="a6763104e7fafcab1b52d9b0f275e19e8" args="(OGRFeatureDefnH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_FD_Reference </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Increments the reference count by one. </p>
<p>The reference count is used keep track of the number of <a class="el" href="classOGRFeature.html">OGRFeature</a> objects referencing this definition.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#a2c58c6238242dff3d472faf5e3803922" title="Increments the reference count by one.">OGRFeatureDefn::Reference()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the feature definition on witch <a class="el" href="classOGRFeature.html">OGRFeature</a> are based on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the updated reference count. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a6763104e7fafcab1b52d9b0f275e19e8">OGR_FD_Reference()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a6763104e7fafcab1b52d9b0f275e19e8">OGR_FD_Reference()</a>.</p>

</div>
</div>
<a class="anchor" id="a0755b0360414095e15eaf2c1496f8c47"></a><!-- doxytag: member="ogr_api.h::OGR_FD_Release" ref="a0755b0360414095e15eaf2c1496f8c47" args="(OGRFeatureDefnH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_FD_Release </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Drop a reference, and destroy if unreferenced. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#a75e1424e3ce755d4393f5b42736d13ee" title="Drop a reference to this object, and destroy if no longer referenced.">OGRFeatureDefn::Release()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the feature definition to be released. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#a0755b0360414095e15eaf2c1496f8c47">OGR_FD_Release()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a0755b0360414095e15eaf2c1496f8c47">OGR_FD_Release()</a>.</p>

</div>
</div>
<a class="anchor" id="a1bbc85e1ba2378679e4ce6bf3523bf8e"></a><!-- doxytag: member="ogr_api.h::OGR_FD_SetGeometryIgnored" ref="a1bbc85e1ba2378679e4ce6bf3523bf8e" args="(OGRFeatureDefnH, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_FD_SetGeometryIgnored </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bIgnore</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set whether the geometry can be omitted when fetching features. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#a539b87cd1587dc928b246a211839e22a" title="Set whether the geometry can be omitted when fetching features.">OGRFeatureDefn::SetGeometryIgnored()</a>.</p>
<p>Starting with GDAL 1.11, this method calls GetGeomFieldDefn(0)-&gt;SetIgnored().</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the feature definition on witch <a class="el" href="classOGRFeature.html">OGRFeature</a> are based on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bIgnore</em>&nbsp;</td><td>ignore state </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#a1bbc85e1ba2378679e4ce6bf3523bf8e">OGR_FD_SetGeometryIgnored()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a1bbc85e1ba2378679e4ce6bf3523bf8e">OGR_FD_SetGeometryIgnored()</a>.</p>

</div>
</div>
<a class="anchor" id="a11ca3a84b54ac36c5f68a03821f1fa78"></a><!-- doxytag: member="ogr_api.h::OGR_FD_SetGeomType" ref="a11ca3a84b54ac36c5f68a03821f1fa78" args="(OGRFeatureDefnH, OGRwkbGeometryType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_FD_SetGeomType </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&nbsp;</td>
          <td class="paramname"> <em>eType</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assign the base geometry type for the passed layer (the same as the feature definition). </p>
<p>All geometry objects using this type must be of the defined type or a derived type. The default upon creation is wkbUnknown which allows for any geometry type. The geometry type should generally not be changed after any OGRFeatures have been created against this definition.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#aa0f50b39efbba6559a510d7afcfa5efb" title="Assign the base geometry type for this layer.">OGRFeatureDefn::SetGeomType()</a>.</p>
<p>Starting with GDAL 1.11, this method calls GetGeomFieldDefn(0)-&gt;SetType().</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the layer or feature definition to set the geometry type to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eType</em>&nbsp;</td><td>the new type to assign. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#a11ca3a84b54ac36c5f68a03821f1fa78">OGR_FD_SetGeomType()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a11ca3a84b54ac36c5f68a03821f1fa78">OGR_FD_SetGeomType()</a>.</p>

</div>
</div>
<a class="anchor" id="a6c09218e9ef9e49abcdd0b76858a514b"></a><!-- doxytag: member="ogr_api.h::OGR_FD_SetStyleIgnored" ref="a6c09218e9ef9e49abcdd0b76858a514b" args="(OGRFeatureDefnH, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_FD_SetStyleIgnored </td>
          <td>(</td>
          <td class="paramtype">OGRFeatureDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bIgnore</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set whether the style can be omitted when fetching features. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#a18e45edc2008f3a73e8bf4fed39fddd9" title="Set whether the style can be omitted when fetching features.">OGRFeatureDefn::SetStyleIgnored()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the feature definition on witch <a class="el" href="classOGRFeature.html">OGRFeature</a> are based on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bIgnore</em>&nbsp;</td><td>ignore state </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#a6c09218e9ef9e49abcdd0b76858a514b">OGR_FD_SetStyleIgnored()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a6c09218e9ef9e49abcdd0b76858a514b">OGR_FD_SetStyleIgnored()</a>.</p>

</div>
</div>
<a class="anchor" id="a24af159359797a83c354fdf6cced3265"></a><!-- doxytag: member="ogr_api.h::OGR_Fld_Create" ref="a24af159359797a83c354fdf6cced3265" args="(const char *, OGRFieldType) CPL_WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRFieldDefnH OGR_Fld_Create </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a>&nbsp;</td>
          <td class="paramname"> <em>eType</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new field definition. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#afc375f038b548b5a86b854c214fee114" title="Constructor.">OGRFieldDefn::OGRFieldDefn()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszName</em>&nbsp;</td><td>the name of the new field definition. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eType</em>&nbsp;</td><td>the type of the new field definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>handle to the new field definition. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a24af159359797a83c354fdf6cced3265">OGR_Fld_Create()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a24af159359797a83c354fdf6cced3265">OGR_Fld_Create()</a>.</p>

</div>
</div>
<a class="anchor" id="a455fa4a2c2451b1748facb6b7126a822"></a><!-- doxytag: member="ogr_api.h::OGR_Fld_Destroy" ref="a455fa4a2c2451b1748facb6b7126a822" args="(OGRFieldDefnH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_Fld_Destroy </td>
          <td>(</td>
          <td class="paramtype">OGRFieldDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy a field definition. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the field definition to destroy. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#a455fa4a2c2451b1748facb6b7126a822">OGR_Fld_Destroy()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a455fa4a2c2451b1748facb6b7126a822">OGR_Fld_Destroy()</a>.</p>

</div>
</div>
<a class="anchor" id="a0cf8a09826e47763e6bf667af0dae1a7"></a><!-- doxytag: member="ogr_api.h::OGR_Fld_GetJustify" ref="a0cf8a09826e47763e6bf667af0dae1a7" args="(OGRFieldDefnH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a701976be938cd60a2fa96454f61d3600">OGRJustification</a> OGR_Fld_GetJustify </td>
          <td>(</td>
          <td class="paramtype">OGRFieldDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the justification for this field. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#a40f6520b0638571f8acf32b2c436231f" title="Get the justification for this field.">OGRFieldDefn::GetJustify()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the field definition to get justification from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the justification. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a0cf8a09826e47763e6bf667af0dae1a7">OGR_Fld_GetJustify()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a0cf8a09826e47763e6bf667af0dae1a7">OGR_Fld_GetJustify()</a>.</p>

</div>
</div>
<a class="anchor" id="a8d7640a6b6a47a95d83415f9271ffe30"></a><!-- doxytag: member="ogr_api.h::OGR_Fld_GetNameRef" ref="a8d7640a6b6a47a95d83415f9271ffe30" args="(OGRFieldDefnH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_Fld_GetNameRef </td>
          <td>(</td>
          <td class="paramtype">OGRFieldDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch name of this field. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#a7754d32a36e4ba854f71f511a5ca7740" title="Fetch name of this field.">OGRFieldDefn::GetNameRef()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the field definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the name of the field definition. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a8d7640a6b6a47a95d83415f9271ffe30">OGR_Fld_GetNameRef()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a8d7640a6b6a47a95d83415f9271ffe30">OGR_Fld_GetNameRef()</a>.</p>

</div>
</div>
<a class="anchor" id="a120dd56ee23070922e4d84ed06b06e27"></a><!-- doxytag: member="ogr_api.h::OGR_Fld_GetPrecision" ref="a120dd56ee23070922e4d84ed06b06e27" args="(OGRFieldDefnH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_Fld_GetPrecision </td>
          <td>(</td>
          <td class="paramtype">OGRFieldDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the formatting precision for this field. This should normally be zero for fields of types other than OFTReal. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#a704a3aa995e9ee44b369aff7f1e065a5" title="Get the formatting precision for this field. This should normally be zero for fields of types other t...">OGRFieldDefn::GetPrecision()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the field definition to get precision from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the precision. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a120dd56ee23070922e4d84ed06b06e27">OGR_Fld_GetPrecision()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a120dd56ee23070922e4d84ed06b06e27">OGR_Fld_GetPrecision()</a>.</p>

</div>
</div>
<a class="anchor" id="ad8d150dfc678e0a2a7f5241ba38c5611"></a><!-- doxytag: member="ogr_api.h::OGR_Fld_GetType" ref="ad8d150dfc678e0a2a7f5241ba38c5611" args="(OGRFieldDefnH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a> OGR_Fld_GetType </td>
          <td>(</td>
          <td class="paramtype">OGRFieldDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch type of this field. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#ac59789eed0b750d05f8ce8b6a8c68dfb" title="Fetch type of this field.">OGRFieldDefn::GetType()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the field definition to get type from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>field type. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#ad8d150dfc678e0a2a7f5241ba38c5611">OGR_Fld_GetType()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ad8d150dfc678e0a2a7f5241ba38c5611">OGR_Fld_GetType()</a>.</p>

</div>
</div>
<a class="anchor" id="aa6500186e3f22761a615428c55bba0ce"></a><!-- doxytag: member="ogr_api.h::OGR_Fld_GetWidth" ref="aa6500186e3f22761a615428c55bba0ce" args="(OGRFieldDefnH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_Fld_GetWidth </td>
          <td>(</td>
          <td class="paramtype">OGRFieldDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the formatting width for this field. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#a3aca8d59291beed0ccfe2e05a187bcb1" title="Get the formatting width for this field.">OGRFieldDefn::GetWidth()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the field definition to get width from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the width, zero means no specified width. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#aa6500186e3f22761a615428c55bba0ce">OGR_Fld_GetWidth()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#aa6500186e3f22761a615428c55bba0ce">OGR_Fld_GetWidth()</a>.</p>

</div>
</div>
<a class="anchor" id="a29bec35ae5a4c232ad850315bdc2b675"></a><!-- doxytag: member="ogr_api.h::OGR_Fld_IsIgnored" ref="a29bec35ae5a4c232ad850315bdc2b675" args="(OGRFieldDefnH hDefn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_Fld_IsIgnored </td>
          <td>(</td>
          <td class="paramtype">OGRFieldDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return whether this field should be omitted when fetching features. </p>
<p>This method is the same as the C++ method <a class="el" href="classOGRFieldDefn.html#a7cdd15cda075af9fd4178b927743aa07" title="Return whether this field should be omitted when fetching features.">OGRFieldDefn::IsIgnored()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the field definition </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>ignore state </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a29bec35ae5a4c232ad850315bdc2b675">OGR_Fld_IsIgnored()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a29bec35ae5a4c232ad850315bdc2b675">OGR_Fld_IsIgnored()</a>.</p>

</div>
</div>
<a class="anchor" id="a5922e599fe8746b81adf251be6b5ecf0"></a><!-- doxytag: member="ogr_api.h::OGR_Fld_Set" ref="a5922e599fe8746b81adf251be6b5ecf0" args="(OGRFieldDefnH, const char *, OGRFieldType, int, int, OGRJustification)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_Fld_Set </td>
          <td>(</td>
          <td class="paramtype">OGRFieldDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszNameIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a>&nbsp;</td>
          <td class="paramname"> <em>eTypeIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nWidthIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nPrecisionIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a701976be938cd60a2fa96454f61d3600">OGRJustification</a>&nbsp;</td>
          <td class="paramname"> <em>eJustifyIn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set defining parameters for a field in one call. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#a9b08b348f111ecbfe2970b312d9ce54b" title="Set defining parameters for a field in one call.">OGRFieldDefn::Set()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the field definition to set to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszNameIn</em>&nbsp;</td><td>the new name to assign. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eTypeIn</em>&nbsp;</td><td>the new type (one of the OFT values like OFTInteger). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nWidthIn</em>&nbsp;</td><td>the preferred formatting width. Defaults to zero indicating undefined. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nPrecisionIn</em>&nbsp;</td><td>number of decimals places for formatting, defaults to zero indicating undefined. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eJustifyIn</em>&nbsp;</td><td>the formatting justification (OJLeft or OJRight), defaults to OJUndefined. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#a5922e599fe8746b81adf251be6b5ecf0">OGR_Fld_Set()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a5922e599fe8746b81adf251be6b5ecf0">OGR_Fld_Set()</a>.</p>

</div>
</div>
<a class="anchor" id="aeddf9aa9767cd28c90dc66ed2a7a7332"></a><!-- doxytag: member="ogr_api.h::OGR_Fld_SetIgnored" ref="aeddf9aa9767cd28c90dc66ed2a7a7332" args="(OGRFieldDefnH hDefn, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_Fld_SetIgnored </td>
          <td>(</td>
          <td class="paramtype">OGRFieldDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ignore</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set whether this field should be omitted when fetching features. </p>
<p>This method is the same as the C++ method <a class="el" href="classOGRFieldDefn.html#ad194ad748a62ec40b772a7ded173c367" title="Set whether this field should be omitted when fetching features.">OGRFieldDefn::SetIgnored()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the field definition </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ignore</em>&nbsp;</td><td>ignore state </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#aeddf9aa9767cd28c90dc66ed2a7a7332">OGR_Fld_SetIgnored()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#aeddf9aa9767cd28c90dc66ed2a7a7332">OGR_Fld_SetIgnored()</a>.</p>

</div>
</div>
<a class="anchor" id="ae4809f2fe957002b8e18aacc1bdca240"></a><!-- doxytag: member="ogr_api.h::OGR_Fld_SetJustify" ref="ae4809f2fe957002b8e18aacc1bdca240" args="(OGRFieldDefnH, OGRJustification)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_Fld_SetJustify </td>
          <td>(</td>
          <td class="paramtype">OGRFieldDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a701976be938cd60a2fa96454f61d3600">OGRJustification</a>&nbsp;</td>
          <td class="paramname"> <em>eJustify</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the justification for this field. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#acbd783e3b61ab388eab3f45c25cf1bc0" title="Set the justification for this field.">OGRFieldDefn::SetJustify()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the field definition to set justification to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eJustify</em>&nbsp;</td><td>the new justification. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#ae4809f2fe957002b8e18aacc1bdca240">OGR_Fld_SetJustify()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ae4809f2fe957002b8e18aacc1bdca240">OGR_Fld_SetJustify()</a>.</p>

</div>
</div>
<a class="anchor" id="a6599fa42bad3aba26574ae3260c6984d"></a><!-- doxytag: member="ogr_api.h::OGR_Fld_SetName" ref="a6599fa42bad3aba26574ae3260c6984d" args="(OGRFieldDefnH, const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_Fld_SetName </td>
          <td>(</td>
          <td class="paramtype">OGRFieldDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset the name of this field. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#a241585cd66a38311aa0322f34e6d5214" title="Reset the name of this field.">OGRFieldDefn::SetName()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the field definition to apply the new name to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszName</em>&nbsp;</td><td>the new name to apply. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#a6599fa42bad3aba26574ae3260c6984d">OGR_Fld_SetName()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a6599fa42bad3aba26574ae3260c6984d">OGR_Fld_SetName()</a>.</p>

</div>
</div>
<a class="anchor" id="a13890f01f7d7e57bcd07e23f3e2947da"></a><!-- doxytag: member="ogr_api.h::OGR_Fld_SetPrecision" ref="a13890f01f7d7e57bcd07e23f3e2947da" args="(OGRFieldDefnH, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_Fld_SetPrecision </td>
          <td>(</td>
          <td class="paramtype">OGRFieldDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nPrecision</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the formatting precision for this field in characters. </p>
<p>This should normally be zero for fields of types other than OFTReal.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#abea88d3ed96c46b4f0eda415460f8664" title="Set the formatting precision for this field in characters.">OGRFieldDefn::SetPrecision()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the field definition to set precision to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nPrecision</em>&nbsp;</td><td>the new precision. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#a13890f01f7d7e57bcd07e23f3e2947da">OGR_Fld_SetPrecision()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a13890f01f7d7e57bcd07e23f3e2947da">OGR_Fld_SetPrecision()</a>.</p>

</div>
</div>
<a class="anchor" id="a76195990f814eb93e821c01ce0599a50"></a><!-- doxytag: member="ogr_api.h::OGR_Fld_SetType" ref="a76195990f814eb93e821c01ce0599a50" args="(OGRFieldDefnH, OGRFieldType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_Fld_SetType </td>
          <td>(</td>
          <td class="paramtype">OGRFieldDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a>&nbsp;</td>
          <td class="paramname"> <em>eType</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the type of this field. This should never be done to an <a class="el" href="classOGRFieldDefn.html">OGRFieldDefn</a> that is already part of an <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a>. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#a26bf22b7d805b9e33dd5c5fe9b4a8363" title="Set the type of this field. This should never be done to an OGRFieldDefn that is already part of an O...">OGRFieldDefn::SetType()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the field definition to set type to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eType</em>&nbsp;</td><td>the new field type. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#a76195990f814eb93e821c01ce0599a50">OGR_Fld_SetType()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a76195990f814eb93e821c01ce0599a50">OGR_Fld_SetType()</a>.</p>

</div>
</div>
<a class="anchor" id="a1d7bf7c14a299448efac58f7bf364326"></a><!-- doxytag: member="ogr_api.h::OGR_Fld_SetWidth" ref="a1d7bf7c14a299448efac58f7bf364326" args="(OGRFieldDefnH, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_Fld_SetWidth </td>
          <td>(</td>
          <td class="paramtype">OGRFieldDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nNewWidth</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the formatting width for this field in characters. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#aa793194c45ccba5ec7e9f7aea49dc6f3" title="Set the formatting width for this field in characters.">OGRFieldDefn::SetWidth()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the field definition to set width to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nNewWidth</em>&nbsp;</td><td>the new width. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#a1d7bf7c14a299448efac58f7bf364326">OGR_Fld_SetWidth()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a1d7bf7c14a299448efac58f7bf364326">OGR_Fld_SetWidth()</a>.</p>

</div>
</div>
<a class="anchor" id="a4a15e130614cb4c66fc99bb93dc6b3b5"></a><!-- doxytag: member="ogr_api.h::OGR_G_AddGeometry" ref="a4a15e130614cb4c66fc99bb93dc6b3b5" args="(OGRGeometryH, OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_G_AddGeometry </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hNewSubGeom</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a geometry to a geometry container. </p>
<p>Some subclasses of <a class="el" href="classOGRGeometryCollection.html">OGRGeometryCollection</a> restrict the types of geometry that can be added, and may return an error. The passed geometry is cloned to make an internal copy.</p>
<p>There is no SFCOM analog to this method.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometryCollection.html#a3da519655d14346e591d22a547562b0c" title="Add a geometry to the container.">OGRGeometryCollection::addGeometry</a>.</p>
<p>For a polygon, hNewSubGeom must be a linearring. If the polygon is empty, the first added subgeometry will be the exterior ring. The next ones will be the interior rings.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>existing geometry container. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hNewSubGeom</em>&nbsp;</td><td>geometry to add to the container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE if successful, or OGRERR_UNSUPPORTED_GEOMETRY_TYPE if the geometry type is illegal for the type of existing geometry. </dd></dl>

<p>References <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa7f299e8edaee30fd3c7a40baf19b48b1">wkbGeometryCollection</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa2ecf4d40ab038779cbc1de22ddcb3429">wkbMultiLineString</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa826c812d3551fa07feb4c3664517c29c">wkbMultiPoint</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa7ff2322e0696d383d7715b7e7be1a7b1">wkbMultiPolygon</a>, and <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa11991cd1245f146f3efd694553433aeb">wkbPolygon</a>.</p>

</div>
</div>
<a class="anchor" id="aff56cae8305396a9c5b690d8356e39c9"></a><!-- doxytag: member="ogr_api.h::OGR_G_AddGeometryDirectly" ref="aff56cae8305396a9c5b690d8356e39c9" args="(OGRGeometryH, OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_G_AddGeometryDirectly </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hNewSubGeom</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a geometry directly to an existing geometry container. </p>
<p>Some subclasses of <a class="el" href="classOGRGeometryCollection.html">OGRGeometryCollection</a> restrict the types of geometry that can be added, and may return an error. Ownership of the passed geometry is taken by the container rather than cloning as addGeometry() does.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometryCollection.html#a8422907a01d088ec5ef916382bea8eb3" title="Add a geometry directly to the container.">OGRGeometryCollection::addGeometryDirectly</a>.</p>
<p>There is no SFCOM analog to this method.</p>
<p>For a polygon, hNewSubGeom must be a linearring. If the polygon is empty, the first added subgeometry will be the exterior ring. The next ones will be the interior rings.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>existing geometry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hNewSubGeom</em>&nbsp;</td><td>geometry to add to the existing geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE if successful, or OGRERR_UNSUPPORTED_GEOMETRY_TYPE if the geometry type is illegal for the type of geometry container. </dd></dl>

<p>References <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa7f299e8edaee30fd3c7a40baf19b48b1">wkbGeometryCollection</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa2ecf4d40ab038779cbc1de22ddcb3429">wkbMultiLineString</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa826c812d3551fa07feb4c3664517c29c">wkbMultiPoint</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa7ff2322e0696d383d7715b7e7be1a7b1">wkbMultiPolygon</a>, and <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa11991cd1245f146f3efd694553433aeb">wkbPolygon</a>.</p>

</div>
</div>
<a class="anchor" id="aa2702d812663bc767e3a8f8832fda089"></a><!-- doxytag: member="ogr_api.h::OGR_G_AddPoint" ref="aa2702d812663bc767e3a8f8832fda089" args="(OGRGeometryH, double, double, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_AddPoint </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfZ</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a point to a geometry (line string or point). </p>
<p>The vertex count of the line string is increased by one, and assigned from the passed location value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle to the geometry to add a point to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfX</em>&nbsp;</td><td>x coordinate of point to add. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfY</em>&nbsp;</td><td>y coordinate of point to add. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfZ</em>&nbsp;</td><td>z coordinate of point to add. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa09fd8f51759a1cf351b04e786a2a9058">wkbLineString</a>, and <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa6f8377c5a4a9d36ae2384f4a5f45d77f">wkbPoint</a>.</p>

</div>
</div>
<a class="anchor" id="a280275c1492d6426cfe0a918d4725374"></a><!-- doxytag: member="ogr_api.h::OGR_G_AddPoint_2D" ref="a280275c1492d6426cfe0a918d4725374" args="(OGRGeometryH, double, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_AddPoint_2D </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfY</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a point to a geometry (line string or point). </p>
<p>The vertex count of the line string is increased by one, and assigned from the passed location value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle to the geometry to add a point to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfX</em>&nbsp;</td><td>x coordinate of point to add. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfY</em>&nbsp;</td><td>y coordinate of point to add. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa09fd8f51759a1cf351b04e786a2a9058">wkbLineString</a>, and <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa6f8377c5a4a9d36ae2384f4a5f45d77f">wkbPoint</a>.</p>

</div>
</div>
<a class="anchor" id="a7c9ee71d0030dc30bdd595c37ab71062"></a><!-- doxytag: member="ogr_api.h::OGR_G_ApproximateArcAngles" ref="a7c9ee71d0030dc30bdd595c37ab71062" args="(double dfCenterX, double dfCenterY, double dfZ, double dfPrimaryRadius, double dfSecondaryAxis, double dfRotation, double dfStartAngle, double dfEndAngle, double dfMaxAngleStepSizeDegrees)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRGeometryH OGR_G_ApproximateArcAngles </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfCenterX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfCenterY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfPrimaryRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfSecondaryRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfRotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfStartAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfEndAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfMaxAngleStepSizeDegrees</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stroke arc to linestring.</p>
<p>Stroke an arc of a circle to a linestring based on a center point, radius, start angle and end angle, all angles in degrees.</p>
<p>If the dfMaxAngleStepSizeDegrees is zero, then a default value will be used. This is currently 4 degrees unless the user has overridden the value with the OGR_ARC_STEPSIZE configuration variable.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cpl__conv_8h.html#aa0cd1a68fe4f2fc7874cd2da605c36ce">CPLSetConfigOption()</a></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dfCenterX</em>&nbsp;</td><td>center X </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfCenterY</em>&nbsp;</td><td>center Y </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfZ</em>&nbsp;</td><td>center Z </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfPrimaryRadius</em>&nbsp;</td><td>X radius of ellipse. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfSecondaryRadius</em>&nbsp;</td><td>Y radius of ellipse. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfRotation</em>&nbsp;</td><td>rotation of the ellipse clockwise. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfStartAngle</em>&nbsp;</td><td>angle to first point on arc (clockwise of X-positive) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfEndAngle</em>&nbsp;</td><td>angle to last point on arc (clockwise of X-positive) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfMaxAngleStepSizeDegrees</em>&nbsp;</td><td>the largest step in degrees along the arc, zero to use the default setting.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classOGRLineString.html">OGRLineString</a> geometry representing an approximation of the arc.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.8.0 </dd></dl>

<p>References <a class="el" href="classOGRGeometryFactory.html#a3b8d418c534cc7d909d706b4483316ae">OGRGeometryFactory::approximateArcAngles()</a>, and <a class="el" href="ogr__api_8h.html#a7c9ee71d0030dc30bdd595c37ab71062">OGR_G_ApproximateArcAngles()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a7c9ee71d0030dc30bdd595c37ab71062">OGR_G_ApproximateArcAngles()</a>.</p>

</div>
</div>
<a class="anchor" id="a2a849c584cd22a199bcfb9b34b9a1a8f"></a><!-- doxytag: member="ogr_api.h::OGR_G_Area" ref="a2a849c584cd22a199bcfb9b34b9a1a8f" args="(OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGR_G_Area </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute geometry area. </p>
<p>Computes the area for an <a class="el" href="classOGRLinearRing.html">OGRLinearRing</a>, <a class="el" href="classOGRPolygon.html">OGRPolygon</a> or <a class="el" href="classOGRMultiPolygon.html">OGRMultiPolygon</a>. Undefined for all other geometry types (returns zero).</p>
<p>This function utilizes the C++ get_Area() methods such as <a class="el" href="classOGRPolygon.html#ad8ba9b796aafc593f5bd7bcf1086bc3d" title="Compute area of polygon.">OGRPolygon::get_Area()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>the geometry to operate on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the area or 0.0 for unsupported geometry types.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.8.0 </dd></dl>

<p>References <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa7f299e8edaee30fd3c7a40baf19b48b1">wkbGeometryCollection</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa48a515899277ce8ccd0bb6041fd42bcc">wkbLinearRing</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa09fd8f51759a1cf351b04e786a2a9058">wkbLineString</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa7ff2322e0696d383d7715b7e7be1a7b1">wkbMultiPolygon</a>, and <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa11991cd1245f146f3efd694553433aeb">wkbPolygon</a>.</p>

</div>
</div>
<a class="anchor" id="a4dfbd5861e1cd20b372d090539fa4536"></a><!-- doxytag: member="ogr_api.h::OGR_G_AssignSpatialReference" ref="a4dfbd5861e1cd20b372d090539fa4536" args="(OGRGeometryH, OGRSpatialReferenceH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_AssignSpatialReference </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRSpatialReferenceH&nbsp;</td>
          <td class="paramname"> <em>hSRS</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assign spatial reference to this object. </p>
<p>Any existing spatial reference is replaced, but under no circumstances does this result in the object being reprojected. It is just changing the interpretation of the existing geometry. Note that assigning a spatial reference increments the reference count on the <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a>, but does not copy it.</p>
<p>This is similar to the SFCOM IGeometry::put_SpatialReference() method.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#a4308e3549c65aa12cc2ba41be15d99a0" title="Assign spatial reference to this object.">OGRGeometry::assignSpatialReference</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle on the geometry to apply the new spatial reference system. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hSRS</em>&nbsp;</td><td>handle on the new spatial reference system to apply. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#a4dfbd5861e1cd20b372d090539fa4536">OGR_G_AssignSpatialReference()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a4dfbd5861e1cd20b372d090539fa4536">OGR_G_AssignSpatialReference()</a>.</p>

</div>
</div>
<a class="anchor" id="a95447f722f907b7143a1fc19005dd20b"></a><!-- doxytag: member="ogr_api.h::OGR_G_Boundary" ref="a95447f722f907b7143a1fc19005dd20b" args="(OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRGeometryH OGR_G_Boundary </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hTarget</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute boundary. </p>
<p>A new geometry object is created and returned containing the boundary of the geometry on which the method is invoked.</p>
<p>This function is the same as the C++ method <a class="el" href="ogr__api_8h.html#a95447f722f907b7143a1fc19005dd20b" title="Compute boundary.">OGR_G_Boundary()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hTarget</em>&nbsp;</td><td>The Geometry to calculate the boundary of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a handle to a newly allocated geometry now owned by the caller, or NULL on failure.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.8.0 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a95447f722f907b7143a1fc19005dd20b">OGR_G_Boundary()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a95447f722f907b7143a1fc19005dd20b">OGR_G_Boundary()</a>.</p>

</div>
</div>
<a class="anchor" id="a1ca0bd5c0fcb4b1af3c3973e467b0ec0"></a><!-- doxytag: member="ogr_api.h::OGR_G_Buffer" ref="a1ca0bd5c0fcb4b1af3c3973e467b0ec0" args="(OGRGeometryH, double, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRGeometryH OGR_G_Buffer </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nQuadSegs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute buffer of geometry. </p>
<p>Builds a new geometry containing the buffer region around the geometry on which it is invoked. The buffer is a polygon containing the region within the buffer distance of the original geometry.</p>
<p>Some buffer sections are properly described as curves, but are converted to approximate polygons. The nQuadSegs parameter can be used to control how many segements should be used to define a 90 degree curve - a quadrant of a circle. A value of 30 is a reasonable default. Large values result in large numbers of vertices in the resulting buffer geometry while small numbers reduce the accuracy of the result.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#ab34b27e2c8812a0fc1dccf055b11d1a2" title="Compute buffer of geometry.">OGRGeometry::Buffer()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hTarget</em>&nbsp;</td><td>the geometry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfDist</em>&nbsp;</td><td>the buffer distance to be applied. Should be expressed into the same unit as the coordinates of the geometry.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nQuadSegs</em>&nbsp;</td><td>the number of segments used to approximate a 90 degree (quadrant) of curvature.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly created geometry, or NULL if an error occurs. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a1ca0bd5c0fcb4b1af3c3973e467b0ec0">OGR_G_Buffer()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a1ca0bd5c0fcb4b1af3c3973e467b0ec0">OGR_G_Buffer()</a>.</p>

</div>
</div>
<a class="anchor" id="a23f5a19a81628af7f9cc59a37378cb2b"></a><!-- doxytag: member="ogr_api.h::OGR_G_Centroid" ref="a23f5a19a81628af7f9cc59a37378cb2b" args="(OGRGeometryH, OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_Centroid </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hCentroidPoint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the geometry centroid. </p>
<p>The centroid location is applied to the passed in <a class="el" href="classOGRPoint.html">OGRPoint</a> object. The centroid is not necessarily within the geometry.</p>
<p>This method relates to the SFCOM ISurface::get_Centroid() method however the current implementation based on GEOS can operate on other geometry types such as multipoint, linestring, geometrycollection such as multipolygons. OGC SF SQL 1.1 defines the operation for surfaces (polygons). SQL/MM-Part 3 defines the operation for surfaces and multisurfaces (multipolygons).</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#abc2cba699382fbb6a45229e4f5f6e792" title="Compute the geometry centroid.">OGRGeometry::Centroid()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE on success or OGRERR_FAILURE on error. </dd></dl>

<p>References <a class="el" href="classOGRGeometry.html#abc2cba699382fbb6a45229e4f5f6e792">OGRGeometry::Centroid()</a>, <a class="el" href="classOGRPoint.html#a0629a8049b94f9ad86939ba0c7a40bed">OGRPoint::getGeometryType()</a>, <a class="el" href="ogr__api_8h.html#a23f5a19a81628af7f9cc59a37378cb2b">OGR_G_Centroid()</a>, and <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa6f8377c5a4a9d36ae2384f4a5f45d77f">wkbPoint</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a23f5a19a81628af7f9cc59a37378cb2b">OGR_G_Centroid()</a>.</p>

</div>
</div>
<a class="anchor" id="a1725918932da7d59f9ee72829ac171fa"></a><!-- doxytag: member="ogr_api.h::OGR_G_Clone" ref="a1725918932da7d59f9ee72829ac171fa" args="(OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRGeometryH OGR_G_Clone </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a copy of this object. </p>
<p>This function relates to the SFCOM IGeometry::clone() method.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#af4cf9f6eee1997268a481b39401c3161" title="Make a copy of this object.">OGRGeometry::clone()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle on the geometry to clone from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an handle on the copy of the geometry with the spatial reference system as the original. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a1725918932da7d59f9ee72829ac171fa">OGR_G_Clone()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a1725918932da7d59f9ee72829ac171fa">OGR_G_Clone()</a>.</p>

</div>
</div>
<a class="anchor" id="acfeb849dcfd4fdf4d6dab66e6ea697c0"></a><!-- doxytag: member="ogr_api.h::OGR_G_CloseRings" ref="acfeb849dcfd4fdf4d6dab66e6ea697c0" args="(OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_CloseRings </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Force rings to be closed. </p>
<p>If this geometry, or any contained geometries has polygon rings that are not closed, they will be closed by adding the starting point at the end.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle to the geometry. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#acfeb849dcfd4fdf4d6dab66e6ea697c0">OGR_G_CloseRings()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#acfeb849dcfd4fdf4d6dab66e6ea697c0">OGR_G_CloseRings()</a>.</p>

</div>
</div>
<a class="anchor" id="ad87e37380f0320faddbe5e67e23312f8"></a><!-- doxytag: member="ogr_api.h::OGR_G_Contains" ref="ad87e37380f0320faddbe5e67e23312f8" args="(OGRGeometryH, OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_Contains </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hOther</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test for containment. </p>
<p>Tests if this geometry contains the other geometry.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a5e2c9296c75521ec8aff5bc2285c347f" title="Test for containment.">OGRGeometry::Contains()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hThis</em>&nbsp;</td><td>the geometry to compare. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hOther</em>&nbsp;</td><td>the other geometry to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if hThis contains hOther geometry, otherwise FALSE. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#ad87e37380f0320faddbe5e67e23312f8">OGR_G_Contains()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ad87e37380f0320faddbe5e67e23312f8">OGR_G_Contains()</a>.</p>

</div>
</div>
<a class="anchor" id="a7a93026cfae8ee6ce25546dba1b2df7d"></a><!-- doxytag: member="ogr_api.h::OGR_G_ConvexHull" ref="a7a93026cfae8ee6ce25546dba1b2df7d" args="(OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRGeometryH OGR_G_ConvexHull </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hTarget</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute convex hull. </p>
<p>A new geometry object is created and returned containing the convex hull of the geometry on which the method is invoked.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#ac906abd9b1cd9dd2b208a10c6e9d1bf0" title="Compute convex hull.">OGRGeometry::ConvexHull()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hTarget</em>&nbsp;</td><td>The Geometry to calculate the convex hull of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a handle to a newly allocated geometry now owned by the caller, or NULL on failure. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a7a93026cfae8ee6ce25546dba1b2df7d">OGR_G_ConvexHull()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a7a93026cfae8ee6ce25546dba1b2df7d">OGR_G_ConvexHull()</a>.</p>

</div>
</div>
<a class="anchor" id="aef37aa4d89f303fee679f97d32461d69"></a><!-- doxytag: member="ogr_api.h::OGR_G_CreateFromGML" ref="aef37aa4d89f303fee679f97d32461d69" args="(const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRGeometryH OGR_G_CreateFromGML </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszGML</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create geometry from GML. </p>
<p>This method translates a fragment of GML containing only the geometry portion into a corresponding <a class="el" href="classOGRGeometry.html">OGRGeometry</a>. There are many limitations on the forms of GML geometries supported by this parser, but they are too numerous to list here.</p>
<p>The following GML2 elements are parsed : Point, LineString, Polygon, MultiPoint, MultiLineString, MultiPolygon, MultiGeometry.</p>
<p>(OGR &gt;= 1.8.0) The following GML3 elements are parsed : Surface, MultiSurface, PolygonPatch, Triangle, Rectangle, Curve, MultiCurve, CompositeCurve, LineStringSegment, Arc, Circle, CompositeSurface, OrientableSurface, Solid, Tin, TriangulatedSurface.</p>
<p>Arc and Circle elements are stroked to linestring, by using a 4 degrees step, unless the user has overridden the value with the OGR_ARC_STEPSIZE configuration variable.</p>
<p>The C++ method <a class="el" href="classOGRGeometryFactory.html#af8714df4e6b6c5d5b2cdbdeec78af08c" title="Create geometry from GML.">OGRGeometryFactory::createFromGML()</a> is the same as this function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszGML</em>&nbsp;</td><td>The GML fragment for the geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a geometry on succes, or NULL on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a3172c8e5b8a094b8ce97fa5d44bcd204"></a><!-- doxytag: member="ogr_api.h::OGR_G_CreateFromWkb" ref="a3172c8e5b8a094b8ce97fa5d44bcd204" args="(unsigned char *, OGRSpatialReferenceH, OGRGeometryH *, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_G_CreateFromWkb </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>pabyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRSpatialReferenceH&nbsp;</td>
          <td class="paramname"> <em>hSRS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRGeometryH *&nbsp;</td>
          <td class="paramname"> <em>phGeometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a geometry object of the appropriate type from it's well known binary representation. </p>
<p>Note that if nBytes is passed as zero, no checking can be done on whether the pabyData is sufficient. This can result in a crash if the input data is corrupt. This function returns no indication of the number of bytes from the data source actually used to represent the returned geometry object. Use <a class="el" href="ogr__api_8h.html#a5f7035a933b957a9d453184c154c237c" title="Returns size of related binary representation.">OGR_G_WkbSize()</a> on the returned geometry to establish the number of bytes it required in WKB format.</p>
<p>The <a class="el" href="classOGRGeometryFactory.html#a699688dba97260f2eb29f802e39cb0ec" title="Create a geometry object of the appropriate type from it&#39;s well known binary representation.">OGRGeometryFactory::createFromWkb()</a> CPP method is the same as this function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pabyData</em>&nbsp;</td><td>pointer to the input BLOB data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hSRS</em>&nbsp;</td><td>handle to the spatial reference to be assigned to the created geometry object. This may be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phGeometry</em>&nbsp;</td><td>the newly created geometry object will be assigned to the indicated handle on return. This will be NULL in case of failure. If not NULL, *phGeometry should be freed with <a class="el" href="ogr__api_8h.html#ac4e665f5f9690c4fa0c190b930fe9492" title="Destroy geometry object.">OGR_G_DestroyGeometry()</a> after use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nBytes</em>&nbsp;</td><td>the number of bytes of data available in pabyData, or -1 if it is not known, but assumed to be sufficient.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE if all goes well, otherwise any of OGRERR_NOT_ENOUGH_DATA, OGRERR_UNSUPPORTED_GEOMETRY_TYPE, or OGRERR_CORRUPT_DATA may be returned. </dd></dl>

<p>References <a class="el" href="classOGRGeometryFactory.html#a699688dba97260f2eb29f802e39cb0ec">OGRGeometryFactory::createFromWkb()</a>, and <a class="el" href="ogr__api_8h.html#a3172c8e5b8a094b8ce97fa5d44bcd204">OGR_G_CreateFromWkb()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a3172c8e5b8a094b8ce97fa5d44bcd204">OGR_G_CreateFromWkb()</a>.</p>

</div>
</div>
<a class="anchor" id="ac02c3ed5f7ebd5039dc2ae70154fd94a"></a><!-- doxytag: member="ogr_api.h::OGR_G_CreateFromWkt" ref="ac02c3ed5f7ebd5039dc2ae70154fd94a" args="(char **, OGRSpatialReferenceH, OGRGeometryH *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_G_CreateFromWkt </td>
          <td>(</td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>ppszData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRSpatialReferenceH&nbsp;</td>
          <td class="paramname"> <em>hSRS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRGeometryH *&nbsp;</td>
          <td class="paramname"> <em>phGeometry</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a geometry object of the appropriate type from it's well known text representation. </p>
<p>The <a class="el" href="classOGRGeometryFactory.html#a9418f71bcfb1e334173882c38d89d070" title="Create a geometry object of the appropriate type from it&#39;s well known text representation.">OGRGeometryFactory::createFromWkt</a> CPP method is the same as this function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ppszData</em>&nbsp;</td><td>input zero terminated string containing well known text representation of the geometry to be created. The pointer is updated to point just beyond that last character consumed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hSRS</em>&nbsp;</td><td>handle to the spatial reference to be assigned to the created geometry object. This may be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phGeometry</em>&nbsp;</td><td>the newly created geometry object will be assigned to the indicated handle on return. This will be NULL if the method fails. If not NULL, *phGeometry should be freed with <a class="el" href="ogr__api_8h.html#ac4e665f5f9690c4fa0c190b930fe9492" title="Destroy geometry object.">OGR_G_DestroyGeometry()</a> after use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE if all goes well, otherwise any of OGRERR_NOT_ENOUGH_DATA, OGRERR_UNSUPPORTED_GEOMETRY_TYPE, or OGRERR_CORRUPT_DATA may be returned. </dd></dl>

<p>References <a class="el" href="classOGRGeometryFactory.html#a9418f71bcfb1e334173882c38d89d070">OGRGeometryFactory::createFromWkt()</a>, and <a class="el" href="ogr__api_8h.html#ac02c3ed5f7ebd5039dc2ae70154fd94a">OGR_G_CreateFromWkt()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ac02c3ed5f7ebd5039dc2ae70154fd94a">OGR_G_CreateFromWkt()</a>.</p>

</div>
</div>
<a class="anchor" id="a4e47710cf70e5bc72216704ddfead0dd"></a><!-- doxytag: member="ogr_api.h::OGR_G_CreateGeometry" ref="a4e47710cf70e5bc72216704ddfead0dd" args="(OGRwkbGeometryType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRGeometryH OGR_G_CreateGeometry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&nbsp;</td>
          <td class="paramname"> <em>eGeometryType</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an empty geometry of desired type. </p>
<p>This is equivalent to allocating the desired geometry with new, but the allocation is guaranteed to take place in the context of the GDAL/OGR heap.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometryFactory.html#ae4887e270d5099357f9a19b1eda6027a" title="Create an empty geometry of desired type.">OGRGeometryFactory::createGeometry</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>eGeometryType</em>&nbsp;</td><td>the type code of the geometry to be created.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>handle to the newly create geometry or NULL on failure. Should be freed with <a class="el" href="ogr__api_8h.html#ac4e665f5f9690c4fa0c190b930fe9492" title="Destroy geometry object.">OGR_G_DestroyGeometry()</a> after use. </dd></dl>

<p>References <a class="el" href="classOGRGeometryFactory.html#ae4887e270d5099357f9a19b1eda6027a">OGRGeometryFactory::createGeometry()</a>, and <a class="el" href="ogr__api_8h.html#a4e47710cf70e5bc72216704ddfead0dd">OGR_G_CreateGeometry()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a4e47710cf70e5bc72216704ddfead0dd">OGR_G_CreateGeometry()</a>.</p>

</div>
</div>
<a class="anchor" id="a7af82e14406879c08841331b2a4cfe7c"></a><!-- doxytag: member="ogr_api.h::OGR_G_Crosses" ref="a7af82e14406879c08841331b2a4cfe7c" args="(OGRGeometryH, OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_Crosses </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hOther</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test for crossing. </p>
<p>Tests if this geometry and the other geometry are crossing.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#ad5656df62f0857852519bea1486ab1ff" title="Test for crossing.">OGRGeometry::Crosses()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hThis</em>&nbsp;</td><td>the geometry to compare. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hOther</em>&nbsp;</td><td>the other geometry to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if they are crossing, otherwise FALSE. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a7af82e14406879c08841331b2a4cfe7c">OGR_G_Crosses()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a7af82e14406879c08841331b2a4cfe7c">OGR_G_Crosses()</a>.</p>

</div>
</div>
<a class="anchor" id="ac4e665f5f9690c4fa0c190b930fe9492"></a><!-- doxytag: member="ogr_api.h::OGR_G_DestroyGeometry" ref="ac4e665f5f9690c4fa0c190b930fe9492" args="(OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_DestroyGeometry </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy geometry object. </p>
<p>Equivalent to invoking delete on a geometry, but it guaranteed to take place within the context of the GDAL/OGR heap.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometryFactory.html#aae001086e26985d95c36ccd255a8c6d5" title="Destroy geometry object.">OGRGeometryFactory::destroyGeometry</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle to the geometry to delete. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classOGRGeometryFactory.html#aae001086e26985d95c36ccd255a8c6d5">OGRGeometryFactory::destroyGeometry()</a>, and <a class="el" href="ogr__api_8h.html#ac4e665f5f9690c4fa0c190b930fe9492">OGR_G_DestroyGeometry()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ac4e665f5f9690c4fa0c190b930fe9492">OGR_G_DestroyGeometry()</a>.</p>

</div>
</div>
<a class="anchor" id="a497977bec6ecd9dade7a9694f776be64"></a><!-- doxytag: member="ogr_api.h::OGR_G_Difference" ref="a497977bec6ecd9dade7a9694f776be64" args="(OGRGeometryH, OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRGeometryH OGR_G_Difference </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hOther</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute difference. </p>
<p>Generates a new geometry which is the region of this geometry with the region of the other geometry removed.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#ac92e1ca0e8b108ee920147d4894bde3a" title="Compute difference.">OGRGeometry::Difference()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hThis</em>&nbsp;</td><td>the geometry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hOther</em>&nbsp;</td><td>the other geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new geometry representing the difference or NULL if the difference is empty or an error occurs. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a497977bec6ecd9dade7a9694f776be64">OGR_G_Difference()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a497977bec6ecd9dade7a9694f776be64">OGR_G_Difference()</a>.</p>

</div>
</div>
<a class="anchor" id="a7980d65f3d82d5a5442c5141efe3f503"></a><!-- doxytag: member="ogr_api.h::OGR_G_Disjoint" ref="a7980d65f3d82d5a5442c5141efe3f503" args="(OGRGeometryH, OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_Disjoint </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hOther</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test for disjointness. </p>
<p>Tests if this geometry and the other geometry are disjoint.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a45f683761d57c8bea40e4ca1d832760a" title="Test for disjointness.">OGRGeometry::Disjoint()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hThis</em>&nbsp;</td><td>the geometry to compare. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hOther</em>&nbsp;</td><td>the other geometry to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if they are disjoint, otherwise FALSE. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a7980d65f3d82d5a5442c5141efe3f503">OGR_G_Disjoint()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a7980d65f3d82d5a5442c5141efe3f503">OGR_G_Disjoint()</a>.</p>

</div>
</div>
<a class="anchor" id="ab01002a9fd4175832af965930f069401"></a><!-- doxytag: member="ogr_api.h::OGR_G_Distance" ref="ab01002a9fd4175832af965930f069401" args="(OGRGeometryH, OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGR_G_Distance </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hOther</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute distance between two geometries. </p>
<p>Returns the shortest distance between the two geometries. The distance is expressed into the same unit as the coordinates of the geometries.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a24fb51e9b419e97f14964e5a00ae3fb4" title="Compute distance between two geometries.">OGRGeometry::Distance()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hFirst</em>&nbsp;</td><td>the first geometry to compare against. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hOther</em>&nbsp;</td><td>the other geometry to compare against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the distance between the geometries or -1 if an error occurs. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#ab01002a9fd4175832af965930f069401">OGR_G_Distance()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ab01002a9fd4175832af965930f069401">OGR_G_Distance()</a>.</p>

</div>
</div>
<a class="anchor" id="a3a99330bd108940f8a33036c0f83119f"></a><!-- doxytag: member="ogr_api.h::OGR_G_DumpReadable" ref="a3a99330bd108940f8a33036c0f83119f" args="(OGRGeometryH, FILE *, const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_DumpReadable </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszPrefix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dump geometry in well known text format to indicated output file. </p>
<p>This method is the same as the CPP method <a class="el" href="classOGRGeometry.html#a2e70f05d61566a5ddaa29b44f637cfff" title="Dump geometry in well known text format to indicated output file.">OGRGeometry::dumpReadable</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle on the geometry to dump. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fp</em>&nbsp;</td><td>the text file to write the geometry to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszPrefix</em>&nbsp;</td><td>the prefix to put on each line of output. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#a3a99330bd108940f8a33036c0f83119f">OGR_G_DumpReadable()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a3a99330bd108940f8a33036c0f83119f">OGR_G_DumpReadable()</a>.</p>

</div>
</div>
<a class="anchor" id="a90cc83b0a3052b8fbe2ed77a86323bf2"></a><!-- doxytag: member="ogr_api.h::OGR_G_Empty" ref="a90cc83b0a3052b8fbe2ed77a86323bf2" args="(OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_Empty </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear geometry information. This restores the geometry to it's initial state after construction, and before assignment of actual geometry. </p>
<p>This function relates to the SFCOM IGeometry::Empty() method.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#a1702b5b8142abe761061a6cd44e50b05" title="Clear geometry information. This restores the geometry to it&#39;s initial state after construction...">OGRGeometry::empty()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle on the geometry to empty. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#a90cc83b0a3052b8fbe2ed77a86323bf2">OGR_G_Empty()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a90cc83b0a3052b8fbe2ed77a86323bf2">OGR_G_Empty()</a>.</p>

</div>
</div>
<a class="anchor" id="abaed0c4fb6f08abc280f91619e2e47d3"></a><!-- doxytag: member="ogr_api.h::OGR_G_Equals" ref="abaed0c4fb6f08abc280f91619e2e47d3" args="(OGRGeometryH, OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_Equals </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hOther</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns TRUE if two geometries are equivalent. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#ae751513a46c7e7b154796bfe494faf16" title="Returns TRUE if two geometries are equivalent.">OGRGeometry::Equals()</a> method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle on the first geometry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hOther</em>&nbsp;</td><td>handle on the other geometry to test against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if equivalent or FALSE otherwise. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#abaed0c4fb6f08abc280f91619e2e47d3">OGR_G_Equals()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#abaed0c4fb6f08abc280f91619e2e47d3">OGR_G_Equals()</a>.</p>

</div>
</div>
<a class="anchor" id="a3c473bd75c553d2bbae1aed480f8c34d"></a><!-- doxytag: member="ogr_api.h::OGR_G_ExportToGML" ref="a3c473bd75c553d2bbae1aed480f8c34d" args="(OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* OGR_G_ExportToGML </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeometry</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a geometry into GML format. </p>
<p>The GML geometry is expressed directly in terms of GML basic data types assuming the this is available in the gml namespace. The returned string should be freed with CPLFree() when no longer required.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRGeometry.html#aacfeca4beed34b58bed61de7cae36b4e" title="Convert a geometry into GML format.">OGRGeometry::exportToGML()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeometry</em>&nbsp;</td><td>handle to the geometry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A GML fragment or NULL in case of error. </dd></dl>

</div>
</div>
<a class="anchor" id="a06fc1cec4a17a2926640f95c6bf7a442"></a><!-- doxytag: member="ogr_api.h::OGR_G_ExportToGMLEx" ref="a06fc1cec4a17a2926640f95c6bf7a442" args="(OGRGeometryH, char **papszOptions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* OGR_G_ExportToGMLEx </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszOptions</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a geometry into GML format. </p>
<p>The GML geometry is expressed directly in terms of GML basic data types assuming the this is available in the gml namespace. The returned string should be freed with CPLFree() when no longer required.</p>
<p>The supported options in OGR 1.8.0 are : </p>
<ul>
<li>
FORMAT=GML3. Otherwise it will default to GML 2.1.2 output. </li>
<li>
GML3_LINESTRING_ELEMENT=curve. (Only valid for FORMAT=GML3) To use gml:Curve element for linestrings. Otherwise gml:LineString will be used . </li>
<li>
GML3_LONGSRS=YES/NO. (Only valid for FORMAT=GML3) Default to YES. If YES, SRS with EPSG authority will be written with the "urn:ogc:def:crs:EPSG::" prefix. In the case, if the SRS is a geographic SRS without explicit AXIS order, but that the same SRS authority code imported with ImportFromEPSGA() should be treated as lat/long, then the function will take care of coordinate order swapping. If set to NO, SRS with EPSG authority will be written with the "EPSG:" prefix, even if they are in lat/long order. </li>
<li>
GMLID=astring. If specified, a gml:id attribute will be written in the top-level geometry element with the provided value. Required for GML 3.2 compatibility. </li>
</ul>
<p>This method is the same as the C++ method <a class="el" href="classOGRGeometry.html#aacfeca4beed34b58bed61de7cae36b4e" title="Convert a geometry into GML format.">OGRGeometry::exportToGML()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeometry</em>&nbsp;</td><td>handle to the geometry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>papszOptions</em>&nbsp;</td><td>NULL-terminated list of options. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A GML fragment or NULL in case of error.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.8.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a9ebd5fa6a9b67ff6ce5a7e4cd0238a47"></a><!-- doxytag: member="ogr_api.h::OGR_G_ExportToJson" ref="a9ebd5fa6a9b67ff6ce5a7e4cd0238a47" args="(OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* OGR_G_ExportToJson </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeometry</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a geometry into GeoJSON format. </p>
<p>The returned string should be freed with CPLFree() when no longer required.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRGeometry.html#a28609fce6bd422b16182eab58ff4e812" title="Convert a geometry into GeoJSON format.">OGRGeometry::exportToJson()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeometry</em>&nbsp;</td><td>handle to the geometry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A GeoJSON fragment or NULL in case of error. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a9ebd5fa6a9b67ff6ce5a7e4cd0238a47">OGR_G_ExportToJson()</a>, and <a class="el" href="ogr__api_8h.html#a97f1713300ac83c3cf31f40b419b9c0d">OGR_G_ExportToJsonEx()</a>.</p>

<p>Referenced by <a class="el" href="classOGRGeometry.html#a28609fce6bd422b16182eab58ff4e812">OGRGeometry::exportToJson()</a>, and <a class="el" href="ogr__api_8h.html#a9ebd5fa6a9b67ff6ce5a7e4cd0238a47">OGR_G_ExportToJson()</a>.</p>

</div>
</div>
<a class="anchor" id="a97f1713300ac83c3cf31f40b419b9c0d"></a><!-- doxytag: member="ogr_api.h::OGR_G_ExportToJsonEx" ref="a97f1713300ac83c3cf31f40b419b9c0d" args="(OGRGeometryH, char **papszOptions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* OGR_G_ExportToJsonEx </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszOptions</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a geometry into GeoJSON format. </p>
<p>The returned string should be freed with CPLFree() when no longer required.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRGeometry.html#a28609fce6bd422b16182eab58ff4e812" title="Convert a geometry into GeoJSON format.">OGRGeometry::exportToJson()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeometry</em>&nbsp;</td><td>handle to the geometry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>papszOptions</em>&nbsp;</td><td>a null terminated list of options. For now, only COORDINATE_PRECISION=int_number where int_number is the maximum number of figures after decimal separator to write in coordinates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A GeoJSON fragment or NULL in case of error.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.9.0 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a97f1713300ac83c3cf31f40b419b9c0d">OGR_G_ExportToJsonEx()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a9ebd5fa6a9b67ff6ce5a7e4cd0238a47">OGR_G_ExportToJson()</a>, and <a class="el" href="ogr__api_8h.html#a97f1713300ac83c3cf31f40b419b9c0d">OGR_G_ExportToJsonEx()</a>.</p>

</div>
</div>
<a class="anchor" id="a27b1389e05c84261a7b612aefedd0ed3"></a><!-- doxytag: member="ogr_api.h::OGR_G_ExportToKML" ref="a27b1389e05c84261a7b612aefedd0ed3" args="(OGRGeometryH, const char *pszAltitudeMode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* OGR_G_ExportToKML </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszAltitudeMode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a geometry into KML format. </p>
<p>The returned string should be freed with CPLFree() when no longer required.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRGeometry.html#a579b67f04630b791a229b6a7c2914640" title="Convert a geometry into KML format.">OGRGeometry::exportToKML()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeometry</em>&nbsp;</td><td>handle to the geometry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszAltitudeMode</em>&nbsp;</td><td>value to write in altitudeMode element, or NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A KML fragment or NULL in case of error. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a27b1389e05c84261a7b612aefedd0ed3">OGR_G_ExportToKML()</a>.</p>

<p>Referenced by <a class="el" href="classOGRGeometry.html#a579b67f04630b791a229b6a7c2914640">OGRGeometry::exportToKML()</a>, and <a class="el" href="ogr__api_8h.html#a27b1389e05c84261a7b612aefedd0ed3">OGR_G_ExportToKML()</a>.</p>

</div>
</div>
<a class="anchor" id="ad5c94ae76c09774dba8725c24daeefd6"></a><!-- doxytag: member="ogr_api.h::OGR_G_ExportToWkb" ref="ad5c94ae76c09774dba8725c24daeefd6" args="(OGRGeometryH, OGRwkbByteOrder, unsigned char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_G_ExportToWkb </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRwkbByteOrder&nbsp;</td>
          <td class="paramname"> <em>eOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>pabyDstBuffer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a geometry into well known binary format. </p>
<p>This function relates to the SFCOM IWks::ExportToWKB() method.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#ad46eeb33da8b6de99f1697f8de9cbea7" title="Convert a geometry into well known binary format.">OGRGeometry::exportToWkb()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle on the geometry to convert to a well know binary data from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eOrder</em>&nbsp;</td><td>One of wkbXDR or wkbNDR indicating MSB or LSB byte order respectively. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pabyDstBuffer</em>&nbsp;</td><td>a buffer into which the binary representation is written. This buffer must be at least <a class="el" href="ogr__api_8h.html#a5f7035a933b957a9d453184c154c237c" title="Returns size of related binary representation.">OGR_G_WkbSize()</a> byte in size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Currently OGRERR_NONE is always returned. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#ad5c94ae76c09774dba8725c24daeefd6">OGR_G_ExportToWkb()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ad5c94ae76c09774dba8725c24daeefd6">OGR_G_ExportToWkb()</a>.</p>

</div>
</div>
<a class="anchor" id="a3bc9310302e2dbfaab1690de9e2fd2fb"></a><!-- doxytag: member="ogr_api.h::OGR_G_ExportToWkt" ref="a3bc9310302e2dbfaab1690de9e2fd2fb" args="(OGRGeometryH, char **)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_G_ExportToWkt </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>ppszSrcText</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a geometry into well known text format. </p>
<p>This function relates to the SFCOM IWks::ExportToWKT() method.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#a0c941d5efdff84666af5a6f6b540aafb" title="Convert a geometry into well known text format.">OGRGeometry::exportToWkt()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle on the geometry to convert to a text format from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ppszSrcText</em>&nbsp;</td><td>a text buffer is allocated by the program, and assigned to the passed pointer. After use, *ppszDstText should be freed with OGRFree().</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Currently OGRERR_NONE is always returned. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a3bc9310302e2dbfaab1690de9e2fd2fb">OGR_G_ExportToWkt()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a3bc9310302e2dbfaab1690de9e2fd2fb">OGR_G_ExportToWkt()</a>.</p>

</div>
</div>
<a class="anchor" id="afdb7354b55c7448b60b44cd9e36073b8"></a><!-- doxytag: member="ogr_api.h::OGR_G_FlattenTo2D" ref="afdb7354b55c7448b60b44cd9e36073b8" args="(OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_FlattenTo2D </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert geometry to strictly 2D. In a sense this converts all Z coordinates to 0.0. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#aaae1a2ced937a5900b2bfeb717bad6c9" title="Convert geometry to strictly 2D. In a sense this converts all Z coordinates to 0.0.">OGRGeometry::flattenTo2D()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle on the geometry to convert. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#afdb7354b55c7448b60b44cd9e36073b8">OGR_G_FlattenTo2D()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#afdb7354b55c7448b60b44cd9e36073b8">OGR_G_FlattenTo2D()</a>.</p>

</div>
</div>
<a class="anchor" id="a670481ed69704f2be0c2c24a304d3bf5"></a><!-- doxytag: member="ogr_api.h::OGR_G_ForceToLineString" ref="a670481ed69704f2be0c2c24a304d3bf5" args="(OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRGeometryH OGR_G_ForceToLineString </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert to line string. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometryFactory.html#adcae79ea28620e332a3d1df87f1180f3" title="Convert to line string.">OGRGeometryFactory::forceToLineString()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle to the geometry to convert (ownership surrendered). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the converted geometry (ownership to caller).</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL/OGR 1.10.0 </dd></dl>

<p>References <a class="el" href="classOGRGeometryFactory.html#adcae79ea28620e332a3d1df87f1180f3">OGRGeometryFactory::forceToLineString()</a>, and <a class="el" href="ogr__api_8h.html#a670481ed69704f2be0c2c24a304d3bf5">OGR_G_ForceToLineString()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a670481ed69704f2be0c2c24a304d3bf5">OGR_G_ForceToLineString()</a>.</p>

</div>
</div>
<a class="anchor" id="ac3d8424596b90664b7280a9e7c89dc96"></a><!-- doxytag: member="ogr_api.h::OGR_G_ForceToMultiLineString" ref="ac3d8424596b90664b7280a9e7c89dc96" args="(OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRGeometryH OGR_G_ForceToMultiLineString </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert to multilinestring. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometryFactory.html#a1c00a78cec110d71175726d6f26b1b39" title="Convert to multilinestring.">OGRGeometryFactory::forceToMultiLineString()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle to the geometry to convert (ownership surrendered). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the converted geometry (ownership to caller).</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL/OGR 1.8.0 </dd></dl>

<p>References <a class="el" href="classOGRGeometryFactory.html#a1c00a78cec110d71175726d6f26b1b39">OGRGeometryFactory::forceToMultiLineString()</a>, and <a class="el" href="ogr__api_8h.html#ac3d8424596b90664b7280a9e7c89dc96">OGR_G_ForceToMultiLineString()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ac3d8424596b90664b7280a9e7c89dc96">OGR_G_ForceToMultiLineString()</a>.</p>

</div>
</div>
<a class="anchor" id="aedd1952b5cde54253746d9da1a2b0500"></a><!-- doxytag: member="ogr_api.h::OGR_G_ForceToMultiPoint" ref="aedd1952b5cde54253746d9da1a2b0500" args="(OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRGeometryH OGR_G_ForceToMultiPoint </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert to multipoint. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometryFactory.html#aa97b7837101f6c56e476520d10a9f3c3" title="Convert to multipoint.">OGRGeometryFactory::forceToMultiPoint()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle to the geometry to convert (ownership surrendered). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the converted geometry (ownership to caller).</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL/OGR 1.8.0 </dd></dl>

<p>References <a class="el" href="classOGRGeometryFactory.html#aa97b7837101f6c56e476520d10a9f3c3">OGRGeometryFactory::forceToMultiPoint()</a>, and <a class="el" href="ogr__api_8h.html#aedd1952b5cde54253746d9da1a2b0500">OGR_G_ForceToMultiPoint()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#aedd1952b5cde54253746d9da1a2b0500">OGR_G_ForceToMultiPoint()</a>.</p>

</div>
</div>
<a class="anchor" id="abea3d494951ab99e72b59cbd5318e8c4"></a><!-- doxytag: member="ogr_api.h::OGR_G_ForceToMultiPolygon" ref="abea3d494951ab99e72b59cbd5318e8c4" args="(OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRGeometryH OGR_G_ForceToMultiPolygon </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert to multipolygon. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometryFactory.html#a2a40032fa65cc71c028516bf8fc0df3e" title="Convert to multipolygon.">OGRGeometryFactory::forceToMultiPolygon()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle to the geometry to convert (ownership surrendered). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the converted geometry (ownership to caller).</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL/OGR 1.8.0 </dd></dl>

<p>References <a class="el" href="classOGRGeometryFactory.html#a2a40032fa65cc71c028516bf8fc0df3e">OGRGeometryFactory::forceToMultiPolygon()</a>, and <a class="el" href="ogr__api_8h.html#abea3d494951ab99e72b59cbd5318e8c4">OGR_G_ForceToMultiPolygon()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#abea3d494951ab99e72b59cbd5318e8c4">OGR_G_ForceToMultiPolygon()</a>.</p>

</div>
</div>
<a class="anchor" id="ac4d5e3d348db62e46ebba718edb36abe"></a><!-- doxytag: member="ogr_api.h::OGR_G_ForceToPolygon" ref="ac4d5e3d348db62e46ebba718edb36abe" args="(OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRGeometryH OGR_G_ForceToPolygon </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert to polygon. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometryFactory.html#afd61936e41ea69831b3196e817658d08" title="Convert to polygon.">OGRGeometryFactory::forceToPolygon()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle to the geometry to convert (ownership surrendered). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the converted geometry (ownership to caller).</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL/OGR 1.8.0 </dd></dl>

<p>References <a class="el" href="classOGRGeometryFactory.html#afd61936e41ea69831b3196e817658d08">OGRGeometryFactory::forceToPolygon()</a>, and <a class="el" href="ogr__api_8h.html#ac4d5e3d348db62e46ebba718edb36abe">OGR_G_ForceToPolygon()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ac4d5e3d348db62e46ebba718edb36abe">OGR_G_ForceToPolygon()</a>.</p>

</div>
</div>
<a class="anchor" id="a660b737a75579daf2cc78d24ccd4311d"></a><!-- doxytag: member="ogr_api.h::OGR_G_GetArea" ref="a660b737a75579daf2cc78d24ccd4311d" args="(OGRGeometryH) CPL_WARN_DEPRECATED(&quot;Non standard method. Use OGR_G_Area() instead&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGR_G_GetArea </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute geometry area (deprecated). </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="ogr__api_8h.html#a2a849c584cd22a199bcfb9b34b9a1a8f" title="Compute geometry area.">OGR_G_Area()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0d479e8f0e97d6244af8776d5ea6efbb"></a><!-- doxytag: member="ogr_api.h::OGR_G_GetBoundary" ref="a0d479e8f0e97d6244af8776d5ea6efbb" args="(OGRGeometryH) CPL_WARN_DEPRECATED(&quot;Non standard method. Use OGR_G_Boundary() instead&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRGeometryH OGR_G_GetBoundary </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hTarget</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute boundary (deprecated). </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="ogr__api_8h.html#a95447f722f907b7143a1fc19005dd20b" title="Compute boundary.">OGR_G_Boundary()</a> </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a0d479e8f0e97d6244af8776d5ea6efbb">OGR_G_GetBoundary()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a0d479e8f0e97d6244af8776d5ea6efbb">OGR_G_GetBoundary()</a>.</p>

</div>
</div>
<a class="anchor" id="a8a5e78b0753339d1cdd282b0e151d28f"></a><!-- doxytag: member="ogr_api.h::OGR_G_GetCoordinateDimension" ref="a8a5e78b0753339d1cdd282b0e151d28f" args="(OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_GetCoordinateDimension </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the dimension of the coordinates in this geometry. </p>
<p>This function corresponds to the SFCOM IGeometry::GetDimension() method.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#a2a93f43a3b66462195b46f7fd2196dfc" title="Get the dimension of the coordinates in this object.">OGRGeometry::getCoordinateDimension()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle on the geometry to get the dimension of the coordinates from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>in practice this will return 2 or 3. It can also return 0 in the case of an empty point. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a8a5e78b0753339d1cdd282b0e151d28f">OGR_G_GetCoordinateDimension()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a8a5e78b0753339d1cdd282b0e151d28f">OGR_G_GetCoordinateDimension()</a>.</p>

</div>
</div>
<a class="anchor" id="a94b633e1acd208c258ad49f8d4fd4104"></a><!-- doxytag: member="ogr_api.h::OGR_G_GetDimension" ref="a94b633e1acd208c258ad49f8d4fd4104" args="(OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_GetDimension </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the dimension of this geometry. </p>
<p>This function corresponds to the SFCOM IGeometry::GetDimension() method. It indicates the dimension of the geometry, but does not indicate the dimension of the underlying space (as indicated by <a class="el" href="ogr__api_8h.html#a8a5e78b0753339d1cdd282b0e151d28f" title="Get the dimension of the coordinates in this geometry.">OGR_G_GetCoordinateDimension()</a> function).</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#aadca09471fa9917452e087ba12d73eeb" title="Get the dimension of this object.">OGRGeometry::getDimension()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle on the geometry to get the dimension from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 for points, 1 for lines and 2 for surfaces. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a94b633e1acd208c258ad49f8d4fd4104">OGR_G_GetDimension()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a94b633e1acd208c258ad49f8d4fd4104">OGR_G_GetDimension()</a>.</p>

</div>
</div>
<a class="anchor" id="a617a9c9ea85157661619a1d8f0a69cf9"></a><!-- doxytag: member="ogr_api.h::OGR_G_GetEnvelope" ref="a617a9c9ea85157661619a1d8f0a69cf9" args="(OGRGeometryH, OGREnvelope *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_GetEnvelope </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGREnvelope.html">OGREnvelope</a> *&nbsp;</td>
          <td class="paramname"> <em>psEnvelope</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#aa3d42b06ae6f7bbef6d1a2886da8d398" title="Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure...">OGRGeometry::getEnvelope()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle of the geometry to get envelope from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>psEnvelope</em>&nbsp;</td><td>the structure in which to place the results. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#a617a9c9ea85157661619a1d8f0a69cf9">OGR_G_GetEnvelope()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a617a9c9ea85157661619a1d8f0a69cf9">OGR_G_GetEnvelope()</a>.</p>

</div>
</div>
<a class="anchor" id="a9a950633ac824042b0afdb88c670c5ce"></a><!-- doxytag: member="ogr_api.h::OGR_G_GetEnvelope3D" ref="a9a950633ac824042b0afdb88c670c5ce" args="(OGRGeometryH, OGREnvelope3D *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_GetEnvelope3D </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGREnvelope3D.html">OGREnvelope3D</a> *&nbsp;</td>
          <td class="paramname"> <em>psEnvelope</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes and returns the bounding envelope (3D) for this geometry in the passed psEnvelope structure. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#aa3d42b06ae6f7bbef6d1a2886da8d398" title="Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure...">OGRGeometry::getEnvelope()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle of the geometry to get envelope from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>psEnvelope</em>&nbsp;</td><td>the structure in which to place the results.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.9.0 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a9a950633ac824042b0afdb88c670c5ce">OGR_G_GetEnvelope3D()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a9a950633ac824042b0afdb88c670c5ce">OGR_G_GetEnvelope3D()</a>.</p>

</div>
</div>
<a class="anchor" id="a1fa07ddf969f97f6444de6ae5128d842"></a><!-- doxytag: member="ogr_api.h::OGR_G_GetGeometryCount" ref="a1fa07ddf969f97f6444de6ae5128d842" args="(OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_GetGeometryCount </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch the number of elements in a geometry or number of geometries in container. </p>
<p>Only geometries of type wkbPolygon[25D], wkbMultiPoint[25D], wkbMultiLineString[25D], wkbMultiPolygon[25D] or wkbGeometryCollection[25D] may return a valid value. Other geometry types will silently return 0.</p>
<p>For a polygon, the returned number is the number of rings (exterior ring + interior rings).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>single geometry or geometry container from which to get the number of elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of elements. </dd></dl>

<p>References <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa7f299e8edaee30fd3c7a40baf19b48b1">wkbGeometryCollection</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa2ecf4d40ab038779cbc1de22ddcb3429">wkbMultiLineString</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa826c812d3551fa07feb4c3664517c29c">wkbMultiPoint</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa7ff2322e0696d383d7715b7e7be1a7b1">wkbMultiPolygon</a>, and <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa11991cd1245f146f3efd694553433aeb">wkbPolygon</a>.</p>

</div>
</div>
<a class="anchor" id="a18121f835b2fb724a0c1a87beb1a437a"></a><!-- doxytag: member="ogr_api.h::OGR_G_GetGeometryName" ref="a18121f835b2fb724a0c1a87beb1a437a" args="(OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_G_GetGeometryName </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch WKT name for geometry type. </p>
<p>There is no SFCOM analog to this function.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#aba109e1c53ce1452942f85eae66d88b8" title="Fetch WKT name for geometry type.">OGRGeometry::getGeometryName()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle on the geometry to get name from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>name used for this geometry type in well known text format. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a18121f835b2fb724a0c1a87beb1a437a">OGR_G_GetGeometryName()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a18121f835b2fb724a0c1a87beb1a437a">OGR_G_GetGeometryName()</a>.</p>

</div>
</div>
<a class="anchor" id="a6bac93150529a5c98811db29e289dd66"></a><!-- doxytag: member="ogr_api.h::OGR_G_GetGeometryRef" ref="a6bac93150529a5c98811db29e289dd66" args="(OGRGeometryH, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRGeometryH OGR_G_GetGeometryRef </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iSubGeom</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch geometry from a geometry container. </p>
<p>This function returns an handle to a geometry within the container. The returned geometry remains owned by the container, and should not be modified. The handle is only valid untill the next change to the geometry container. Use <a class="el" href="ogr__api_8h.html#a1725918932da7d59f9ee72829ac171fa" title="Make a copy of this object.">OGR_G_Clone()</a> to make a copy.</p>
<p>This function relates to the SFCOM IGeometryCollection::get_Geometry() method.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometryCollection.html#ad609f2c7886918a766dd3d3a4fa52ec3" title="Fetch geometry from container.">OGRGeometryCollection::getGeometryRef()</a>.</p>
<p>For a polygon, OGR_G_GetGeometryRef(iSubGeom) returns the exterior ring if iSubGeom == 0, and the interior rings for iSubGeom &gt; 0.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle to the geometry container from which to get a geometry from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iSubGeom</em>&nbsp;</td><td>the index of the geometry to fetch, between 0 and getNumGeometries() - 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>handle to the requested geometry. </dd></dl>

<p>References <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa7f299e8edaee30fd3c7a40baf19b48b1">wkbGeometryCollection</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa2ecf4d40ab038779cbc1de22ddcb3429">wkbMultiLineString</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa826c812d3551fa07feb4c3664517c29c">wkbMultiPoint</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa7ff2322e0696d383d7715b7e7be1a7b1">wkbMultiPolygon</a>, and <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa11991cd1245f146f3efd694553433aeb">wkbPolygon</a>.</p>

</div>
</div>
<a class="anchor" id="a8fae58102f5c4a4cf2526e5ca8369a76"></a><!-- doxytag: member="ogr_api.h::OGR_G_GetGeometryType" ref="a8fae58102f5c4a4cf2526e5ca8369a76" args="(OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a> OGR_G_GetGeometryType </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch geometry type. </p>
<p>Note that the geometry type may include the 2.5D flag. To get a 2D flattened version of the geometry type apply the wkbFlatten() macro to the return result.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#a5c6bca18682cb933e3227552d480e1a5" title="Fetch geometry type.">OGRGeometry::getGeometryType()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle on the geometry to get type from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the geometry type code. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a8fae58102f5c4a4cf2526e5ca8369a76">OGR_G_GetGeometryType()</a>, and <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa3645f782f9b9f7632d7e7cdd0451d58f">wkbUnknown</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a8fae58102f5c4a4cf2526e5ca8369a76">OGR_G_GetGeometryType()</a>.</p>

</div>
</div>
<a class="anchor" id="a67b897ffcd88a83832964c3735fa1dcb"></a><!-- doxytag: member="ogr_api.h::OGR_G_GetPoint" ref="a67b897ffcd88a83832964c3735fa1dcb" args="(OGRGeometryH, int iPoint, double *, double *, double *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_GetPoint </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pdfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pdfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pdfZ</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch a point in line string or a point geometry. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle to the geometry from which to get the coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>the vertex to fetch, from 0 to getNumPoints()-1, zero for a point. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pdfX</em>&nbsp;</td><td>value of x coordinate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pdfY</em>&nbsp;</td><td>value of y coordinate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pdfZ</em>&nbsp;</td><td>value of z coordinate. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classOGRLineString.html#a7ea70605cd6ac71221177586c2ec5cfc">OGRLineString::getNumPoints()</a>, <a class="el" href="classOGRLineString.html#aa4c8c1c903bca56f64bc5856f42b2e5c">OGRLineString::getX()</a>, <a class="el" href="classOGRLineString.html#abe55ebb3fc3c9491eb937d2c5c240771">OGRLineString::getY()</a>, <a class="el" href="classOGRLineString.html#a9bf6ed6cc59d36b79d0f358f50b3b47a">OGRLineString::getZ()</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa09fd8f51759a1cf351b04e786a2a9058">wkbLineString</a>, and <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa6f8377c5a4a9d36ae2384f4a5f45d77f">wkbPoint</a>.</p>

</div>
</div>
<a class="anchor" id="aec43cbe83609bc7b43739d67858846c1"></a><!-- doxytag: member="ogr_api.h::OGR_G_GetPointCount" ref="aec43cbe83609bc7b43739d67858846c1" args="(OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_GetPointCount </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch number of points from a geometry. </p>
<p>Only wkbPoint[25D] or wkbLineString[25D] may return a valid value. Other geometry types will silently return 0.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle to the geometry from which to get the number of points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of points. </dd></dl>

<p>References <a class="el" href="classOGRLineString.html#a7ea70605cd6ac71221177586c2ec5cfc">OGRLineString::getNumPoints()</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa09fd8f51759a1cf351b04e786a2a9058">wkbLineString</a>, and <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa6f8377c5a4a9d36ae2384f4a5f45d77f">wkbPoint</a>.</p>

</div>
</div>
<a class="anchor" id="a6c22d91b27d7a42c225a7dfde28f09c4"></a><!-- doxytag: member="ogr_api.h::OGR_G_GetPoints" ref="a6c22d91b27d7a42c225a7dfde28f09c4" args="(OGRGeometryH hGeom, void *pabyX, int nXStride, void *pabyY, int nYStride, void *pabyZ, int nZStride)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_GetPoints </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pabyX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nXStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pabyY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nYStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pabyZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nZStride</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns all points of line string. </p>
<p>This method copies all points into user arrays. The user provides the stride between 2 consecutives elements of the array.</p>
<p>On some CPU architectures, care must be taken so that the arrays are properly aligned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle to the geometry from which to get the coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pabyX</em>&nbsp;</td><td>a buffer of at least (sizeof(double) * nXStride * nPointCount) bytes, may be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nXStride</em>&nbsp;</td><td>the number of bytes between 2 elements of pabyX. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pabyY</em>&nbsp;</td><td>a buffer of at least (sizeof(double) * nYStride * nPointCount) bytes, may be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nYStride</em>&nbsp;</td><td>the number of bytes between 2 elements of pabyY. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pabyZ</em>&nbsp;</td><td>a buffer of at last size (sizeof(double) * nZStride * nPointCount) bytes, may be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nZStride</em>&nbsp;</td><td>the number of bytes between 2 elements of pabyZ.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of points</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.9.0 </dd></dl>

<p>References <a class="el" href="classOGRLineString.html#a7ea70605cd6ac71221177586c2ec5cfc">OGRLineString::getNumPoints()</a>, <a class="el" href="classOGRLineString.html#a3cf1133f3f80193a74cb89daafa69021">OGRLineString::getPoints()</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa09fd8f51759a1cf351b04e786a2a9058">wkbLineString</a>, and <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa6f8377c5a4a9d36ae2384f4a5f45d77f">wkbPoint</a>.</p>

</div>
</div>
<a class="anchor" id="abc393e40282eec3801fb4a4abc9e25bf"></a><!-- doxytag: member="ogr_api.h::OGR_G_GetSpatialReference" ref="abc393e40282eec3801fb4a4abc9e25bf" args="(OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRSpatialReferenceH OGR_G_GetSpatialReference </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns spatial reference system for geometry. </p>
<p>This function relates to the SFCOM IGeometry::get_SpatialReference() method.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#a194f0bbdae896539852106cafbffbe87" title="Returns spatial reference system for object.">OGRGeometry::getSpatialReference()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle on the geometry to get spatial reference from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to the spatial reference geometry. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#abc393e40282eec3801fb4a4abc9e25bf">OGR_G_GetSpatialReference()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#abc393e40282eec3801fb4a4abc9e25bf">OGR_G_GetSpatialReference()</a>.</p>

</div>
</div>
<a class="anchor" id="a354146161d0a087b63ab6e350bae4d86"></a><!-- doxytag: member="ogr_api.h::OGR_G_GetX" ref="a354146161d0a087b63ab6e350bae4d86" args="(OGRGeometryH, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGR_G_GetX </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch the x coordinate of a point from a geometry. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle to the geometry from which to get the x coordinate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>point to get the x coordinate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the X coordinate of this point. </dd></dl>

<p>References <a class="el" href="classOGRLineString.html#a7ea70605cd6ac71221177586c2ec5cfc">OGRLineString::getNumPoints()</a>, <a class="el" href="classOGRLineString.html#aa4c8c1c903bca56f64bc5856f42b2e5c">OGRLineString::getX()</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa09fd8f51759a1cf351b04e786a2a9058">wkbLineString</a>, and <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa6f8377c5a4a9d36ae2384f4a5f45d77f">wkbPoint</a>.</p>

</div>
</div>
<a class="anchor" id="a8405350c9aea2ab7d0f759f0b09b926f"></a><!-- doxytag: member="ogr_api.h::OGR_G_GetY" ref="a8405350c9aea2ab7d0f759f0b09b926f" args="(OGRGeometryH, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGR_G_GetY </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch the x coordinate of a point from a geometry. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle to the geometry from which to get the y coordinate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>point to get the Y coordinate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the Y coordinate of this point. </dd></dl>

<p>References <a class="el" href="classOGRLineString.html#a7ea70605cd6ac71221177586c2ec5cfc">OGRLineString::getNumPoints()</a>, <a class="el" href="classOGRLineString.html#abe55ebb3fc3c9491eb937d2c5c240771">OGRLineString::getY()</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa09fd8f51759a1cf351b04e786a2a9058">wkbLineString</a>, and <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa6f8377c5a4a9d36ae2384f4a5f45d77f">wkbPoint</a>.</p>

</div>
</div>
<a class="anchor" id="a1d8c6aeb013325f33b8e642003fc17ad"></a><!-- doxytag: member="ogr_api.h::OGR_G_GetZ" ref="a1d8c6aeb013325f33b8e642003fc17ad" args="(OGRGeometryH, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGR_G_GetZ </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch the z coordinate of a point from a geometry. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle to the geometry from which to get the Z coordinate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>point to get the Z coordinate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the Z coordinate of this point. </dd></dl>

<p>References <a class="el" href="classOGRLineString.html#a7ea70605cd6ac71221177586c2ec5cfc">OGRLineString::getNumPoints()</a>, <a class="el" href="classOGRLineString.html#a9bf6ed6cc59d36b79d0f358f50b3b47a">OGRLineString::getZ()</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa09fd8f51759a1cf351b04e786a2a9058">wkbLineString</a>, and <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa6f8377c5a4a9d36ae2384f4a5f45d77f">wkbPoint</a>.</p>

</div>
</div>
<a class="anchor" id="afa5a9173aa3b10a4db09ed696a92ba4a"></a><!-- doxytag: member="ogr_api.h::OGR_G_ImportFromWkb" ref="afa5a9173aa3b10a4db09ed696a92ba4a" args="(OGRGeometryH, unsigned char *, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_G_ImportFromWkb </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>pabyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assign geometry from well known binary data. </p>
<p>The object must have already been instantiated as the correct derived type of geometry object to match the binaries type.</p>
<p>This function relates to the SFCOM IWks::ImportFromWKB() method.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#ab2c6583c2b7c3e526dcfe54a61470c1f" title="Assign geometry from well known binary data.">OGRGeometry::importFromWkb()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle on the geometry to assign the well know binary data to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pabyData</em>&nbsp;</td><td>the binary input data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nSize</em>&nbsp;</td><td>the size of pabyData in bytes, or zero if not known.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE if all goes well, otherwise any of OGRERR_NOT_ENOUGH_DATA, OGRERR_UNSUPPORTED_GEOMETRY_TYPE, or OGRERR_CORRUPT_DATA may be returned. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#afa5a9173aa3b10a4db09ed696a92ba4a">OGR_G_ImportFromWkb()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#afa5a9173aa3b10a4db09ed696a92ba4a">OGR_G_ImportFromWkb()</a>.</p>

</div>
</div>
<a class="anchor" id="a4286ba243fb05a831a49f52aabcbc6f8"></a><!-- doxytag: member="ogr_api.h::OGR_G_ImportFromWkt" ref="a4286ba243fb05a831a49f52aabcbc6f8" args="(OGRGeometryH, char **)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_G_ImportFromWkt </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>ppszSrcText</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assign geometry from well known text data. </p>
<p>The object must have already been instantiated as the correct derived type of geometry object to match the text type.</p>
<p>This function relates to the SFCOM IWks::ImportFromWKT() method.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#a30561a301d44b1f90393ea4a78a5b0a5" title="Assign geometry from well known text data.">OGRGeometry::importFromWkt()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle on the geometry to assign well know text data to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ppszSrcText</em>&nbsp;</td><td>pointer to a pointer to the source text. The pointer is updated to pointer after the consumed text.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE if all goes well, otherwise any of OGRERR_NOT_ENOUGH_DATA, OGRERR_UNSUPPORTED_GEOMETRY_TYPE, or OGRERR_CORRUPT_DATA may be returned. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a4286ba243fb05a831a49f52aabcbc6f8">OGR_G_ImportFromWkt()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a4286ba243fb05a831a49f52aabcbc6f8">OGR_G_ImportFromWkt()</a>.</p>

</div>
</div>
<a class="anchor" id="a5a271b5c7b72994120e7a6bbc7e7e5cb"></a><!-- doxytag: member="ogr_api.h::OGR_G_Intersection" ref="a5a271b5c7b72994120e7a6bbc7e7e5cb" args="(OGRGeometryH, OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRGeometryH OGR_G_Intersection </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hOther</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute intersection. </p>
<p>Generates a new geometry which is the region of intersection of the two geometries operated on. The <a class="el" href="ogr__api_8h.html#acaed6926b75cd33a42b284c10def6e87" title="Do these features intersect?">OGR_G_Intersects()</a> function can be used to test if two geometries intersect.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a202ad4c29487ca046c4a2b055042cb6a" title="Compute intersection.">OGRGeometry::Intersection()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hThis</em>&nbsp;</td><td>the geometry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hOther</em>&nbsp;</td><td>the other geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new geometry representing the intersection or NULL if there is no intersection or an error occurs. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a5a271b5c7b72994120e7a6bbc7e7e5cb">OGR_G_Intersection()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a5a271b5c7b72994120e7a6bbc7e7e5cb">OGR_G_Intersection()</a>.</p>

</div>
</div>
<a class="anchor" id="acaed6926b75cd33a42b284c10def6e87"></a><!-- doxytag: member="ogr_api.h::OGR_G_Intersects" ref="acaed6926b75cd33a42b284c10def6e87" args="(OGRGeometryH, OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_Intersects </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hOtherGeom</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Do these features intersect? </p>
<p>Currently this is not implemented in a rigerous fashion, and generally just tests whether the envelopes of the two features intersect. Eventually this will be made rigerous.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#a0829528c9ca29059f86399da954fc8ae" title="Do these features intersect?">OGRGeometry::Intersects</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle on the first geometry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hOtherGeom</em>&nbsp;</td><td>handle on the other geometry to test against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the geometries intersect, otherwise FALSE. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#acaed6926b75cd33a42b284c10def6e87">OGR_G_Intersects()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#acaed6926b75cd33a42b284c10def6e87">OGR_G_Intersects()</a>.</p>

</div>
</div>
<a class="anchor" id="a737b0c4d73928e7406d69c658209dbbf"></a><!-- doxytag: member="ogr_api.h::OGR_G_IsEmpty" ref="a737b0c4d73928e7406d69c658209dbbf" args="(OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_IsEmpty </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if the geometry is empty. </p>
<p>This method is the same as the CPP method <a class="el" href="classOGRGeometry.html#ac8653ba97e53f3e3b041946ca2acc111" title="Returns TRUE (non-zero) if the object has no points.">OGRGeometry::IsEmpty()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>The Geometry to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the geometry has no points, otherwise FALSE. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a737b0c4d73928e7406d69c658209dbbf">OGR_G_IsEmpty()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a737b0c4d73928e7406d69c658209dbbf">OGR_G_IsEmpty()</a>.</p>

</div>
</div>
<a class="anchor" id="ab9e99b4792042aca861866cb29bdf826"></a><!-- doxytag: member="ogr_api.h::OGR_G_IsRing" ref="ab9e99b4792042aca861866cb29bdf826" args="(OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_IsRing </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if the geometry is a ring. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#ad15ffdcae4351112b3106d4f87b2a3bf" title="Test if the geometry is a ring.">OGRGeometry::IsRing()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always return FALSE.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>The Geometry to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the geometry has no points, otherwise FALSE. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#ab9e99b4792042aca861866cb29bdf826">OGR_G_IsRing()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ab9e99b4792042aca861866cb29bdf826">OGR_G_IsRing()</a>.</p>

</div>
</div>
<a class="anchor" id="a3cb66472d7e302d16aacf0d66c01ac73"></a><!-- doxytag: member="ogr_api.h::OGR_G_IsSimple" ref="a3cb66472d7e302d16aacf0d66c01ac73" args="(OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_IsSimple </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns TRUE if the geometry is simple. </p>
<p>Returns TRUE if the geometry has no anomalous geometric points, such as self intersection or self tangency. The description of each instantiable geometric class will include the specific conditions that cause an instance of that class to be classified as not simple.</p>
<p>This function is the same as the c++ method <a class="el" href="classOGRGeometry.html#ab72b0c5c673d8b1cf6f870fabbeffe26" title="Test if the geometry is simple.">OGRGeometry::IsSimple()</a> method.</p>
<p>If OGR is built without the GEOS library, this function will always return FALSE.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>The Geometry to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if object is simple, otherwise FALSE. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a3cb66472d7e302d16aacf0d66c01ac73">OGR_G_IsSimple()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a3cb66472d7e302d16aacf0d66c01ac73">OGR_G_IsSimple()</a>.</p>

</div>
</div>
<a class="anchor" id="a4df68924f3b41fd377c5b4aa6631a00b"></a><!-- doxytag: member="ogr_api.h::OGR_G_IsValid" ref="a4df68924f3b41fd377c5b4aa6631a00b" args="(OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_IsValid </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if the geometry is valid. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a7bbb194937466a6127b5436ac2ae99d9" title="Test if the geometry is valid.">OGRGeometry::IsValid()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always return FALSE.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>The Geometry to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the geometry has no points, otherwise FALSE. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a4df68924f3b41fd377c5b4aa6631a00b">OGR_G_IsValid()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a4df68924f3b41fd377c5b4aa6631a00b">OGR_G_IsValid()</a>.</p>

</div>
</div>
<a class="anchor" id="a5eb038c3271dbf41ac7ebc02fad3907f"></a><!-- doxytag: member="ogr_api.h::OGR_G_Length" ref="a5eb038c3271dbf41ac7ebc02fad3907f" args="(OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGR_G_Length </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute length of a geometry. </p>
<p>Computes the area for <a class="el" href="classOGRCurve.html">OGRCurve</a> or MultiCurve objects. Undefined for all other geometry types (returns zero).</p>
<p>This function utilizes the C++ get_Length() method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>the geometry to operate on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the lenght or 0.0 for unsupported geometry types.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.8.0 </dd></dl>

<p>References <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa7f299e8edaee30fd3c7a40baf19b48b1">wkbGeometryCollection</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa48a515899277ce8ccd0bb6041fd42bcc">wkbLinearRing</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa09fd8f51759a1cf351b04e786a2a9058">wkbLineString</a>, and <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa2ecf4d40ab038779cbc1de22ddcb3429">wkbMultiLineString</a>.</p>

</div>
</div>
<a class="anchor" id="a07acfe1bef39cd2cd1ad4a5ec26f2ceb"></a><!-- doxytag: member="ogr_api.h::OGR_G_Overlaps" ref="a07acfe1bef39cd2cd1ad4a5ec26f2ceb" args="(OGRGeometryH, OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_Overlaps </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hOther</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test for overlap. </p>
<p>Tests if this geometry and the other geometry overlap, that is their intersection has a non-zero area.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#afc672c524568f3ee6ee5257b250d2b12" title="Test for overlap.">OGRGeometry::Overlaps()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hThis</em>&nbsp;</td><td>the geometry to compare. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hOther</em>&nbsp;</td><td>the other geometry to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if they are overlapping, otherwise FALSE. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a07acfe1bef39cd2cd1ad4a5ec26f2ceb">OGR_G_Overlaps()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a07acfe1bef39cd2cd1ad4a5ec26f2ceb">OGR_G_Overlaps()</a>.</p>

</div>
</div>
<a class="anchor" id="af89dc63f138aee453cf8ff3e2b1c0833"></a><!-- doxytag: member="ogr_api.h::OGR_G_PointOnSurface" ref="af89dc63f138aee453cf8ff3e2b1c0833" args="(OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRGeometryH OGR_G_PointOnSurface </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a point guaranteed to lie on the surface. </p>
<p>This method relates to the SFCOM ISurface::get_PointOnSurface() method however the current implementation based on GEOS can operate on other geometry types than the types that are supported by SQL/MM-Part 3 : surfaces (polygons) and multisurfaces (multipolygons).</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>the geometry to operate on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a point guaranteed to lie on the surface or NULL if an error occured.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.10 </dd></dl>

<p>References <a class="el" href="classOGRGeometry.html#a4308e3549c65aa12cc2ba41be15d99a0">OGRGeometry::assignSpatialReference()</a>, <a class="el" href="classOGRGeometry.html#a5c6bca18682cb933e3227552d480e1a5">OGRGeometry::getGeometryType()</a>, <a class="el" href="classOGRGeometry.html#a194f0bbdae896539852106cafbffbe87">OGRGeometry::getSpatialReference()</a>, <a class="el" href="ogr__api_8h.html#af89dc63f138aee453cf8ff3e2b1c0833">OGR_G_PointOnSurface()</a>, and <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa6f8377c5a4a9d36ae2384f4a5f45d77f">wkbPoint</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#af89dc63f138aee453cf8ff3e2b1c0833">OGR_G_PointOnSurface()</a>, and <a class="el" href="classOGRPolygon.html#a76e64f21cd31a6256cc425a6b5639069">OGRPolygon::PointOnSurface()</a>.</p>

</div>
</div>
<a class="anchor" id="a673c6c4745d5092fb250ae5342bc1b3b"></a><!-- doxytag: member="ogr_api.h::OGR_G_Polygonize" ref="a673c6c4745d5092fb250ae5342bc1b3b" args="(OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRGeometryH OGR_G_Polygonize </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hTarget</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Polygonizes a set of sparse edges. </p>
<p>A new geometry object is created and returned containing a collection of reassembled Polygons: NULL will be returned if the input collection doesn't corresponds to a MultiLinestring, or when reassembling Edges into Polygons is impossible due to topogical inconsistencies.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a674319670e735bf6d4049300096157ec" title="Polygonizes a set of sparse edges.">OGRGeometry::Polygonize()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hTarget</em>&nbsp;</td><td>The Geometry to be polygonized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a handle to a newly allocated geometry now owned by the caller, or NULL on failure.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.9.0 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a673c6c4745d5092fb250ae5342bc1b3b">OGR_G_Polygonize()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a673c6c4745d5092fb250ae5342bc1b3b">OGR_G_Polygonize()</a>.</p>

</div>
</div>
<a class="anchor" id="a54ea024bb659e48d3297404e53800237"></a><!-- doxytag: member="ogr_api.h::OGR_G_RemoveGeometry" ref="a54ea024bb659e48d3297404e53800237" args="(OGRGeometryH, int, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_G_RemoveGeometry </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bDelete</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove a geometry from an exiting geometry container. </p>
<p>Removing a geometry will cause the geometry count to drop by one, and all "higher" geometries will shuffle down one in index.</p>
<p>There is no SFCOM analog to this method.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometryCollection.html#ae37405203118eeb0430ef38668a385b7" title="Remove a geometry from the container.">OGRGeometryCollection::removeGeometry()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>the existing geometry to delete from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iGeom</em>&nbsp;</td><td>the index of the geometry to delete. A value of -1 is a special flag meaning that all geometries should be removed.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bDelete</em>&nbsp;</td><td>if TRUE the geometry will be destroyed, otherwise it will not. The default is TRUE as the existing geometry is considered to own the geometries in it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE if successful, or OGRERR_FAILURE if the index is out of range. </dd></dl>

<p>References <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa7f299e8edaee30fd3c7a40baf19b48b1">wkbGeometryCollection</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa2ecf4d40ab038779cbc1de22ddcb3429">wkbMultiLineString</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa826c812d3551fa07feb4c3664517c29c">wkbMultiPoint</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa7ff2322e0696d383d7715b7e7be1a7b1">wkbMultiPolygon</a>, and <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa11991cd1245f146f3efd694553433aeb">wkbPolygon</a>.</p>

</div>
</div>
<a class="anchor" id="ade9f08c8d63bc0e726cb20c201c86423"></a><!-- doxytag: member="ogr_api.h::OGR_G_Segmentize" ref="ade9f08c8d63bc0e726cb20c201c86423" args="(OGRGeometryH hGeom, double dfMaxLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_Segmentize </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfMaxLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modify the geometry such it has no segment longer then the given distance. </p>
<p>Interpolated points will have Z and M values (if needed) set to 0. Distance computation is performed in 2d only</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#a91685bd7c0bdd67cd073a8b4da3c06a5" title="Modify the geometry such it has no segment longer then the given distance.">OGRGeometry::segmentize()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle on the geometry to segmentize </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfMaxLength</em>&nbsp;</td><td>the maximum distance between 2 points after segmentization </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#ade9f08c8d63bc0e726cb20c201c86423">OGR_G_Segmentize()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ade9f08c8d63bc0e726cb20c201c86423">OGR_G_Segmentize()</a>.</p>

</div>
</div>
<a class="anchor" id="ac6bcad9553f488f7d8b6c8674cf7771c"></a><!-- doxytag: member="ogr_api.h::OGR_G_SetCoordinateDimension" ref="ac6bcad9553f488f7d8b6c8674cf7771c" args="(OGRGeometryH, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_SetCoordinateDimension </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nNewDimension</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the coordinate dimension. </p>
<p>This method sets the explicit coordinate dimension. Setting the coordinate dimension of a geometry to 2 should zero out any existing Z values. Setting the dimension of a geometry collection will not necessarily affect the children geometries.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle on the geometry to set the dimension of the coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nNewDimension</em>&nbsp;</td><td>New coordinate dimension value, either 2 or 3. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#ac6bcad9553f488f7d8b6c8674cf7771c">OGR_G_SetCoordinateDimension()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ac6bcad9553f488f7d8b6c8674cf7771c">OGR_G_SetCoordinateDimension()</a>.</p>

</div>
</div>
<a class="anchor" id="a303fb1a2a94363c15f9e61dc46b710e8"></a><!-- doxytag: member="ogr_api.h::OGR_G_SetPoint" ref="a303fb1a2a94363c15f9e61dc46b710e8" args="(OGRGeometryH, int iPoint, double, double, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_SetPoint </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfZ</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the location of a vertex in a point or linestring geometry. </p>
<p>If iPoint is larger than the number of existing points in the linestring, the point count will be increased to accomodate the request.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle to the geometry to add a vertex to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>the index of the vertex to assign (zero based) or zero for a point. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfX</em>&nbsp;</td><td>input X coordinate to assign. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfY</em>&nbsp;</td><td>input Y coordinate to assign. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfZ</em>&nbsp;</td><td>input Z coordinate to assign (defaults to zero). </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa09fd8f51759a1cf351b04e786a2a9058">wkbLineString</a>, and <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa6f8377c5a4a9d36ae2384f4a5f45d77f">wkbPoint</a>.</p>

</div>
</div>
<a class="anchor" id="ab14b9730d6f9fc829fe6be9bc2a5ec48"></a><!-- doxytag: member="ogr_api.h::OGR_G_SetPoint_2D" ref="ab14b9730d6f9fc829fe6be9bc2a5ec48" args="(OGRGeometryH, int iPoint, double, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_SetPoint_2D </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfY</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the location of a vertex in a point or linestring geometry. </p>
<p>If iPoint is larger than the number of existing points in the linestring, the point count will be increased to accomodate the request.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle to the geometry to add a vertex to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>the index of the vertex to assign (zero based) or zero for a point. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfX</em>&nbsp;</td><td>input X coordinate to assign. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfY</em>&nbsp;</td><td>input Y coordinate to assign. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa09fd8f51759a1cf351b04e786a2a9058">wkbLineString</a>, and <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa6f8377c5a4a9d36ae2384f4a5f45d77f">wkbPoint</a>.</p>

</div>
</div>
<a class="anchor" id="a4f4f7bff0d685b2713504bd89b14d0fc"></a><!-- doxytag: member="ogr_api.h::OGR_G_SetPointCount" ref="a4f4f7bff0d685b2713504bd89b14d0fc" args="(OGRGeometryH hGeom, int nNewPointCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_SetPointCount </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nNewPointCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set number of points in a geometry. </p>
<p>This method primary exists to preset the number of points in a linestring geometry before setPoint() is used to assign them to avoid reallocating the array larger with each call to addPoint().</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nNewPointCount</em>&nbsp;</td><td>the new number of points for geometry. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classOGRLineString.html#a7d7d288f869c9431a88d2012d96132b9">OGRLineString::setNumPoints()</a>, and <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa09fd8f51759a1cf351b04e786a2a9058">wkbLineString</a>.</p>

</div>
</div>
<a class="anchor" id="a20abd3bb0d4a31b758883312db11cb70"></a><!-- doxytag: member="ogr_api.h::OGR_G_SetPoints" ref="a20abd3bb0d4a31b758883312db11cb70" args="(OGRGeometryH hGeom, int nPointsIn, void *pabyX, int nXStride, void *pabyY, int nYStride, void *pabyZ, int nZStride)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_SetPoints </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nPointsIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pabyX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nXStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pabyY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nYStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pabyZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nZStride</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assign all points in a point or a line string geometry. </p>
<p>This method clear any existing points assigned to this geometry, and assigns a whole new set.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle to the geometry to set the coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nPointsIn</em>&nbsp;</td><td>number of points being passed in padfX and padfY. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfX</em>&nbsp;</td><td>list of X coordinates of points being assigned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nXStride</em>&nbsp;</td><td>the number of bytes between 2 elements of pabyX. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfY</em>&nbsp;</td><td>list of Y coordinates of points being assigned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nYStride</em>&nbsp;</td><td>the number of bytes between 2 elements of pabyY. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfZ</em>&nbsp;</td><td>list of Z coordinates of points being assigned (defaults to NULL for 2D objects). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nZStride</em>&nbsp;</td><td>the number of bytes between 2 elements of pabyZ. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classOGRLineString.html#a7d7d288f869c9431a88d2012d96132b9">OGRLineString::setNumPoints()</a>, <a class="el" href="classOGRLineString.html#a68fe89e30ccbfaf76c481349c13968c4">OGRLineString::setPoint()</a>, <a class="el" href="classOGRLineString.html#a49a2c161f48b2bd5ad6c7e2832c0cf15">OGRLineString::setPoints()</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa09fd8f51759a1cf351b04e786a2a9058">wkbLineString</a>, and <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa6f8377c5a4a9d36ae2384f4a5f45d77f">wkbPoint</a>.</p>

</div>
</div>
<a class="anchor" id="a0453f97e9d4fc44e13787ad1a8439c0c"></a><!-- doxytag: member="ogr_api.h::OGR_G_Simplify" ref="a0453f97e9d4fc44e13787ad1a8439c0c" args="(OGRGeometryH hThis, double tolerance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRGeometryH OGR_G_Simplify </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dTolerance</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute a simplified geometry. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#afd3ea0ffa1e2994427032d0212206ccf" title="Simplify the geometry.">OGRGeometry::Simplify()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hThis</em>&nbsp;</td><td>the geometry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dTolerance</em>&nbsp;</td><td>the distance tolerance for the simplification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the simplified geometry or NULL if an error occurs.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.8.0 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a0453f97e9d4fc44e13787ad1a8439c0c">OGR_G_Simplify()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a0453f97e9d4fc44e13787ad1a8439c0c">OGR_G_Simplify()</a>.</p>

</div>
</div>
<a class="anchor" id="a8e19e9cfa01744db6a2e8eee710611b6"></a><!-- doxytag: member="ogr_api.h::OGR_G_SimplifyPreserveTopology" ref="a8e19e9cfa01744db6a2e8eee710611b6" args="(OGRGeometryH hThis, double tolerance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRGeometryH OGR_G_SimplifyPreserveTopology </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dTolerance</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Simplify the geometry while preserving topology. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a6b770f62585c9e6081fda50d270ffbd9" title="Simplify the geometry while preserving topology.">OGRGeometry::SimplifyPreserveTopology()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hThis</em>&nbsp;</td><td>the geometry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dTolerance</em>&nbsp;</td><td>the distance tolerance for the simplification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the simplified geometry or NULL if an error occurs.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.9.0 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a8e19e9cfa01744db6a2e8eee710611b6">OGR_G_SimplifyPreserveTopology()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a8e19e9cfa01744db6a2e8eee710611b6">OGR_G_SimplifyPreserveTopology()</a>.</p>

</div>
</div>
<a class="anchor" id="a2b047fca89d06a08a5c34f210c4c97d5"></a><!-- doxytag: member="ogr_api.h::OGR_G_SymDifference" ref="a2b047fca89d06a08a5c34f210c4c97d5" args="(OGRGeometryH, OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRGeometryH OGR_G_SymDifference </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hOther</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute symmetric difference. </p>
<p>Generates a new geometry which is the symmetric difference of this geometry and the other geometry.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a61d73b46cfa6488167dd4005f85c7ca0" title="Compute symmetric difference (deprecated).">OGRGeometry::SymmetricDifference()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hThis</em>&nbsp;</td><td>the geometry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hOther</em>&nbsp;</td><td>the other geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new geometry representing the symmetric difference or NULL if the difference is empty or an error occurs.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.8.0 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a2b047fca89d06a08a5c34f210c4c97d5">OGR_G_SymDifference()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a2b047fca89d06a08a5c34f210c4c97d5">OGR_G_SymDifference()</a>.</p>

</div>
</div>
<a class="anchor" id="aed147010bb540b4710c68d30c62da50f"></a><!-- doxytag: member="ogr_api.h::OGR_G_SymmetricDifference" ref="aed147010bb540b4710c68d30c62da50f" args="(OGRGeometryH, OGRGeometryH) CPL_WARN_DEPRECATED(&quot;Non standard method. Use OGR_G_SymDifference() instead&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRGeometryH OGR_G_SymmetricDifference </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hOther</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute symmetric difference (deprecated). </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated:</a></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="ogr__api_8h.html#aed147010bb540b4710c68d30c62da50f" title="Compute symmetric difference (deprecated).">OGR_G_SymmetricDifference()</a> </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#aed147010bb540b4710c68d30c62da50f">OGR_G_SymmetricDifference()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#aed147010bb540b4710c68d30c62da50f">OGR_G_SymmetricDifference()</a>.</p>

</div>
</div>
<a class="anchor" id="a6f67616eb88f479eba50f9783c8494d9"></a><!-- doxytag: member="ogr_api.h::OGR_G_Touches" ref="a6f67616eb88f479eba50f9783c8494d9" args="(OGRGeometryH, OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_Touches </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hOther</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test for touching. </p>
<p>Tests if this geometry and the other geometry are touching.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a5d3e23c20b51ceb5a56d397f812a81a2" title="Test for touching.">OGRGeometry::Touches()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hThis</em>&nbsp;</td><td>the geometry to compare. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hOther</em>&nbsp;</td><td>the other geometry to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if they are touching, otherwise FALSE. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a6f67616eb88f479eba50f9783c8494d9">OGR_G_Touches()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a6f67616eb88f479eba50f9783c8494d9">OGR_G_Touches()</a>.</p>

</div>
</div>
<a class="anchor" id="a59a5b3f954b11cfbf6e78807c28d6090"></a><!-- doxytag: member="ogr_api.h::OGR_G_Transform" ref="a59a5b3f954b11cfbf6e78807c28d6090" args="(OGRGeometryH, OGRCoordinateTransformationH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_G_Transform </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRCoordinateTransformationH&nbsp;</td>
          <td class="paramname"> <em>hTransform</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply arbitrary coordinate transformation to geometry. </p>
<p>This function will transform the coordinates of a geometry from their current spatial reference system to a new target spatial reference system. Normally this means reprojecting the vectors, but it could include datum shifts, and changes of units.</p>
<p>Note that this function does not require that the geometry already have a spatial reference system. It will be assumed that they can be treated as having the source spatial reference system of the <a class="el" href="classOGRCoordinateTransformation.html">OGRCoordinateTransformation</a> object, and the actual SRS of the geometry will be ignored. On successful completion the output <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> of the <a class="el" href="classOGRCoordinateTransformation.html">OGRCoordinateTransformation</a> will be assigned to the geometry.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#aa9e8bfb3c2129f25cf622660f734e1ba" title="Apply arbitrary coordinate transformation to geometry.">OGRGeometry::transform</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle on the geometry to apply the transform to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hTransform</em>&nbsp;</td><td>handle on the transformation to apply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE on success or an error code. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a59a5b3f954b11cfbf6e78807c28d6090">OGR_G_Transform()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a59a5b3f954b11cfbf6e78807c28d6090">OGR_G_Transform()</a>.</p>

</div>
</div>
<a class="anchor" id="a43af4c2127cea0a5059692a62c0feb63"></a><!-- doxytag: member="ogr_api.h::OGR_G_TransformTo" ref="a43af4c2127cea0a5059692a62c0feb63" args="(OGRGeometryH, OGRSpatialReferenceH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_G_TransformTo </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRSpatialReferenceH&nbsp;</td>
          <td class="paramname"> <em>hSRS</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transform geometry to new spatial reference system. </p>
<p>This function will transform the coordinates of a geometry from their current spatial reference system to a new target spatial reference system. Normally this means reprojecting the vectors, but it could include datum shifts, and changes of units.</p>
<p>This function will only work if the geometry already has an assigned spatial reference system, and if it is transformable to the target coordinate system.</p>
<p>Because this function requires internal creation and initialization of an <a class="el" href="classOGRCoordinateTransformation.html">OGRCoordinateTransformation</a> object it is significantly more expensive to use this function to transform many geometries than it is to create the <a class="el" href="classOGRCoordinateTransformation.html">OGRCoordinateTransformation</a> in advance, and call transform() with that transformation. This function exists primarily for convenience when only transforming a single geometry.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#ae3f0b441fbf2f66ce3ef3571268ab10f" title="Transform geometry to new spatial reference system.">OGRGeometry::transformTo</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle on the geometry to apply the transform to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hSRS</em>&nbsp;</td><td>handle on the spatial reference system to apply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE on success, or an error code. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a43af4c2127cea0a5059692a62c0feb63">OGR_G_TransformTo()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a43af4c2127cea0a5059692a62c0feb63">OGR_G_TransformTo()</a>.</p>

</div>
</div>
<a class="anchor" id="af58f2cfbdb2497659d2eabea73d3b8a0"></a><!-- doxytag: member="ogr_api.h::OGR_G_Union" ref="af58f2cfbdb2497659d2eabea73d3b8a0" args="(OGRGeometryH, OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRGeometryH OGR_G_Union </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hOther</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute union. </p>
<p>Generates a new geometry which is the region of union of the two geometries operated on.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a15fb98d101f5887f7c3af40b6da5a3c4" title="Compute union.">OGRGeometry::Union()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hThis</em>&nbsp;</td><td>the geometry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hOther</em>&nbsp;</td><td>the other geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new geometry representing the union or NULL if an error occurs. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#af58f2cfbdb2497659d2eabea73d3b8a0">OGR_G_Union()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#af58f2cfbdb2497659d2eabea73d3b8a0">OGR_G_Union()</a>.</p>

</div>
</div>
<a class="anchor" id="a2bb45d7d6ca9641be5f0773f1d60aa0f"></a><!-- doxytag: member="ogr_api.h::OGR_G_UnionCascaded" ref="a2bb45d7d6ca9641be5f0773f1d60aa0f" args="(OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRGeometryH OGR_G_UnionCascaded </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hThis</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute union using cascading. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a2ba2d777083c60fe707a40d2adc36f20" title="Compute union using cascading.">OGRGeometry::UnionCascaded()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hThis</em>&nbsp;</td><td>the geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new geometry representing the union or NULL if an error occurs. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a2bb45d7d6ca9641be5f0773f1d60aa0f">OGR_G_UnionCascaded()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a2bb45d7d6ca9641be5f0773f1d60aa0f">OGR_G_UnionCascaded()</a>.</p>

</div>
</div>
<a class="anchor" id="a80ba9e516ccae381ae7240cc9684eb72"></a><!-- doxytag: member="ogr_api.h::OGR_G_Within" ref="a80ba9e516ccae381ae7240cc9684eb72" args="(OGRGeometryH, OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_Within </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hOther</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test for containment. </p>
<p>Tests if this geometry is within the other geometry.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#abb4bb4687de9b6f23e61b686177b2856" title="Test for containment.">OGRGeometry::Within()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hThis</em>&nbsp;</td><td>the geometry to compare. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hOther</em>&nbsp;</td><td>the other geometry to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if hThis is within hOther, otherwise FALSE. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a80ba9e516ccae381ae7240cc9684eb72">OGR_G_Within()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a80ba9e516ccae381ae7240cc9684eb72">OGR_G_Within()</a>.</p>

</div>
</div>
<a class="anchor" id="a5f7035a933b957a9d453184c154c237c"></a><!-- doxytag: member="ogr_api.h::OGR_G_WkbSize" ref="a5f7035a933b957a9d453184c154c237c" args="(OGRGeometryH hGeom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_WkbSize </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns size of related binary representation. </p>
<p>This function returns the exact number of bytes required to hold the well known binary representation of this geometry object. Its computation may be slightly expensive for complex geometries.</p>
<p>This function relates to the SFCOM IWks::WkbSize() method.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#acd1a8164dae2e44e50990756ed6b8b4a" title="Returns size of related binary representation.">OGRGeometry::WkbSize()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle on the geometry to get the binary size from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>size of binary representation in bytes. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a5f7035a933b957a9d453184c154c237c">OGR_G_WkbSize()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a5f7035a933b957a9d453184c154c237c">OGR_G_WkbSize()</a>.</p>

</div>
</div>
<a class="anchor" id="af1e61b89ae2d799cf5e217d01ef7b415"></a><!-- doxytag: member="ogr_api.h::OGR_GetFieldTypeName" ref="af1e61b89ae2d799cf5e217d01ef7b415" args="(OGRFieldType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_GetFieldTypeName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a>&nbsp;</td>
          <td class="paramname"> <em>eType</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch human readable name for a field type. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#afc2a020f72be8296b6e09f5ab979f930" title="Fetch human readable name for a field type.">OGRFieldDefn::GetFieldTypeName()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>eType</em>&nbsp;</td><td>the field type to get name for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the name. </dd></dl>

<p>References <a class="el" href="classOGRFieldDefn.html#afc2a020f72be8296b6e09f5ab979f930">OGRFieldDefn::GetFieldTypeName()</a>, and <a class="el" href="ogr__api_8h.html#af1e61b89ae2d799cf5e217d01ef7b415">OGR_GetFieldTypeName()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#af1e61b89ae2d799cf5e217d01ef7b415">OGR_GetFieldTypeName()</a>.</p>

</div>
</div>
<a class="anchor" id="a4681750642cae49933ba4fc962744b78"></a><!-- doxytag: member="ogr_api.h::OGR_GFld_Create" ref="a4681750642cae49933ba4fc962744b78" args="(const char *, OGRwkbGeometryType) CPL_WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRGeomFieldDefnH OGR_GFld_Create </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&nbsp;</td>
          <td class="paramname"> <em>eType</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new field geometry definition. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeomFieldDefn.html#ac69cdfca5b480465569b88bc4f9f7765" title="Constructor.">OGRGeomFieldDefn::OGRGeomFieldDefn()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszName</em>&nbsp;</td><td>the name of the new field definition. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eType</em>&nbsp;</td><td>the type of the new field definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>handle to the new field definition.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.11 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a4681750642cae49933ba4fc962744b78">OGR_GFld_Create()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a4681750642cae49933ba4fc962744b78">OGR_GFld_Create()</a>.</p>

</div>
</div>
<a class="anchor" id="a0f3e65993ea2b8b907e43ffa8b106871"></a><!-- doxytag: member="ogr_api.h::OGR_GFld_Destroy" ref="a0f3e65993ea2b8b907e43ffa8b106871" args="(OGRGeomFieldDefnH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_GFld_Destroy </td>
          <td>(</td>
          <td class="paramtype">OGRGeomFieldDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy a geometry field definition. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the geometry field definition to destroy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.11 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a0f3e65993ea2b8b907e43ffa8b106871">OGR_GFld_Destroy()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a0f3e65993ea2b8b907e43ffa8b106871">OGR_GFld_Destroy()</a>.</p>

</div>
</div>
<a class="anchor" id="ad9914366a6cc3b4169a3359c2b1ef614"></a><!-- doxytag: member="ogr_api.h::OGR_GFld_GetNameRef" ref="ad9914366a6cc3b4169a3359c2b1ef614" args="(OGRGeomFieldDefnH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_GFld_GetNameRef </td>
          <td>(</td>
          <td class="paramtype">OGRGeomFieldDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch name of this field. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeomFieldDefn.html#a8dbbb2a2630752eda8702cd4196ed4c6" title="Fetch name of this field.">OGRGeomFieldDefn::GetNameRef()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the geometry field definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the name of the geometry field definition.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.11 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#ad9914366a6cc3b4169a3359c2b1ef614">OGR_GFld_GetNameRef()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ad9914366a6cc3b4169a3359c2b1ef614">OGR_GFld_GetNameRef()</a>.</p>

</div>
</div>
<a class="anchor" id="a7927b11a85659d8ce6da8857f52b05c4"></a><!-- doxytag: member="ogr_api.h::OGR_GFld_GetSpatialRef" ref="a7927b11a85659d8ce6da8857f52b05c4" args="(OGRGeomFieldDefnH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRSpatialReferenceH OGR_GFld_GetSpatialRef </td>
          <td>(</td>
          <td class="paramtype">OGRGeomFieldDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch spatial reference system of this field. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeomFieldDefn.html#ae043691f36413950ea2ec0c3495ac959" title="Fetch spatial reference system of this field.">OGRGeomFieldDefn::GetSpatialRef()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the geometry field definition</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>field spatial reference system.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.11 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a7927b11a85659d8ce6da8857f52b05c4">OGR_GFld_GetSpatialRef()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a7927b11a85659d8ce6da8857f52b05c4">OGR_GFld_GetSpatialRef()</a>.</p>

</div>
</div>
<a class="anchor" id="a323f4350c2e90c6e67df37f68d244a0d"></a><!-- doxytag: member="ogr_api.h::OGR_GFld_GetType" ref="a323f4350c2e90c6e67df37f68d244a0d" args="(OGRGeomFieldDefnH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a> OGR_GFld_GetType </td>
          <td>(</td>
          <td class="paramtype">OGRGeomFieldDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch geometry type of this field. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeomFieldDefn.html#a1b628044cd6d2142a1732f5c5ef41bd6" title="Fetch geometry type of this field.">OGRGeomFieldDefn::GetType()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the geometry field definition to get type from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>field geometry type.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.11 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a323f4350c2e90c6e67df37f68d244a0d">OGR_GFld_GetType()</a>, and <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa3645f782f9b9f7632d7e7cdd0451d58f">wkbUnknown</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a323f4350c2e90c6e67df37f68d244a0d">OGR_GFld_GetType()</a>.</p>

</div>
</div>
<a class="anchor" id="ab232798830d8dcae0742d83948e33d1a"></a><!-- doxytag: member="ogr_api.h::OGR_GFld_IsIgnored" ref="ab232798830d8dcae0742d83948e33d1a" args="(OGRGeomFieldDefnH hDefn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_GFld_IsIgnored </td>
          <td>(</td>
          <td class="paramtype">OGRGeomFieldDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return whether this field should be omitted when fetching features. </p>
<p>This method is the same as the C++ method <a class="el" href="classOGRGeomFieldDefn.html#a4ccd20966ad367adc7e16ee628056689" title="Return whether this field should be omitted when fetching features.">OGRGeomFieldDefn::IsIgnored()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the geometry field definition </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>ignore state</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.11 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#ab232798830d8dcae0742d83948e33d1a">OGR_GFld_IsIgnored()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ab232798830d8dcae0742d83948e33d1a">OGR_GFld_IsIgnored()</a>.</p>

</div>
</div>
<a class="anchor" id="af3a4e5e2af01140209e9d2814869eb41"></a><!-- doxytag: member="ogr_api.h::OGR_GFld_SetIgnored" ref="af3a4e5e2af01140209e9d2814869eb41" args="(OGRGeomFieldDefnH hDefn, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_GFld_SetIgnored </td>
          <td>(</td>
          <td class="paramtype">OGRGeomFieldDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ignore</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set whether this field should be omitted when fetching features. </p>
<p>This method is the same as the C++ method <a class="el" href="classOGRGeomFieldDefn.html#a387cedc1973472c54237944bfb530b25" title="Set whether this field should be omitted when fetching features.">OGRGeomFieldDefn::SetIgnored()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the geometry field definition </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ignore</em>&nbsp;</td><td>ignore state</td></tr>
  </table>
  </dd>
</dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.11 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#af3a4e5e2af01140209e9d2814869eb41">OGR_GFld_SetIgnored()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#af3a4e5e2af01140209e9d2814869eb41">OGR_GFld_SetIgnored()</a>.</p>

</div>
</div>
<a class="anchor" id="a6c9b9d56381cae346c5129943641f628"></a><!-- doxytag: member="ogr_api.h::OGR_GFld_SetName" ref="a6c9b9d56381cae346c5129943641f628" args="(OGRGeomFieldDefnH, const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_GFld_SetName </td>
          <td>(</td>
          <td class="paramtype">OGRGeomFieldDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset the name of this field. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeomFieldDefn.html#ae3ca3a2ccdea222a2675cd0f7eeb57f7" title="Reset the name of this field.">OGRGeomFieldDefn::SetName()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the geometry field definition to apply the new name to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszName</em>&nbsp;</td><td>the new name to apply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.11 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a6c9b9d56381cae346c5129943641f628">OGR_GFld_SetName()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a6c9b9d56381cae346c5129943641f628">OGR_GFld_SetName()</a>.</p>

</div>
</div>
<a class="anchor" id="aa717acc8f4f5f33825334fe72edc2be9"></a><!-- doxytag: member="ogr_api.h::OGR_GFld_SetSpatialRef" ref="aa717acc8f4f5f33825334fe72edc2be9" args="(OGRGeomFieldDefnH, OGRSpatialReferenceH hSRS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_GFld_SetSpatialRef </td>
          <td>(</td>
          <td class="paramtype">OGRGeomFieldDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRSpatialReferenceH&nbsp;</td>
          <td class="paramname"> <em>hSRS</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the spatial reference of this field. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeomFieldDefn.html#aeae0b00cc5a55b49aa51262d0a736bae" title="Set the spatial reference of this field.">OGRGeomFieldDefn::SetSpatialRef()</a>.</p>
<p>This function drops the reference of the previously set SRS object and acquires a new reference on the passed object (if non-NULL).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the geometry field definition </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hSRS</em>&nbsp;</td><td>the new SRS to apply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.11 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#aa717acc8f4f5f33825334fe72edc2be9">OGR_GFld_SetSpatialRef()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#aa717acc8f4f5f33825334fe72edc2be9">OGR_GFld_SetSpatialRef()</a>.</p>

</div>
</div>
<a class="anchor" id="affb3691474967ca5f0c9789e0626d55f"></a><!-- doxytag: member="ogr_api.h::OGR_GFld_SetType" ref="affb3691474967ca5f0c9789e0626d55f" args="(OGRGeomFieldDefnH, OGRwkbGeometryType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_GFld_SetType </td>
          <td>(</td>
          <td class="paramtype">OGRGeomFieldDefnH&nbsp;</td>
          <td class="paramname"> <em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&nbsp;</td>
          <td class="paramname"> <em>eType</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the geometry type of this field. This should never be done to an <a class="el" href="classOGRGeomFieldDefn.html">OGRGeomFieldDefn</a> that is already part of an <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a>. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeomFieldDefn.html#a9b030e08d01a09b1917c1d01638a4ac8" title="Set the geometry type of this field. This should never be done to an OGRGeomFieldDefn that is already...">OGRGeomFieldDefn::SetType()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDefn</em>&nbsp;</td><td>handle to the geometry field definition to set type to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eType</em>&nbsp;</td><td>the new field geometry type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.11 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#affb3691474967ca5f0c9789e0626d55f">OGR_GFld_SetType()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#affb3691474967ca5f0c9789e0626d55f">OGR_GFld_SetType()</a>.</p>

</div>
</div>
<a class="anchor" id="a679904d97c1084f309706ac3c6228cec"></a><!-- doxytag: member="ogr_api.h::OGR_L_AlterFieldDefn" ref="a679904d97c1084f309706ac3c6228cec" args="(OGRLayerH, int iField, OGRFieldDefnH hNewFieldDefn, int nFlags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_L_AlterFieldDefn </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRFieldDefnH&nbsp;</td>
          <td class="paramname"> <em>hNewFieldDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nFlags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Alter the definition of an existing field on a layer. </p>
<p>You must use this to alter the definition of an existing field of a real layer. Internally the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> for the layer will be updated to reflect the altered field. Applications should never modify the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> used by a layer directly.</p>
<p>This function should not be called while there are feature objects in existance that were obtained or created with the previous layer definition.</p>
<p>Not all drivers support this function. You can query a layer to check if it supports it with the OLCAlterFieldDefn capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existings features of the backing file/database should be updated accordingly. Some drivers might also not support all update flags.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a71e69a665e93001d48a4339695f33c1a" title="Alter the definition of an existing field on a layer.">OGRLayer::AlterFieldDefn()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hLayer</em>&nbsp;</td><td>handle to the layer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iField</em>&nbsp;</td><td>index of the field whose definition must be altered. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hNewFieldDefn</em>&nbsp;</td><td>new field definition </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nFlags</em>&nbsp;</td><td>combination of ALTER_NAME_FLAG, ALTER_TYPE_FLAG and ALTER_WIDTH_PRECISION_FLAG to indicate which of the name and/or type and/or width and precision fields from the new field definition must be taken into account.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE on success.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.9.0 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a679904d97c1084f309706ac3c6228cec">OGR_L_AlterFieldDefn()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a679904d97c1084f309706ac3c6228cec">OGR_L_AlterFieldDefn()</a>.</p>

</div>
</div>
<a class="anchor" id="ae12dcd5dc6dc5f930218573658f1b5c2"></a><!-- doxytag: member="ogr_api.h::OGR_L_Clip" ref="ae12dcd5dc6dc5f930218573658f1b5c2" args="(OGRLayerH, OGRLayerH, OGRLayerH, char **, GDALProgressFunc, void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_L_Clip </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>pLayerInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>pLayerMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>pLayerResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&nbsp;</td>
          <td class="paramname"> <em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pProgressArg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clip off areas that are not covered by the method layer. </p>
<p>The result layer contains features whose geometries represent areas that are in the input layer and in the method layer. The features in the result layer have the (possibly clipped) areas of features in the input layer and the attributes from the same features. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in the input layer.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</dd>
<dd>
This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</dd></dl>
<p>The recognized list of options is : </p>
<ul>
<li>
SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted. </li>
<li>
PROMOTE_TO_MULTI=YES/NO. Set it to YES to convert Polygons into MultiPolygons, or LineStrings to MultiLineStrings. </li>
<li>
INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer. </li>
<li>
METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer. </li>
</ul>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a56d7ee3b2020e53c730d67ee4f1e2fb6" title="Clip off areas that are not covered by the method layer.">OGRLayer::Clip()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pLayerInput</em>&nbsp;</td><td>the input layer. Should not be NULL.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pLayerMethod</em>&nbsp;</td><td>the method layer. Should not be NULL.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pLayerResult</em>&nbsp;</td><td>the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>papszOptions</em>&nbsp;</td><td>NULL terminated list of options (may be NULL).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnProgress</em>&nbsp;</td><td>a GDALProgressFunc() compatible callback function for reporting progress or NULL.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pProgressArg</em>&nbsp;</td><td>argument to be passed to pfnProgress. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.10 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#ae12dcd5dc6dc5f930218573658f1b5c2">OGR_L_Clip()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ae12dcd5dc6dc5f930218573658f1b5c2">OGR_L_Clip()</a>.</p>

</div>
</div>
<a class="anchor" id="a6135ef3b16c3cc974682365783603cc6"></a><!-- doxytag: member="ogr_api.h::OGR_L_CommitTransaction" ref="a6135ef3b16c3cc974682365783603cc6" args="(OGRLayerH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_L_CommitTransaction </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>hLayer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For datasources which support transactions, CommitTransaction commits a transaction. </p>
<p>If no transaction is active, or the commit fails, will return OGRERR_FAILURE. Datasources which do not support transactions will always return OGRERR_NONE.</p>
<p>This function is the same as the C++ method OGRLayer::CommitTransaction().</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hLayer</em>&nbsp;</td><td>handle to the layer</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE on success. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a6135ef3b16c3cc974682365783603cc6">OGR_L_CommitTransaction()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a6135ef3b16c3cc974682365783603cc6">OGR_L_CommitTransaction()</a>.</p>

</div>
</div>
<a class="anchor" id="a301d319111285a47fe6cda6e079214f8"></a><!-- doxytag: member="ogr_api.h::OGR_L_CreateFeature" ref="a301d319111285a47fe6cda6e079214f8" args="(OGRLayerH, OGRFeatureH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_L_CreateFeature </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create and write a new feature within a layer. </p>
<p>The passed feature is written to the layer as a new feature, rather than overwriting an existing one. If the feature has a feature id other than OGRNullFID, then the native implementation may use that as the feature id of the new feature, but not necessarily. Upon successful return the passed feature will have been updated with the new feature id.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#aaa1e32016f481596a55e1d988a15a067" title="Create and write a new feature within a layer.">OGRLayer::CreateFeature()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hLayer</em>&nbsp;</td><td>handle to the layer to write the feature to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>the handle of the feature to write to disk.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE on success. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a301d319111285a47fe6cda6e079214f8">OGR_L_CreateFeature()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a301d319111285a47fe6cda6e079214f8">OGR_L_CreateFeature()</a>.</p>

</div>
</div>
<a class="anchor" id="aab585ef1166c61c4819f7fd46ee4a275"></a><!-- doxytag: member="ogr_api.h::OGR_L_CreateField" ref="aab585ef1166c61c4819f7fd46ee4a275" args="(OGRLayerH, OGRFieldDefnH, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_L_CreateField </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRFieldDefnH&nbsp;</td>
          <td class="paramname"> <em>hField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bApproxOK</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new field on a layer. </p>
<p>You must use this to create new fields on a real layer. Internally the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> for the layer will be updated to reflect the new field. Applications should never modify the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> used by a layer directly.</p>
<p>This function should not be called while there are feature objects in existance that were obtained or created with the previous layer definition.</p>
<p>Not all drivers support this function. You can query a layer to check if it supports it with the OLCCreateField capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existings features of the backing file/database should be updated accordingly.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a00b1376a1eabb1298ef278f92f6d84be" title="Create a new field on a layer.">OGRLayer::CreateField()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hLayer</em>&nbsp;</td><td>handle to the layer to write the field definition. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hField</em>&nbsp;</td><td>handle of the field definition to write to disk. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bApproxOK</em>&nbsp;</td><td>If TRUE, the field may be created in a slightly different form depending on the limitations of the format driver.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE on success. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#aab585ef1166c61c4819f7fd46ee4a275">OGR_L_CreateField()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#aab585ef1166c61c4819f7fd46ee4a275">OGR_L_CreateField()</a>.</p>

</div>
</div>
<a class="anchor" id="af6908931c4f3ad364fef8d6e831363bc"></a><!-- doxytag: member="ogr_api.h::OGR_L_CreateGeomField" ref="af6908931c4f3ad364fef8d6e831363bc" args="(OGRLayerH hLayer, OGRGeomFieldDefnH hFieldDefn, int bForce)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_L_CreateGeomField </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRGeomFieldDefnH&nbsp;</td>
          <td class="paramname"> <em>hField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bApproxOK</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new geometry field on a layer. </p>
<p>You must use this to create new geometry fields on a real layer. Internally the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> for the layer will be updated to reflect the new field. Applications should never modify the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> used by a layer directly.</p>
<p>This function should not be called while there are feature objects in existance that were obtained or created with the previous layer definition.</p>
<p>Not all drivers support this function. You can query a layer to check if it supports it with the OLCCreateField capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existings features of the backing file/database should be updated accordingly.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a00b1376a1eabb1298ef278f92f6d84be" title="Create a new field on a layer.">OGRLayer::CreateField()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hLayer</em>&nbsp;</td><td>handle to the layer to write the field definition. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hField</em>&nbsp;</td><td>handle of the geometry field definition to write to disk. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bApproxOK</em>&nbsp;</td><td>If TRUE, the field may be created in a slightly different form depending on the limitations of the format driver.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE on success.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.11 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#af6908931c4f3ad364fef8d6e831363bc">OGR_L_CreateGeomField()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#af6908931c4f3ad364fef8d6e831363bc">OGR_L_CreateGeomField()</a>.</p>

</div>
</div>
<a class="anchor" id="a3525cc8e47db48f8968605d3f2d9a41a"></a><!-- doxytag: member="ogr_api.h::OGR_L_DeleteFeature" ref="a3525cc8e47db48f8968605d3f2d9a41a" args="(OGRLayerH, long)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_L_DeleteFeature </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nFID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete feature from layer. </p>
<p>The feature with the indicated feature id is deleted from the layer if supported by the driver. Most drivers do not support feature deletion, and will return OGRERR_UNSUPPORTED_OPERATION. The <a class="el" href="ogr__api_8h.html#a480adc8b839b04597f49583371d366fd" title="Test if this layer supported the named capability.">OGR_L_TestCapability()</a> function may be called with OLCDeleteFeature to check if the driver supports feature deletion.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRLayer.html#a7e3d454d54a615a1b4359628bb6e7674" title="Delete feature from layer.">OGRLayer::DeleteFeature()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hLayer</em>&nbsp;</td><td>handle to the layer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nFID</em>&nbsp;</td><td>the feature id to be deleted from the layer</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE on success. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a3525cc8e47db48f8968605d3f2d9a41a">OGR_L_DeleteFeature()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a3525cc8e47db48f8968605d3f2d9a41a">OGR_L_DeleteFeature()</a>.</p>

</div>
</div>
<a class="anchor" id="afc861413683418eba5d31e487da2f9e2"></a><!-- doxytag: member="ogr_api.h::OGR_L_DeleteField" ref="afc861413683418eba5d31e487da2f9e2" args="(OGRLayerH, int iField)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_L_DeleteField </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iField</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new field on a layer. </p>
<p>You must use this to delete existing fields on a real layer. Internally the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> for the layer will be updated to reflect the deleted field. Applications should never modify the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> used by a layer directly.</p>
<p>This function should not be called while there are feature objects in existance that were obtained or created with the previous layer definition.</p>
<p>Not all drivers support this function. You can query a layer to check if it supports it with the OLCDeleteField capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existings features of the backing file/database should be updated accordingly.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#aaebe7c671dca995549543eecf0f7a76a" title="Delete an existing field on a layer.">OGRLayer::DeleteField()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hLayer</em>&nbsp;</td><td>handle to the layer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iField</em>&nbsp;</td><td>index of the field to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE on success.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.9.0 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#afc861413683418eba5d31e487da2f9e2">OGR_L_DeleteField()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#afc861413683418eba5d31e487da2f9e2">OGR_L_DeleteField()</a>.</p>

</div>
</div>
<a class="anchor" id="a0f8c47bbeae70e609f4e51a239784285"></a><!-- doxytag: member="ogr_api.h::OGR_L_Erase" ref="a0f8c47bbeae70e609f4e51a239784285" args="(OGRLayerH, OGRLayerH, OGRLayerH, char **, GDALProgressFunc, void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_L_Erase </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>pLayerInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>pLayerMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>pLayerResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&nbsp;</td>
          <td class="paramname"> <em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pProgressArg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove areas that are covered by the method layer. </p>
<p>The result layer contains features whose geometries represent areas that are in the input layer but not in the method layer. The features in the result layer have attributes from the input layer. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in the input layer.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</dd>
<dd>
This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</dd></dl>
<p>The recognized list of options is : </p>
<ul>
<li>
SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted. </li>
<li>
PROMOTE_TO_MULTI=YES/NO. Set it to YES to convert Polygons into MultiPolygons, or LineStrings to MultiLineStrings. </li>
<li>
INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer. </li>
<li>
METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer. </li>
</ul>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#ae8fcf55ffa259f32df35edcb05274439" title="Remove areas that are covered by the method layer.">OGRLayer::Erase()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pLayerInput</em>&nbsp;</td><td>the input layer. Should not be NULL.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pLayerMethod</em>&nbsp;</td><td>the method layer. Should not be NULL.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pLayerResult</em>&nbsp;</td><td>the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>papszOptions</em>&nbsp;</td><td>NULL terminated list of options (may be NULL).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnProgress</em>&nbsp;</td><td>a GDALProgressFunc() compatible callback function for reporting progress or NULL.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pProgressArg</em>&nbsp;</td><td>argument to be passed to pfnProgress. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.10 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a0f8c47bbeae70e609f4e51a239784285">OGR_L_Erase()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a0f8c47bbeae70e609f4e51a239784285">OGR_L_Erase()</a>.</p>

</div>
</div>
<a class="anchor" id="affc3cef62be82ec4f811a89b1855cbd5"></a><!-- doxytag: member="ogr_api.h::OGR_L_FindFieldIndex" ref="affc3cef62be82ec4f811a89b1855cbd5" args="(OGRLayerH, const char *, int bExactMatch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_L_FindFieldIndex </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bExactMatch</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the index of field in a layer. </p>
<p>The returned number is the index of the field in the layers, or -1 if the field doesn't exist.</p>
<p>If bExactMatch is set to FALSE and the field doesn't exists in the given form the driver might apply some changes to make it match, like those it might do if the layer was created (eg. like LAUNDER in the OCI driver).</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRLayer.html#aef41bcd7adad1ac5ddcef54d6b38713c" title="Find the index of field in the layer.">OGRLayer::FindFieldIndex()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>field index, or -1 if the field doesn't exist </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#affc3cef62be82ec4f811a89b1855cbd5">OGR_L_FindFieldIndex()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#affc3cef62be82ec4f811a89b1855cbd5">OGR_L_FindFieldIndex()</a>.</p>

</div>
</div>
<a class="anchor" id="aa6c495581900c8301dff91d8cd3ee12f"></a><!-- doxytag: member="ogr_api.h::OGR_L_GetExtent" ref="aa6c495581900c8301dff91d8cd3ee12f" args="(OGRLayerH, OGREnvelope *, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_L_GetExtent </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGREnvelope.html">OGREnvelope</a> *&nbsp;</td>
          <td class="paramname"> <em>psExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bForce</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch the extent of this layer. </p>
<p>Returns the extent (MBR) of the data in the layer. If bForce is FALSE, and it would be expensive to establish the extent then OGRERR_FAILURE will be returned indicating that the extent isn't know. If bForce is TRUE then some implementations will actually scan the entire layer once to compute the MBR of all the features in the layer.</p>
<p>Depending on the drivers, the returned extent may or may not take the spatial filter into account. So it is safer to call <a class="el" href="ogr__api_8h.html#aa6c495581900c8301dff91d8cd3ee12f" title="Fetch the extent of this layer.">OGR_L_GetExtent()</a> without setting a spatial filter.</p>
<p>Layers without any geometry may return OGRERR_FAILURE just indicating that no meaningful extents could be collected.</p>
<p>Note that some implementations of this method may alter the read cursor of the layer.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a3be658ddb5b33d1ed95c31286774bbd2" title="Fetch the extent of this layer.">OGRLayer::GetExtent()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hLayer</em>&nbsp;</td><td>handle to the layer from which to get extent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>psExtent</em>&nbsp;</td><td>the structure in which the extent value will be returned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bForce</em>&nbsp;</td><td>Flag indicating whether the extent should be computed even if it is expensive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE on success, OGRERR_FAILURE if extent not known. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#aa6c495581900c8301dff91d8cd3ee12f">OGR_L_GetExtent()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#aa6c495581900c8301dff91d8cd3ee12f">OGR_L_GetExtent()</a>.</p>

</div>
</div>
<a class="anchor" id="ac3dbfd4443c80dca0d93574f0c00d376"></a><!-- doxytag: member="ogr_api.h::OGR_L_GetExtentEx" ref="ac3dbfd4443c80dca0d93574f0c00d376" args="(OGRLayerH, int iGeomField, OGREnvelope *psExtent, int bForce)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_L_GetExtentEx </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iGeomField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGREnvelope.html">OGREnvelope</a> *&nbsp;</td>
          <td class="paramname"> <em>psExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bForce</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch the extent of this layer, on the specified geometry field. </p>
<p>Returns the extent (MBR) of the data in the layer. If bForce is FALSE, and it would be expensive to establish the extent then OGRERR_FAILURE will be returned indicating that the extent isn't know. If bForce is TRUE then some implementations will actually scan the entire layer once to compute the MBR of all the features in the layer.</p>
<p>Depending on the drivers, the returned extent may or may not take the spatial filter into account. So it is safer to call <a class="el" href="ogr__api_8h.html#aa6c495581900c8301dff91d8cd3ee12f" title="Fetch the extent of this layer.">OGR_L_GetExtent()</a> without setting a spatial filter.</p>
<p>Layers without any geometry may return OGRERR_FAILURE just indicating that no meaningful extents could be collected.</p>
<p>Note that some implementations of this method may alter the read cursor of the layer.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a3be658ddb5b33d1ed95c31286774bbd2" title="Fetch the extent of this layer.">OGRLayer::GetExtent()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hLayer</em>&nbsp;</td><td>handle to the layer from which to get extent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iGeomField</em>&nbsp;</td><td>the index of the geometry field on which to compute the extent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>psExtent</em>&nbsp;</td><td>the structure in which the extent value will be returned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bForce</em>&nbsp;</td><td>Flag indicating whether the extent should be computed even if it is expensive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE on success, OGRERR_FAILURE if extent not known. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#ac3dbfd4443c80dca0d93574f0c00d376">OGR_L_GetExtentEx()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ac3dbfd4443c80dca0d93574f0c00d376">OGR_L_GetExtentEx()</a>.</p>

</div>
</div>
<a class="anchor" id="a7c628dce8939904154b50365306b06f9"></a><!-- doxytag: member="ogr_api.h::OGR_L_GetFeature" ref="a7c628dce8939904154b50365306b06f9" args="(OGRLayerH, long)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRFeatureH OGR_L_GetFeature </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nFeatureId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch a feature by its identifier. </p>
<p>This function will attempt to read the identified feature. The nFID value cannot be OGRNullFID. Success or failure of this operation is unaffected by the spatial or attribute filters (and specialized implementations in drivers should make sure that they do not take into account spatial or attribute filters).</p>
<p>If this function returns a non-NULL feature, it is guaranteed that its feature id (<a class="el" href="ogr__api_8h.html#a95bc391bf7883a8732a523d525c26a00" title="Get feature identifier.">OGR_F_GetFID()</a>) will be the same as nFID.</p>
<p>Use OGR_L_TestCapability(OLCRandomRead) to establish if this layer supports efficient random access reading via <a class="el" href="ogr__api_8h.html#a7c628dce8939904154b50365306b06f9" title="Fetch a feature by its identifier.">OGR_L_GetFeature()</a>; however, the call should always work if the feature exists as a fallback implementation just scans all the features in the layer looking for the desired feature.</p>
<p>Sequential reads (with <a class="el" href="ogr__api_8h.html#a6708c067521ab7b7f9c4ec0ebe221b5b" title="Fetch the next available feature from this layer.">OGR_L_GetNextFeature()</a>) are generally considered interrupted by a <a class="el" href="ogr__api_8h.html#a7c628dce8939904154b50365306b06f9" title="Fetch a feature by its identifier.">OGR_L_GetFeature()</a> call.</p>
<p>The returned feature should be free with <a class="el" href="ogr__api_8h.html#a16fb8126aa932f4b4acdaca5ea99bbbb" title="Destroy feature.">OGR_F_Destroy()</a>.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#acb7625383f161e5a04aeea2173dce411" title="Fetch a feature by its identifier.">OGRLayer::GetFeature( )</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hLayer</em>&nbsp;</td><td>handle to the layer that owned the feature. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nFeatureId</em>&nbsp;</td><td>the feature id of the feature to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an handle to a feature now owned by the caller, or NULL on failure. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a7c628dce8939904154b50365306b06f9">OGR_L_GetFeature()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a7c628dce8939904154b50365306b06f9">OGR_L_GetFeature()</a>.</p>

</div>
</div>
<a class="anchor" id="abfbba8f45edd5dc44ced91f9228f9124"></a><!-- doxytag: member="ogr_api.h::OGR_L_GetFeatureCount" ref="abfbba8f45edd5dc44ced91f9228f9124" args="(OGRLayerH, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_L_GetFeatureCount </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bForce</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch the feature count in this layer. </p>
<p>Returns the number of features in the layer. For dynamic databases the count may not be exact. If bForce is FALSE, and it would be expensive to establish the feature count a value of -1 may be returned indicating that the count isn't know. If bForce is TRUE some implementations will actually scan the entire layer once to count objects.</p>
<p>The returned count takes the spatial filter into account.</p>
<p>Note that some implementations of this method may alter the read cursor of the layer.</p>
<p>This function is the same as the CPP <a class="el" href="classOGRLayer.html#a74c796d4ce712e9a78df6042eeb8a91a" title="Fetch the feature count in this layer.">OGRLayer::GetFeatureCount()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hLayer</em>&nbsp;</td><td>handle to the layer that owned the features. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bForce</em>&nbsp;</td><td>Flag indicating whether the count should be computed even if it is expensive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>feature count, -1 if count not known. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#abfbba8f45edd5dc44ced91f9228f9124">OGR_L_GetFeatureCount()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#abfbba8f45edd5dc44ced91f9228f9124">OGR_L_GetFeatureCount()</a>.</p>

</div>
</div>
<a class="anchor" id="abfeb6e1258f113c6c45c8d6a43c8cfa5"></a><!-- doxytag: member="ogr_api.h::OGR_L_GetFIDColumn" ref="abfeb6e1258f113c6c45c8d6a43c8cfa5" args="(OGRLayerH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * OGR_L_GetFIDColumn </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>hLayer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method returns the name of the underlying database column being used as the FID column, or "" if not supported. </p>
<p>This method is the same as the C++ method <a class="el" href="classOGRLayer.html#af0cb9a05310d7b17d9dfec9e83a18e61" title="This method returns the name of the underlying database column being used as the FID column...">OGRLayer::GetFIDColumn()</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hLayer</em>&nbsp;</td><td>handle to the layer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>fid column name. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#abfeb6e1258f113c6c45c8d6a43c8cfa5">OGR_L_GetFIDColumn()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#abfeb6e1258f113c6c45c8d6a43c8cfa5">OGR_L_GetFIDColumn()</a>.</p>

</div>
</div>
<a class="anchor" id="ab060e07e277cebd1d8504c449d97b29f"></a><!-- doxytag: member="ogr_api.h::OGR_L_GetGeometryColumn" ref="ab060e07e277cebd1d8504c449d97b29f" args="(OGRLayerH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * OGR_L_GetGeometryColumn </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>hLayer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method returns the name of the underlying database column being used as the geometry column, or "" if not supported. </p>
<p>This method is the same as the C++ method <a class="el" href="classOGRLayer.html#af68036c23622c954ce3a91861f22b724" title="This method returns the name of the underlying database column being used as the geometry column...">OGRLayer::GetGeometryColumn()</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hLayer</em>&nbsp;</td><td>handle to the layer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>geometry column name. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#ab060e07e277cebd1d8504c449d97b29f">OGR_L_GetGeometryColumn()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ab060e07e277cebd1d8504c449d97b29f">OGR_L_GetGeometryColumn()</a>.</p>

</div>
</div>
<a class="anchor" id="a0adea8ce1ca795ce0a6a76505f90f078"></a><!-- doxytag: member="ogr_api.h::OGR_L_GetGeomType" ref="a0adea8ce1ca795ce0a6a76505f90f078" args="(OGRLayerH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a> OGR_L_GetGeomType </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>hLayer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the layer geometry type. </p>
<p>This returns the same result as OGR_FD_GetGeomType(OGR_L_GetLayerDefn(hLayer)), but for a few drivers, calling <a class="el" href="ogr__api_8h.html#a0adea8ce1ca795ce0a6a76505f90f078" title="Return the layer geometry type.">OGR_L_GetGeomType()</a> directly can avoid lengthy layer definition initialization.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a818a25520ce08d5a681443348e930604" title="Return the layer geometry type.">OGRLayer::GetGeomType()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hLayer</em>&nbsp;</td><td>handle to the layer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the geometry type </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.8.0 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a0adea8ce1ca795ce0a6a76505f90f078">OGR_L_GetGeomType()</a>, and <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa3645f782f9b9f7632d7e7cdd0451d58f">wkbUnknown</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a0adea8ce1ca795ce0a6a76505f90f078">OGR_L_GetGeomType()</a>.</p>

</div>
</div>
<a class="anchor" id="a7b67ea4ab5892c6720460dc7f66eca2d"></a><!-- doxytag: member="ogr_api.h::OGR_L_GetLayerDefn" ref="a7b67ea4ab5892c6720460dc7f66eca2d" args="(OGRLayerH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRFeatureDefnH OGR_L_GetLayerDefn </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>hLayer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch the schema information for this layer. </p>
<p>The returned handle to the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> is owned by the <a class="el" href="classOGRLayer.html">OGRLayer</a>, and should not be modified or freed by the application. It encapsulates the attribute schema of the features of the layer.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">OGRLayer::GetLayerDefn()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hLayer</em>&nbsp;</td><td>handle to the layer to get the schema information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an handle to the feature definition. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a7b67ea4ab5892c6720460dc7f66eca2d">OGR_L_GetLayerDefn()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a7b67ea4ab5892c6720460dc7f66eca2d">OGR_L_GetLayerDefn()</a>.</p>

</div>
</div>
<a class="anchor" id="a88facf4f8e8b32278101d52ae094255c"></a><!-- doxytag: member="ogr_api.h::OGR_L_GetName" ref="a88facf4f8e8b32278101d52ae094255c" args="(OGRLayerH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * OGR_L_GetName </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>hLayer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the layer name. </p>
<p>This returns the same content as OGR_FD_GetName(OGR_L_GetLayerDefn(hLayer)), but for a few drivers, calling <a class="el" href="ogr__api_8h.html#a88facf4f8e8b32278101d52ae094255c" title="Return the layer name.">OGR_L_GetName()</a> directly can avoid lengthy layer definition initialization.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a287f5ec7728cacc2f7d94882a9f1a22e" title="Return the layer name.">OGRLayer::GetName()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hLayer</em>&nbsp;</td><td>handle to the layer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the layer name (must not been freed) </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.8.0 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a88facf4f8e8b32278101d52ae094255c">OGR_L_GetName()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a88facf4f8e8b32278101d52ae094255c">OGR_L_GetName()</a>.</p>

</div>
</div>
<a class="anchor" id="a6708c067521ab7b7f9c4ec0ebe221b5b"></a><!-- doxytag: member="ogr_api.h::OGR_L_GetNextFeature" ref="a6708c067521ab7b7f9c4ec0ebe221b5b" args="(OGRLayerH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRFeatureH OGR_L_GetNextFeature </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>hLayer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch the next available feature from this layer. </p>
<p>The returned feature becomes the responsiblity of the caller to delete with <a class="el" href="ogr__api_8h.html#a16fb8126aa932f4b4acdaca5ea99bbbb" title="Destroy feature.">OGR_F_Destroy()</a>. It is critical that all features associated with an <a class="el" href="classOGRLayer.html">OGRLayer</a> (more specifically an <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a>) be deleted before that layer/datasource is deleted.</p>
<p>Only features matching the current spatial filter (set with SetSpatialFilter()) will be returned.</p>
<p>This function implements sequential access to the features of a layer. The <a class="el" href="ogr__api_8h.html#ab0383004bf637171648a9d03a80f15a4" title="Reset feature reading to start on the first feature.">OGR_L_ResetReading()</a> function can be used to start at the beginning again.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6" title="Fetch the next available feature from this layer.">OGRLayer::GetNextFeature()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hLayer</em>&nbsp;</td><td>handle to the layer from which feature are read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an handle to a feature, or NULL if no more features are available. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a6708c067521ab7b7f9c4ec0ebe221b5b">OGR_L_GetNextFeature()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a6708c067521ab7b7f9c4ec0ebe221b5b">OGR_L_GetNextFeature()</a>.</p>

</div>
</div>
<a class="anchor" id="a36d61f311c9f8c172ad118659358c60a"></a><!-- doxytag: member="ogr_api.h::OGR_L_GetSpatialFilter" ref="a36d61f311c9f8c172ad118659358c60a" args="(OGRLayerH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRGeometryH OGR_L_GetSpatialFilter </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>hLayer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function returns the current spatial filter for this layer. </p>
<p>The returned pointer is to an internally owned object, and should not be altered or deleted by the caller.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#adc3735e444204d46f517eec251712f4d" title="This method returns the current spatial filter for this layer.">OGRLayer::GetSpatialFilter()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hLayer</em>&nbsp;</td><td>handle to the layer to get the spatial filter from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an handle to the spatial filter geometry. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a36d61f311c9f8c172ad118659358c60a">OGR_L_GetSpatialFilter()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a36d61f311c9f8c172ad118659358c60a">OGR_L_GetSpatialFilter()</a>.</p>

</div>
</div>
<a class="anchor" id="a8b2a10085f410aa84172eba413408c39"></a><!-- doxytag: member="ogr_api.h::OGR_L_GetSpatialRef" ref="a8b2a10085f410aa84172eba413408c39" args="(OGRLayerH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRSpatialReferenceH OGR_L_GetSpatialRef </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>hLayer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch the spatial reference system for this layer. </p>
<p>The returned object is owned by the <a class="el" href="classOGRLayer.html">OGRLayer</a> and should not be modified or freed by the application.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a75c06b4993f8eb76b569f37365cd19ab" title="Fetch the spatial reference system for this layer.">OGRLayer::GetSpatialRef()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hLayer</em>&nbsp;</td><td>handle to the layer to get the spatial reference from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>spatial reference, or NULL if there isn't one. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a8b2a10085f410aa84172eba413408c39">OGR_L_GetSpatialRef()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a8b2a10085f410aa84172eba413408c39">OGR_L_GetSpatialRef()</a>.</p>

</div>
</div>
<a class="anchor" id="a67948074f2e2942cebdd0f90bbec8aa9"></a><!-- doxytag: member="ogr_api.h::OGR_L_Identity" ref="a67948074f2e2942cebdd0f90bbec8aa9" args="(OGRLayerH, OGRLayerH, OGRLayerH, char **, GDALProgressFunc, void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_L_Identity </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>pLayerInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>pLayerMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>pLayerResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&nbsp;</td>
          <td class="paramname"> <em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pProgressArg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Identify the features of this layer with the ones from the identity layer. </p>
<p>The result layer contains features whose geometries represent areas that are in the input layer. The features in the result layer have attributes from both input and method layers. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in input and method layers.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If the schema of the result is set by user and contains fields that have the same name as a field in input and in method layer, then the attribute in the result feature will get the value from the feature of the method layer (even if it is undefined).</dd>
<dd>
For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</dd>
<dd>
This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</dd></dl>
<p>The recognized list of options is : </p>
<ul>
<li>
SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted. </li>
<li>
PROMOTE_TO_MULTI=YES/NO. Set it to YES to convert Polygons into MultiPolygons, or LineStrings to MultiLineStrings. </li>
<li>
INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer. </li>
<li>
METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer. </li>
</ul>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#acac6a0bde9737555b22c6ac7fa967431" title="Identify the features of this layer with the ones from the identity layer.">OGRLayer::Identity()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pLayerInput</em>&nbsp;</td><td>the input layer. Should not be NULL.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pLayerMethod</em>&nbsp;</td><td>the method layer. Should not be NULL.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pLayerResult</em>&nbsp;</td><td>the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>papszOptions</em>&nbsp;</td><td>NULL terminated list of options (may be NULL).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnProgress</em>&nbsp;</td><td>a GDALProgressFunc() compatible callback function for reporting progress or NULL.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pProgressArg</em>&nbsp;</td><td>argument to be passed to pfnProgress. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.10 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a67948074f2e2942cebdd0f90bbec8aa9">OGR_L_Identity()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a67948074f2e2942cebdd0f90bbec8aa9">OGR_L_Identity()</a>.</p>

</div>
</div>
<a class="anchor" id="a5c353cc32c9dd02967a7bed1450d2524"></a><!-- doxytag: member="ogr_api.h::OGR_L_Intersection" ref="a5c353cc32c9dd02967a7bed1450d2524" args="(OGRLayerH, OGRLayerH, OGRLayerH, char **, GDALProgressFunc, void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_L_Intersection </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>pLayerInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>pLayerMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>pLayerResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&nbsp;</td>
          <td class="paramname"> <em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pProgressArg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Intersection of two layers. </p>
<p>The result layer contains features whose geometries represent areas that are common between features in the input layer and in the method layer. The features in the result layer have attributes from both input and method layers. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in the input and method layers.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If the schema of the result is set by user and contains fields that have the same name as a field in input and in method layer, then the attribute in the result feature will get the value from the feature of the method layer.</dd>
<dd>
For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</dd>
<dd>
This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</dd></dl>
<p>The recognized list of options is : </p>
<ul>
<li>
SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted. </li>
<li>
PROMOTE_TO_MULTI=YES/NO. Set it to YES to convert Polygons into MultiPolygons, or LineStrings to MultiLineStrings. </li>
<li>
INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer. </li>
<li>
METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer. </li>
</ul>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#ac189f54996c2d6fd769889ec99e0f48a" title="Intersection of two layers.">OGRLayer::Intersection()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pLayerInput</em>&nbsp;</td><td>the input layer. Should not be NULL.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pLayerMethod</em>&nbsp;</td><td>the method layer. Should not be NULL.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pLayerResult</em>&nbsp;</td><td>the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>papszOptions</em>&nbsp;</td><td>NULL terminated list of options (may be NULL).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnProgress</em>&nbsp;</td><td>a GDALProgressFunc() compatible callback function for reporting progress or NULL.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pProgressArg</em>&nbsp;</td><td>argument to be passed to pfnProgress. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.10 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a5c353cc32c9dd02967a7bed1450d2524">OGR_L_Intersection()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a5c353cc32c9dd02967a7bed1450d2524">OGR_L_Intersection()</a>.</p>

</div>
</div>
<a class="anchor" id="ad20a3796ee63935285976ee425878927"></a><!-- doxytag: member="ogr_api.h::OGR_L_ReorderField" ref="ad20a3796ee63935285976ee425878927" args="(OGRLayerH, int iOldFieldPos, int iNewFieldPos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_L_ReorderField </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iOldFieldPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iNewFieldPos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reorder an existing field on a layer. </p>
<p>This function is a conveniency wrapper of <a class="el" href="ogr__api_8h.html#a4cc576cb39e1dd4a1f074125199245bb" title="Reorder all the fields of a layer.">OGR_L_ReorderFields()</a> dedicated to move a single field.</p>
<p>You must use this to reorder existing fields on a real layer. Internally the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> for the layer will be updated to reflect the reordering of the fields. Applications should never modify the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> used by a layer directly.</p>
<p>This function should not be called while there are feature objects in existance that were obtained or created with the previous layer definition.</p>
<p>The field definition that was at initial position iOldFieldPos will be moved at position iNewFieldPos, and elements between will be shuffled accordingly.</p>
<p>For example, let suppose the fields were "0","1","2","3","4" initially. ReorderField(1, 3) will reorder them as "0","2","3","1","4".</p>
<p>Not all drivers support this function. You can query a layer to check if it supports it with the OLCReorderFields capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existings features of the backing file/database should be updated accordingly.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#ab4c02b991bfa78552eeb0cbcdcf1aed8" title="Reorder an existing field on a layer.">OGRLayer::ReorderField()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hLayer</em>&nbsp;</td><td>handle to the layer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iOldFieldPos</em>&nbsp;</td><td>previous position of the field to move. Must be in the range [0,GetFieldCount()-1]. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iNewFieldPos</em>&nbsp;</td><td>new position of the field to move. Must be in the range [0,GetFieldCount()-1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE on success.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.9.0 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#ad20a3796ee63935285976ee425878927">OGR_L_ReorderField()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ad20a3796ee63935285976ee425878927">OGR_L_ReorderField()</a>.</p>

</div>
</div>
<a class="anchor" id="a4cc576cb39e1dd4a1f074125199245bb"></a><!-- doxytag: member="ogr_api.h::OGR_L_ReorderFields" ref="a4cc576cb39e1dd4a1f074125199245bb" args="(OGRLayerH, int *panMap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_L_ReorderFields </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>panMap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reorder all the fields of a layer. </p>
<p>You must use this to reorder existing fields on a real layer. Internally the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> for the layer will be updated to reflect the reordering of the fields. Applications should never modify the <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> used by a layer directly.</p>
<p>This function should not be called while there are feature objects in existance that were obtained or created with the previous layer definition.</p>
<p>panMap is such that,for each field definition at position i after reordering, its position before reordering was panMap[i].</p>
<p>For example, let suppose the fields were "0","1","2","3","4" initially. ReorderFields([0,2,3,1,4]) will reorder them as "0","2","3","1","4".</p>
<p>Not all drivers support this function. You can query a layer to check if it supports it with the OLCReorderFields capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existings features of the backing file/database should be updated accordingly.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#aebd364a150d91f8d65d967646e0f92d3" title="Reorder all the fields of a layer.">OGRLayer::ReorderFields()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hLayer</em>&nbsp;</td><td>handle to the layer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>panMap</em>&nbsp;</td><td>an array of GetLayerDefn()-&gt;GetFieldCount() elements which is a permutation of [0, GetLayerDefn()-&gt;GetFieldCount()-1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE on success.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.9.0 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a4cc576cb39e1dd4a1f074125199245bb">OGR_L_ReorderFields()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a4cc576cb39e1dd4a1f074125199245bb">OGR_L_ReorderFields()</a>.</p>

</div>
</div>
<a class="anchor" id="ab0383004bf637171648a9d03a80f15a4"></a><!-- doxytag: member="ogr_api.h::OGR_L_ResetReading" ref="ab0383004bf637171648a9d03a80f15a4" args="(OGRLayerH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_L_ResetReading </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>hLayer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset feature reading to start on the first feature. </p>
<p>This affects GetNextFeature().</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#aad0f2cd7f0587584b8f382c6a913583c" title="Reset feature reading to start on the first feature.">OGRLayer::ResetReading()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hLayer</em>&nbsp;</td><td>handle to the layer on which features are read. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#ab0383004bf637171648a9d03a80f15a4">OGR_L_ResetReading()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ab0383004bf637171648a9d03a80f15a4">OGR_L_ResetReading()</a>.</p>

</div>
</div>
<a class="anchor" id="a823a6c351dccf751777f67801dd7f9c5"></a><!-- doxytag: member="ogr_api.h::OGR_L_RollbackTransaction" ref="a823a6c351dccf751777f67801dd7f9c5" args="(OGRLayerH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_L_RollbackTransaction </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>hLayer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For datasources which support transactions, RollbackTransaction will roll back a datasource to its state before the start of the current transaction. If no transaction is active, or the rollback fails, will return OGRERR_FAILURE. Datasources which do not support transactions will always return OGRERR_NONE. </p>
<p>This function is the same as the C++ method OGRLayer::RollbackTransaction().</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hLayer</em>&nbsp;</td><td>handle to the layer</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE on success. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a823a6c351dccf751777f67801dd7f9c5">OGR_L_RollbackTransaction()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a823a6c351dccf751777f67801dd7f9c5">OGR_L_RollbackTransaction()</a>.</p>

</div>
</div>
<a class="anchor" id="a4000d426bf26ad7cc7d4012634c93f09"></a><!-- doxytag: member="ogr_api.h::OGR_L_SetAttributeFilter" ref="a4000d426bf26ad7cc7d4012634c93f09" args="(OGRLayerH, const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_L_SetAttributeFilter </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszQuery</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a new attribute query. </p>
<p>This function sets the attribute query string to be used when fetching features via the <a class="el" href="ogr__api_8h.html#a6708c067521ab7b7f9c4ec0ebe221b5b" title="Fetch the next available feature from this layer.">OGR_L_GetNextFeature()</a> function. Only features for which the query evaluates as true will be returned.</p>
<p>The query string should be in the format of an SQL WHERE clause. For instance "population &gt; 1000000 and population &lt; 5000000" where population is an attribute in the layer. The query format is a restricted form of SQL WHERE clause as defined "eq_format=restricted_where" about half way through this document:</p>
<p><a href="http://ogdi.sourceforge.net/prop/6.2.CapabilitiesMetadata.html">http://ogdi.sourceforge.net/prop/6.2.CapabilitiesMetadata.html</a></p>
<p>Note that installing a query string will generally result in resetting the current reading position (ala <a class="el" href="ogr__api_8h.html#ab0383004bf637171648a9d03a80f15a4" title="Reset feature reading to start on the first feature.">OGR_L_ResetReading()</a>).</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#acb2c6cc5fa3577df5be538284c1b0dde" title="Set a new attribute query.">OGRLayer::SetAttributeFilter()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hLayer</em>&nbsp;</td><td>handle to the layer on which attribute query will be executed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszQuery</em>&nbsp;</td><td>query in restricted SQL WHERE format, or NULL to clear the current query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE if successfully installed, or an error code if the query expression is in error, or some other failure occurs. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a4000d426bf26ad7cc7d4012634c93f09">OGR_L_SetAttributeFilter()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a4000d426bf26ad7cc7d4012634c93f09">OGR_L_SetAttributeFilter()</a>.</p>

</div>
</div>
<a class="anchor" id="a5b380520d0999422987f06b6e31b9b00"></a><!-- doxytag: member="ogr_api.h::OGR_L_SetFeature" ref="a5b380520d0999422987f06b6e31b9b00" args="(OGRLayerH, OGRFeatureH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_L_SetFeature </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rewrite an existing feature. </p>
<p>This function will write a feature to the layer, based on the feature id within the <a class="el" href="classOGRFeature.html">OGRFeature</a>.</p>
<p>Use OGR_L_TestCapability(OLCRandomWrite) to establish if this layer supports random access writing via <a class="el" href="ogr__api_8h.html#a5b380520d0999422987f06b6e31b9b00" title="Rewrite an existing feature.">OGR_L_SetFeature()</a>.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a681139bfd585b74d7218e51a32144283" title="Rewrite an existing feature.">OGRLayer::SetFeature()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hLayer</em>&nbsp;</td><td>handle to the layer to write the feature. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>the feature to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE if the operation works, otherwise an appropriate error code. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a5b380520d0999422987f06b6e31b9b00">OGR_L_SetFeature()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a5b380520d0999422987f06b6e31b9b00">OGR_L_SetFeature()</a>.</p>

</div>
</div>
<a class="anchor" id="a6d43f1474201356bed2e6f92e7d37154"></a><!-- doxytag: member="ogr_api.h::OGR_L_SetIgnoredFields" ref="a6d43f1474201356bed2e6f92e7d37154" args="(OGRLayerH, const char **)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_L_SetIgnoredFields </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>papszFields</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set which fields can be omitted when retrieving features from the layer. </p>
<p>If the driver supports this functionality (testable using OLCIgnoreFields capability), it will not fetch the specified fields in subsequent calls to GetFeature() / GetNextFeature() and thus save some processing time and/or bandwidth.</p>
<p>Besides field names of the layers, the following special fields can be passed: "OGR_GEOMETRY" to ignore geometry and "OGR_STYLE" to ignore layer style.</p>
<p>By default, no fields are ignored.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRLayer.html#a5e0c3427f64249d1c35cefb487546b10" title="Set which fields can be omitted when retrieving features from the layer.">OGRLayer::SetIgnoredFields()</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>papszFields</em>&nbsp;</td><td>an array of field names terminated by NULL item. If NULL is passed, the ignored list is cleared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE if all field names have been resolved (even if the driver does not support this method) </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a6d43f1474201356bed2e6f92e7d37154">OGR_L_SetIgnoredFields()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a6d43f1474201356bed2e6f92e7d37154">OGR_L_SetIgnoredFields()</a>.</p>

</div>
</div>
<a class="anchor" id="a5bb3f366e3e6cd8cb586842193b4a7f9"></a><!-- doxytag: member="ogr_api.h::OGR_L_SetNextByIndex" ref="a5bb3f366e3e6cd8cb586842193b4a7f9" args="(OGRLayerH, long)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_L_SetNextByIndex </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nIndex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Move read cursor to the nIndex'th feature in the current resultset. </p>
<p>This method allows positioning of a layer such that the GetNextFeature() call will read the requested feature, where nIndex is an absolute index into the current result set. So, setting it to 3 would mean the next feature read with GetNextFeature() would have been the 4th feature to have been read if sequential reading took place from the beginning of the layer, including accounting for spatial and attribute filters.</p>
<p>Only in rare circumstances is SetNextByIndex() efficiently implemented. In all other cases the default implementation which calls ResetReading() and then calls GetNextFeature() nIndex times is used. To determine if fast seeking is available on the current layer use the TestCapability() method with a value of OLCFastSetNextByIndex.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRLayer.html#ae3b6234d6077a18a19eddaf7e75ff5e1" title="Move read cursor to the nIndex&#39;th feature in the current resultset.">OGRLayer::SetNextByIndex()</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hLayer</em>&nbsp;</td><td>handle to the layer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nIndex</em>&nbsp;</td><td>the index indicating how many steps into the result set to seek.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE on success or an error code. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a5bb3f366e3e6cd8cb586842193b4a7f9">OGR_L_SetNextByIndex()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a5bb3f366e3e6cd8cb586842193b4a7f9">OGR_L_SetNextByIndex()</a>.</p>

</div>
</div>
<a class="anchor" id="a678d1735bc82533614ac005691d1138c"></a><!-- doxytag: member="ogr_api.h::OGR_L_SetSpatialFilter" ref="a678d1735bc82533614ac005691d1138c" args="(OGRLayerH, OGRGeometryH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_L_SetSpatialFilter </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a new spatial filter. </p>
<p>This function set the geometry to be used as a spatial filter when fetching features via the <a class="el" href="ogr__api_8h.html#a6708c067521ab7b7f9c4ec0ebe221b5b" title="Fetch the next available feature from this layer.">OGR_L_GetNextFeature()</a> function. Only features that geometrically intersect the filter geometry will be returned.</p>
<p>Currently this test is may be inaccurately implemented, but it is guaranteed that all features who's envelope (as returned by <a class="el" href="ogr__api_8h.html#a617a9c9ea85157661619a1d8f0a69cf9" title="Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure...">OGR_G_GetEnvelope()</a>) overlaps the envelope of the spatial filter will be returned. This can result in more shapes being returned that should strictly be the case.</p>
<p>This function makes an internal copy of the passed geometry. The passed geometry remains the responsibility of the caller, and may be safely destroyed.</p>
<p>For the time being the passed filter geometry should be in the same SRS as the layer (as returned by <a class="el" href="ogr__api_8h.html#a8b2a10085f410aa84172eba413408c39" title="Fetch the spatial reference system for this layer.">OGR_L_GetSpatialRef()</a>). In the future this may be generalized.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169" title="Set a new spatial filter.">OGRLayer::SetSpatialFilter</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hLayer</em>&nbsp;</td><td>handle to the layer on which to set the spatial filter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle to the geometry to use as a filtering region. NULL may be passed indicating that the current spatial filter should be cleared, but no new one instituted. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#a678d1735bc82533614ac005691d1138c">OGR_L_SetSpatialFilter()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a678d1735bc82533614ac005691d1138c">OGR_L_SetSpatialFilter()</a>.</p>

</div>
</div>
<a class="anchor" id="a00c8a1a968542d389f86ed1b4edd5823"></a><!-- doxytag: member="ogr_api.h::OGR_L_SetSpatialFilterEx" ref="a00c8a1a968542d389f86ed1b4edd5823" args="(OGRLayerH, int iGeomField, OGRGeometryH hGeom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_L_SetSpatialFilterEx </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iGeomField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hGeom</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a new spatial filter. </p>
<p>This function set the geometry to be used as a spatial filter when fetching features via the <a class="el" href="ogr__api_8h.html#a6708c067521ab7b7f9c4ec0ebe221b5b" title="Fetch the next available feature from this layer.">OGR_L_GetNextFeature()</a> function. Only features that geometrically intersect the filter geometry will be returned.</p>
<p>Currently this test is may be inaccurately implemented, but it is guaranteed that all features who's envelope (as returned by <a class="el" href="ogr__api_8h.html#a617a9c9ea85157661619a1d8f0a69cf9" title="Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure...">OGR_G_GetEnvelope()</a>) overlaps the envelope of the spatial filter will be returned. This can result in more shapes being returned that should strictly be the case.</p>
<p>This function makes an internal copy of the passed geometry. The passed geometry remains the responsibility of the caller, and may be safely destroyed.</p>
<p>For the time being the passed filter geometry should be in the same SRS as the geometry field definition it corresponds to (as returned by GetLayerDefn()-&gt;GetGeomFieldDefn(iGeomField)-&gt;GetSpatialRef()). In the future this may be generalized.</p>
<p>Note that only the last spatial filter set is applied, even if several successive calls are done with different iGeomField values.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169" title="Set a new spatial filter.">OGRLayer::SetSpatialFilter</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hLayer</em>&nbsp;</td><td>handle to the layer on which to set the spatial filter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iGeomField</em>&nbsp;</td><td>index of the geometry field on which the spatial filter operates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hGeom</em>&nbsp;</td><td>handle to the geometry to use as a filtering region. NULL may be passed indicating that the current spatial filter should be cleared, but no new one instituted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.11 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a00c8a1a968542d389f86ed1b4edd5823">OGR_L_SetSpatialFilterEx()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a00c8a1a968542d389f86ed1b4edd5823">OGR_L_SetSpatialFilterEx()</a>.</p>

</div>
</div>
<a class="anchor" id="a5cba569e0779a02a95327f041d9f7a13"></a><!-- doxytag: member="ogr_api.h::OGR_L_SetSpatialFilterRect" ref="a5cba569e0779a02a95327f041d9f7a13" args="(OGRLayerH, double, double, double, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_L_SetSpatialFilterRect </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfMinX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfMinY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfMaxX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfMaxY</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a new rectangular spatial filter. </p>
<p>This method set rectangle to be used as a spatial filter when fetching features via the <a class="el" href="ogr__api_8h.html#a6708c067521ab7b7f9c4ec0ebe221b5b" title="Fetch the next available feature from this layer.">OGR_L_GetNextFeature()</a> method. Only features that geometrically intersect the given rectangle will be returned.</p>
<p>The x/y values should be in the same coordinate system as the layer as a whole (as returned by <a class="el" href="classOGRLayer.html#a75c06b4993f8eb76b569f37365cd19ab" title="Fetch the spatial reference system for this layer.">OGRLayer::GetSpatialRef()</a>). Internally this method is normally implemented as creating a 5 vertex closed rectangular polygon and passing it to <a class="el" href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169" title="Set a new spatial filter.">OGRLayer::SetSpatialFilter()</a>. It exists as a convenience.</p>
<p>The only way to clear a spatial filter set with this method is to call OGRLayer::SetSpatialFilter(NULL).</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRLayer.html#acd16bcdb3e8f720003fb24cd68f25460" title="Set a new rectangular spatial filter.">OGRLayer::SetSpatialFilterRect()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hLayer</em>&nbsp;</td><td>handle to the layer on which to set the spatial filter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfMinX</em>&nbsp;</td><td>the minimum X coordinate for the rectangular region. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfMinY</em>&nbsp;</td><td>the minimum Y coordinate for the rectangular region. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfMaxX</em>&nbsp;</td><td>the maximum X coordinate for the rectangular region. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfMaxY</em>&nbsp;</td><td>the maximum Y coordinate for the rectangular region. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#a5cba569e0779a02a95327f041d9f7a13">OGR_L_SetSpatialFilterRect()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a5cba569e0779a02a95327f041d9f7a13">OGR_L_SetSpatialFilterRect()</a>.</p>

</div>
</div>
<a class="anchor" id="a489241dfe65d6e089809d3258c4f79f5"></a><!-- doxytag: member="ogr_api.h::OGR_L_SetSpatialFilterRectEx" ref="a489241dfe65d6e089809d3258c4f79f5" args="(OGRLayerH, int iGeomField, double dfMinX, double dfMinY, double dfMaxX, double dfMaxY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_L_SetSpatialFilterRectEx </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iGeomField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfMinX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfMinY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfMaxX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfMaxY</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a new rectangular spatial filter. </p>
<p>This method set rectangle to be used as a spatial filter when fetching features via the <a class="el" href="ogr__api_8h.html#a6708c067521ab7b7f9c4ec0ebe221b5b" title="Fetch the next available feature from this layer.">OGR_L_GetNextFeature()</a> method. Only features that geometrically intersect the given rectangle will be returned.</p>
<p>The x/y values should be in the same coordinate system as as the geometry field definition it corresponds to (as returned by GetLayerDefn()-&gt;GetGeomFieldDefn(iGeomField)-&gt;GetSpatialRef()). Internally this method is normally implemented as creating a 5 vertex closed rectangular polygon and passing it to <a class="el" href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169" title="Set a new spatial filter.">OGRLayer::SetSpatialFilter()</a>. It exists as a convenience.</p>
<p>The only way to clear a spatial filter set with this method is to call OGRLayer::SetSpatialFilter(NULL).</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRLayer.html#acd16bcdb3e8f720003fb24cd68f25460" title="Set a new rectangular spatial filter.">OGRLayer::SetSpatialFilterRect()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hLayer</em>&nbsp;</td><td>handle to the layer on which to set the spatial filter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iGeomField</em>&nbsp;</td><td>index of the geometry field on which the spatial filter operates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfMinX</em>&nbsp;</td><td>the minimum X coordinate for the rectangular region. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfMinY</em>&nbsp;</td><td>the minimum Y coordinate for the rectangular region. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfMaxX</em>&nbsp;</td><td>the maximum X coordinate for the rectangular region. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfMaxY</em>&nbsp;</td><td>the maximum Y coordinate for the rectangular region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.11 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a489241dfe65d6e089809d3258c4f79f5">OGR_L_SetSpatialFilterRectEx()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a489241dfe65d6e089809d3258c4f79f5">OGR_L_SetSpatialFilterRectEx()</a>.</p>

</div>
</div>
<a class="anchor" id="a8180ea56ca7f677eb5da05c8cfcb77be"></a><!-- doxytag: member="ogr_api.h::OGR_L_StartTransaction" ref="a8180ea56ca7f677eb5da05c8cfcb77be" args="(OGRLayerH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_L_StartTransaction </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>hLayer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For datasources which support transactions, StartTransaction creates a transaction. </p>
<p>If starting the transaction fails, will return OGRERR_FAILURE. Datasources which do not support transactions will always return OGRERR_NONE.</p>
<p>This function is the same as the C++ method OGRLayer::StartTransaction().</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hLayer</em>&nbsp;</td><td>handle to the layer</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE on success. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a8180ea56ca7f677eb5da05c8cfcb77be">OGR_L_StartTransaction()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a8180ea56ca7f677eb5da05c8cfcb77be">OGR_L_StartTransaction()</a>.</p>

</div>
</div>
<a class="anchor" id="a03249311ff4c88b2fac5f728be63b549"></a><!-- doxytag: member="ogr_api.h::OGR_L_SymDifference" ref="a03249311ff4c88b2fac5f728be63b549" args="(OGRLayerH, OGRLayerH, OGRLayerH, char **, GDALProgressFunc, void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_L_SymDifference </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>pLayerInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>pLayerMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>pLayerResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&nbsp;</td>
          <td class="paramname"> <em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pProgressArg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Symmetrical difference of two layers. </p>
<p>The result layer contains features whose geometries represent areas that are in either in the input layer or in the method layer but not in both. The features in the result layer have attributes from both input and method layers. For features which represent areas that are only in the input or in the method layer the respective attributes have undefined values. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in the input and method layers.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If the schema of the result is set by user and contains fields that have the same name as a field in input and in method layer, then the attribute in the result feature will get the value from the feature of the method layer (even if it is undefined).</dd>
<dd>
For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</dd>
<dd>
This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</dd></dl>
<p>The recognized list of options is : </p>
<ul>
<li>
SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted. </li>
<li>
PROMOTE_TO_MULTI=YES/NO. Set it to YES to convert Polygons into MultiPolygons, or LineStrings to MultiLineStrings. </li>
<li>
INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer. </li>
<li>
METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer. </li>
</ul>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a781aa76c6b44b19de09f61816e32245b" title="Symmetrical difference of two layers.">OGRLayer::SymDifference()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pLayerInput</em>&nbsp;</td><td>the input layer. Should not be NULL.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pLayerMethod</em>&nbsp;</td><td>the method layer. Should not be NULL.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pLayerResult</em>&nbsp;</td><td>the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>papszOptions</em>&nbsp;</td><td>NULL terminated list of options (may be NULL).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnProgress</em>&nbsp;</td><td>a GDALProgressFunc() compatible callback function for reporting progress or NULL.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pProgressArg</em>&nbsp;</td><td>argument to be passed to pfnProgress. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.10 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a03249311ff4c88b2fac5f728be63b549">OGR_L_SymDifference()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a03249311ff4c88b2fac5f728be63b549">OGR_L_SymDifference()</a>.</p>

</div>
</div>
<a class="anchor" id="a9d845a6cf6652756925530418905471a"></a><!-- doxytag: member="ogr_api.h::OGR_L_SyncToDisk" ref="a9d845a6cf6652756925530418905471a" args="(OGRLayerH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_L_SyncToDisk </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>hLayer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flush pending changes to disk. </p>
<p>This call is intended to force the layer to flush any pending writes to disk, and leave the disk file in a consistent state. It would not normally have any effect on read-only datasources.</p>
<p>Some layers do not implement this method, and will still return OGRERR_NONE. The default implementation just returns OGRERR_NONE. An error is only returned if an error occurs while attempting to flush to disk.</p>
<p>In any event, you should always close any opened datasource with <a class="el" href="ogr__api_8h.html#a4823e7c3513cd9d57254364de9a1d021" title="Closes opened datasource and releases allocated resources.">OGR_DS_Destroy()</a> that will ensure all data is correctly flushed.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRLayer.html#aebb07284c734e485d8611b7c8599254f" title="Flush pending changes to disk.">OGRLayer::SyncToDisk()</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hLayer</em>&nbsp;</td><td>handle to the layer</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE if no error occurs (even if nothing is done) or an error code. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a9d845a6cf6652756925530418905471a">OGR_L_SyncToDisk()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a9d845a6cf6652756925530418905471a">OGR_L_SyncToDisk()</a>.</p>

</div>
</div>
<a class="anchor" id="a480adc8b839b04597f49583371d366fd"></a><!-- doxytag: member="ogr_api.h::OGR_L_TestCapability" ref="a480adc8b839b04597f49583371d366fd" args="(OGRLayerH, const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_L_TestCapability </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszCap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if this layer supported the named capability. </p>
<p>The capability codes that can be tested are represented as strings, but #defined constants exists to ensure correct spelling. Specific layer types may implement class specific capabilities, but this can't generally be discovered by the caller. </p>
<ul>
<li>
<p class="startli"><b>OLCRandomRead</b> / "RandomRead": TRUE if the GetFeature() method is implemented in an optimized way for this layer, as opposed to the default implementation using ResetReading() and GetNextFeature() to find the requested feature id.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCSequentialWrite</b> / "SequentialWrite": TRUE if the CreateFeature() method works for this layer. Note this means that this particular layer is writable. The same <a class="el" href="classOGRLayer.html">OGRLayer</a> class may returned FALSE for other layer instances that are effectively read-only.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCRandomWrite</b> / "RandomWrite": TRUE if the SetFeature() method is operational on this layer. Note this means that this particular layer is writable. The same <a class="el" href="classOGRLayer.html">OGRLayer</a> class may returned FALSE for other layer instances that are effectively read-only.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCFastSpatialFilter</b> / "FastSpatialFilter": TRUE if this layer implements spatial filtering efficiently. Layers that effectively read all features, and test them with the <a class="el" href="classOGRFeature.html">OGRFeature</a> intersection methods should return FALSE. This can be used as a clue by the application whether it should build and maintain its own spatial index for features in this layer.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCFastFeatureCount</b> / "FastFeatureCount": TRUE if this layer can return a feature count (via <a class="el" href="ogr__api_8h.html#abfbba8f45edd5dc44ced91f9228f9124" title="Fetch the feature count in this layer.">OGR_L_GetFeatureCount()</a>) efficiently ... ie. without counting the features. In some cases this will return TRUE until a spatial filter is installed after which it will return FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCFastGetExtent</b> / "FastGetExtent": TRUE if this layer can return its data extent (via <a class="el" href="ogr__api_8h.html#aa6c495581900c8301dff91d8cd3ee12f" title="Fetch the extent of this layer.">OGR_L_GetExtent()</a>) efficiently ... ie. without scanning all the features. In some cases this will return TRUE until a spatial filter is installed after which it will return FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCFastSetNextByIndex</b> / "FastSetNextByIndex": TRUE if this layer can perform the SetNextByIndex() call efficiently, otherwise FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCCreateField</b> / "CreateField": TRUE if this layer can create new fields on the current layer using CreateField(), otherwise FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCCreateGeomField</b> / "CreateGeomField": (GDAL &gt;= 1.11) TRUE if this layer can create new geometry fields on the current layer using CreateGeomField(), otherwise FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCDeleteField</b> / "DeleteField": TRUE if this layer can delete existing fields on the current layer using DeleteField(), otherwise FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCReorderFields</b> / "ReorderFields": TRUE if this layer can reorder existing fields on the current layer using ReorderField() or ReorderFields(), otherwise FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCAlterFieldDefn</b> / "AlterFieldDefn": TRUE if this layer can alter the definition of an existing field on the current layer using AlterFieldDefn(), otherwise FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCDeleteFeature</b> / "DeleteFeature": TRUE if the DeleteFeature() method is supported on this layer, otherwise FALSE.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCStringsAsUTF8</b> / "StringsAsUTF8": TRUE if values of OFTString fields are assured to be in UTF-8 format. If FALSE the encoding of fields is uncertain, though it might still be UTF-8.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCTransactions</b> / "Transactions": TRUE if the StartTransaction(), CommitTransaction() and RollbackTransaction() methods work in a meaningful way, otherwise FALSE.</p>
<p></p>
<p></p>
<p></p>
<p class="endli"></p>
</li>
</ul>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#aeedbda1a62f9b89b8e5f24332cf22286" title="Test if this layer supported the named capability.">OGRLayer::TestCapability()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hLayer</em>&nbsp;</td><td>handle to the layer to get the capability from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszCap</em>&nbsp;</td><td>the name of the capability to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the layer has the requested capability, or FALSE otherwise. OGRLayers will return FALSE for any unrecognised capabilities.</dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a480adc8b839b04597f49583371d366fd">OGR_L_TestCapability()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a480adc8b839b04597f49583371d366fd">OGR_L_TestCapability()</a>.</p>

</div>
</div>
<a class="anchor" id="ac8edb8696c2b046370e29efdd73787f7"></a><!-- doxytag: member="ogr_api.h::OGR_L_Union" ref="ac8edb8696c2b046370e29efdd73787f7" args="(OGRLayerH, OGRLayerH, OGRLayerH, char **, GDALProgressFunc, void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_L_Union </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>pLayerInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>pLayerMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>pLayerResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&nbsp;</td>
          <td class="paramname"> <em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pProgressArg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Union of two layers. </p>
<p>The result layer contains features whose geometries represent areas that are in either in the input layer or in the method layer. The features in the result layer have attributes from both input and method layers. For features which represent areas that are only in the input or in the method layer the respective attributes have undefined values. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in the input and method layers.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If the schema of the result is set by user and contains fields that have the same name as a field in input and in method layer, then the attribute in the result feature will get the value from the feature of the method layer (even if it is undefined).</dd>
<dd>
For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</dd>
<dd>
This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</dd></dl>
<p>The recognized list of options is : </p>
<ul>
<li>
SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted. </li>
<li>
PROMOTE_TO_MULTI=YES/NO. Set it to YES to convert Polygons into MultiPolygons, or LineStrings to MultiLineStrings. </li>
<li>
INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer. </li>
<li>
METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer. </li>
</ul>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#aeb8ab475561f2aca2c0e605cfb810b22" title="Union of two layers.">OGRLayer::Union()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pLayerInput</em>&nbsp;</td><td>the input layer. Should not be NULL.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pLayerMethod</em>&nbsp;</td><td>the method layer. Should not be NULL.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pLayerResult</em>&nbsp;</td><td>the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>papszOptions</em>&nbsp;</td><td>NULL terminated list of options (may be NULL).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnProgress</em>&nbsp;</td><td>a GDALProgressFunc() compatible callback function for reporting progress or NULL.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pProgressArg</em>&nbsp;</td><td>argument to be passed to pfnProgress. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.10 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#ac8edb8696c2b046370e29efdd73787f7">OGR_L_Union()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ac8edb8696c2b046370e29efdd73787f7">OGR_L_Union()</a>.</p>

</div>
</div>
<a class="anchor" id="a87b478c971619145dee7d8d8deeac702"></a><!-- doxytag: member="ogr_api.h::OGR_L_Update" ref="a87b478c971619145dee7d8d8deeac702" args="(OGRLayerH, OGRLayerH, OGRLayerH, char **, GDALProgressFunc, void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGR_L_Update </td>
          <td>(</td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>pLayerInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>pLayerMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRLayerH&nbsp;</td>
          <td class="paramname"> <em>pLayerResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&nbsp;</td>
          <td class="paramname"> <em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pProgressArg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update this layer with features from the update layer. </p>
<p>The result layer contains features whose geometries represent areas that are either in the input layer or in the method layer. The features in the result layer have areas of the features of the method layer or those ares of the features of the input layer that are not covered by the method layer. The features of the result layer get their attributes from the input layer. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in the input layer.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If the schema of the result is set by user and contains fields that have the same name as a field in the method layer, then the attribute in the result feature the originates from the method layer will get the value from the feature of the method layer.</dd>
<dd>
For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</dd>
<dd>
This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</dd></dl>
<p>The recognized list of options is : </p>
<ul>
<li>
SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted. </li>
<li>
PROMOTE_TO_MULTI=YES/NO. Set it to YES to convert Polygons into MultiPolygons, or LineStrings to MultiLineStrings. </li>
<li>
INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer. </li>
<li>
METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer. </li>
</ul>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#aa1c5dc5ca195956c46d35a85b0b21d9b" title="Update this layer with features from the update layer.">OGRLayer::Update()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pLayerInput</em>&nbsp;</td><td>the input layer. Should not be NULL.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pLayerMethod</em>&nbsp;</td><td>the method layer. Should not be NULL.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pLayerResult</em>&nbsp;</td><td>the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>papszOptions</em>&nbsp;</td><td>NULL terminated list of options (may be NULL).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnProgress</em>&nbsp;</td><td>a GDALProgressFunc() compatible callback function for reporting progress or NULL.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pProgressArg</em>&nbsp;</td><td>argument to be passed to pfnProgress. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.10 </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a87b478c971619145dee7d8d8deeac702">OGR_L_Update()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a87b478c971619145dee7d8d8deeac702">OGR_L_Update()</a>.</p>

</div>
</div>
<a class="anchor" id="af358ec087124f355fca02bf33a1e0027"></a><!-- doxytag: member="ogr_api.h::OGR_SM_AddPart" ref="af358ec087124f355fca02bf33a1e0027" args="(OGRStyleMgrH hSM, OGRStyleToolH hST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_SM_AddPart </td>
          <td>(</td>
          <td class="paramtype">OGRStyleMgrH&nbsp;</td>
          <td class="paramname"> <em>hSM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRStyleToolH&nbsp;</td>
          <td class="paramname"> <em>hST</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a part (style tool) to the current style. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRStyleMgr.html#a3b893dd11e0f009fca53bf42d16abf47" title="Add a part (style tool) to the current style.">OGRStyleMgr::AddPart()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hSM</em>&nbsp;</td><td>handle to the style manager. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hST</em>&nbsp;</td><td>the style tool defining the part to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success, FALSE on errors. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#af358ec087124f355fca02bf33a1e0027">OGR_SM_AddPart()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#af358ec087124f355fca02bf33a1e0027">OGR_SM_AddPart()</a>.</p>

</div>
</div>
<a class="anchor" id="a358c1558e61951b2e1e338ead8401ad8"></a><!-- doxytag: member="ogr_api.h::OGR_SM_AddStyle" ref="a358c1558e61951b2e1e338ead8401ad8" args="(OGRStyleMgrH hSM, const char *pszStyleName, const char *pszStyleString)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_SM_AddStyle </td>
          <td>(</td>
          <td class="paramtype">OGRStyleMgrH&nbsp;</td>
          <td class="paramname"> <em>hSM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszStyleName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszStyleString</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a style to the current style table. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRStyleMgr.html#a7f6c3dcb19e0803ebc3aae61467e00f0" title="Add a style to the current style table.">OGRStyleMgr::AddStyle()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hSM</em>&nbsp;</td><td>handle to the style manager. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszStyleName</em>&nbsp;</td><td>the name of the style to add. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszStyleString</em>&nbsp;</td><td>the style string to use, or NULL to use the style stored in the manager.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success, FALSE on errors. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a358c1558e61951b2e1e338ead8401ad8">OGR_SM_AddStyle()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a358c1558e61951b2e1e338ead8401ad8">OGR_SM_AddStyle()</a>.</p>

</div>
</div>
<a class="anchor" id="aba4d31b48c3c9ea6c1edbe4f0aa65866"></a><!-- doxytag: member="ogr_api.h::OGR_SM_Create" ref="aba4d31b48c3c9ea6c1edbe4f0aa65866" args="(OGRStyleTableH hStyleTable) CPL_WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRStyleMgrH OGR_SM_Create </td>
          <td>(</td>
          <td class="paramtype">OGRStyleTableH&nbsp;</td>
          <td class="paramname"> <em>hStyleTable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classOGRStyleMgr.html">OGRStyleMgr</a> factory. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRStyleMgr.html#abdd3e0eab4c6733e92ddaaf7c69639e5" title="Constructor.">OGRStyleMgr::OGRStyleMgr()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hStyleTable</em>&nbsp;</td><td>pointer to <a class="el" href="classOGRStyleTable.html">OGRStyleTable</a> or NULL if not working with a style table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an handle to the new style manager object. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#aba4d31b48c3c9ea6c1edbe4f0aa65866">OGR_SM_Create()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#aba4d31b48c3c9ea6c1edbe4f0aa65866">OGR_SM_Create()</a>.</p>

</div>
</div>
<a class="anchor" id="a474fca7d9327da916305ec1276a57443"></a><!-- doxytag: member="ogr_api.h::OGR_SM_Destroy" ref="a474fca7d9327da916305ec1276a57443" args="(OGRStyleMgrH hSM)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_SM_Destroy </td>
          <td>(</td>
          <td class="paramtype">OGRStyleMgrH&nbsp;</td>
          <td class="paramname"> <em>hSM</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy Style Manager. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRStyleMgr.html#a534a68c59c66901a6fc01d72130337ae" title="Destructor.">OGRStyleMgr::~OGRStyleMgr()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hSM</em>&nbsp;</td><td>handle to the style manager to destroy. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#a474fca7d9327da916305ec1276a57443">OGR_SM_Destroy()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a474fca7d9327da916305ec1276a57443">OGR_SM_Destroy()</a>.</p>

</div>
</div>
<a class="anchor" id="a61d4e04abb6e3c59ed570c62dffc4164"></a><!-- doxytag: member="ogr_api.h::OGR_SM_GetPart" ref="a61d4e04abb6e3c59ed570c62dffc4164" args="(OGRStyleMgrH hSM, int nPartId, const char *pszStyleString)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRStyleToolH OGR_SM_GetPart </td>
          <td>(</td>
          <td class="paramtype">OGRStyleMgrH&nbsp;</td>
          <td class="paramname"> <em>hSM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nPartId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszStyleString</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch a part (style tool) from the current style. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRStyleMgr.html#a06b9ff4d26e1d7a19dc4f79e52160416" title="Fetch a part (style tool) from the current style.">OGRStyleMgr::GetPart()</a>.</p>
<p>This function instanciates a new object that should be freed with <a class="el" href="ogr__api_8h.html#a5d1ecf398ee062f3f5a297f70244497a" title="Destroy Style Tool.">OGR_ST_Destroy()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hSM</em>&nbsp;</td><td>handle to the style manager. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nPartId</em>&nbsp;</td><td>the part number (0-based index). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszStyleString</em>&nbsp;</td><td>(optional) the style string on which to operate. If NULL then the current style string stored in the style manager is used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRStyleToolH of the requested part (style tools) or NULL on error. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a61d4e04abb6e3c59ed570c62dffc4164">OGR_SM_GetPart()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a61d4e04abb6e3c59ed570c62dffc4164">OGR_SM_GetPart()</a>.</p>

</div>
</div>
<a class="anchor" id="ad272704a535c0fa8cfd7b097eb4968dc"></a><!-- doxytag: member="ogr_api.h::OGR_SM_GetPartCount" ref="ad272704a535c0fa8cfd7b097eb4968dc" args="(OGRStyleMgrH hSM, const char *pszStyleString)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_SM_GetPartCount </td>
          <td>(</td>
          <td class="paramtype">OGRStyleMgrH&nbsp;</td>
          <td class="paramname"> <em>hSM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszStyleString</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the number of parts in a style. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRStyleMgr.html#a111f5e714f48ebd937473e1eea28867c" title="Get the number of parts in a style.">OGRStyleMgr::GetPartCount()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hSM</em>&nbsp;</td><td>handle to the style manager. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszStyleString</em>&nbsp;</td><td>(optional) the style string on which to operate. If NULL then the current style string stored in the style manager is used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of parts (style tools) in the style. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#ad272704a535c0fa8cfd7b097eb4968dc">OGR_SM_GetPartCount()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ad272704a535c0fa8cfd7b097eb4968dc">OGR_SM_GetPartCount()</a>.</p>

</div>
</div>
<a class="anchor" id="afca737ee6586ce8078b52108707b0b6a"></a><!-- doxytag: member="ogr_api.h::OGR_SM_InitFromFeature" ref="afca737ee6586ce8078b52108707b0b6a" args="(OGRStyleMgrH hSM, OGRFeatureH hFeat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_SM_InitFromFeature </td>
          <td>(</td>
          <td class="paramtype">OGRStyleMgrH&nbsp;</td>
          <td class="paramname"> <em>hSM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRFeatureH&nbsp;</td>
          <td class="paramname"> <em>hFeat</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize style manager from the style string of a feature. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRStyleMgr.html#adadbb0a44c3ca3bd11801ee64568d2a6" title="Initialize style manager from the style string of a feature.">OGRStyleMgr::InitFromFeature()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hSM</em>&nbsp;</td><td>handle to the style manager. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hFeat</em>&nbsp;</td><td>handle to the new feature from which to read the style.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to the style string read from the feature, or NULL in case of error. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#afca737ee6586ce8078b52108707b0b6a">OGR_SM_InitFromFeature()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#afca737ee6586ce8078b52108707b0b6a">OGR_SM_InitFromFeature()</a>.</p>

</div>
</div>
<a class="anchor" id="ade49bffec1e796ddf4419f5cbe34fda8"></a><!-- doxytag: member="ogr_api.h::OGR_SM_InitStyleString" ref="ade49bffec1e796ddf4419f5cbe34fda8" args="(OGRStyleMgrH hSM, const char *pszStyleString)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_SM_InitStyleString </td>
          <td>(</td>
          <td class="paramtype">OGRStyleMgrH&nbsp;</td>
          <td class="paramname"> <em>hSM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszStyleString</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize style manager from the style string. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRStyleMgr.html#a0d9d942d7cd5335b82dd4a764cb9ef73" title="Initialize style manager from the style string.">OGRStyleMgr::InitStyleString()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hSM</em>&nbsp;</td><td>handle to the style manager. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszStyleString</em>&nbsp;</td><td>the style string to use (can be NULL).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success, FALSE on errors. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#ade49bffec1e796ddf4419f5cbe34fda8">OGR_SM_InitStyleString()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ade49bffec1e796ddf4419f5cbe34fda8">OGR_SM_InitStyleString()</a>.</p>

</div>
</div>
<a class="anchor" id="a4cc7bc2b21febd7a78d44727ad7de30f"></a><!-- doxytag: member="ogr_api.h::OGR_ST_Create" ref="a4cc7bc2b21febd7a78d44727ad7de30f" args="(OGRSTClassId eClassId) CPL_WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRStyleToolH OGR_ST_Create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a109ea92417a0152008c7c11eeec4f028">OGRSTClassId</a>&nbsp;</td>
          <td class="paramname"> <em>eClassId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classOGRStyleTool.html">OGRStyleTool</a> factory. </p>
<p>This function is a constructor for <a class="el" href="classOGRStyleTool.html">OGRStyleTool</a> derived classes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>eClassId</em>&nbsp;</td><td>subclass of style tool to create. One of OGRSTCPen (1), OGRSTCBrush (2), OGRSTCSymbol (3) or OGRSTCLabel (4).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an handle to the new style tool object or NULL if the creation failed. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a4cc7bc2b21febd7a78d44727ad7de30f">OGR_ST_Create()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a4cc7bc2b21febd7a78d44727ad7de30f">OGR_ST_Create()</a>.</p>

</div>
</div>
<a class="anchor" id="a5d1ecf398ee062f3f5a297f70244497a"></a><!-- doxytag: member="ogr_api.h::OGR_ST_Destroy" ref="a5d1ecf398ee062f3f5a297f70244497a" args="(OGRStyleToolH hST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_ST_Destroy </td>
          <td>(</td>
          <td class="paramtype">OGRStyleToolH&nbsp;</td>
          <td class="paramname"> <em>hST</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy Style Tool. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hST</em>&nbsp;</td><td>handle to the style tool to destroy. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#a5d1ecf398ee062f3f5a297f70244497a">OGR_ST_Destroy()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a5d1ecf398ee062f3f5a297f70244497a">OGR_ST_Destroy()</a>.</p>

</div>
</div>
<a class="anchor" id="a96082cdf432271acfa3b3777c3be853b"></a><!-- doxytag: member="ogr_api.h::OGR_ST_GetParamDbl" ref="a96082cdf432271acfa3b3777c3be853b" args="(OGRStyleToolH hST, int eParam, int *bValueIsNull)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGR_ST_GetParamDbl </td>
          <td>(</td>
          <td class="paramtype">OGRStyleToolH&nbsp;</td>
          <td class="paramname"> <em>hST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>eParam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>bValueIsNull</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get Style Tool parameter value as a double. </p>
<p>Maps to the <a class="el" href="classOGRStyleTool.html">OGRStyleTool</a> subclasses' GetParamDbl() methods.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hST</em>&nbsp;</td><td>handle to the style tool. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eParam</em>&nbsp;</td><td>the parameter id from the enumeration corresponding to the type of this style tool (one of the OGRSTPenParam, OGRSTBrushParam, OGRSTSymbolParam or OGRSTLabelParam enumerations) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bValueIsNull</em>&nbsp;</td><td>pointer to an integer that will be set to TRUE or FALSE to indicate whether the parameter value is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the parameter value as double and sets bValueIsNull. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a96082cdf432271acfa3b3777c3be853b">OGR_ST_GetParamDbl()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a96082cdf432271acfa3b3777c3be853b">OGR_ST_GetParamDbl()</a>.</p>

</div>
</div>
<a class="anchor" id="ad4168832561881cb75dcc7c35935cdd3"></a><!-- doxytag: member="ogr_api.h::OGR_ST_GetParamNum" ref="ad4168832561881cb75dcc7c35935cdd3" args="(OGRStyleToolH hST, int eParam, int *bValueIsNull)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_ST_GetParamNum </td>
          <td>(</td>
          <td class="paramtype">OGRStyleToolH&nbsp;</td>
          <td class="paramname"> <em>hST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>eParam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>bValueIsNull</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get Style Tool parameter value as an integer. </p>
<p>Maps to the <a class="el" href="classOGRStyleTool.html">OGRStyleTool</a> subclasses' GetParamNum() methods.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hST</em>&nbsp;</td><td>handle to the style tool. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eParam</em>&nbsp;</td><td>the parameter id from the enumeration corresponding to the type of this style tool (one of the OGRSTPenParam, OGRSTBrushParam, OGRSTSymbolParam or OGRSTLabelParam enumerations) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bValueIsNull</em>&nbsp;</td><td>pointer to an integer that will be set to TRUE or FALSE to indicate whether the parameter value is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the parameter value as integer and sets bValueIsNull. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#ad4168832561881cb75dcc7c35935cdd3">OGR_ST_GetParamNum()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ad4168832561881cb75dcc7c35935cdd3">OGR_ST_GetParamNum()</a>.</p>

</div>
</div>
<a class="anchor" id="aecadf5738c3b96093605b352a95869f1"></a><!-- doxytag: member="ogr_api.h::OGR_ST_GetParamStr" ref="aecadf5738c3b96093605b352a95869f1" args="(OGRStyleToolH hST, int eParam, int *bValueIsNull)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_ST_GetParamStr </td>
          <td>(</td>
          <td class="paramtype">OGRStyleToolH&nbsp;</td>
          <td class="paramname"> <em>hST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>eParam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>bValueIsNull</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get Style Tool parameter value as string. </p>
<p>Maps to the <a class="el" href="classOGRStyleTool.html">OGRStyleTool</a> subclasses' GetParamStr() methods.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hST</em>&nbsp;</td><td>handle to the style tool. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eParam</em>&nbsp;</td><td>the parameter id from the enumeration corresponding to the type of this style tool (one of the OGRSTPenParam, OGRSTBrushParam, OGRSTSymbolParam or OGRSTLabelParam enumerations) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bValueIsNull</em>&nbsp;</td><td>pointer to an integer that will be set to TRUE or FALSE to indicate whether the parameter value is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the parameter value as string and sets bValueIsNull. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#aecadf5738c3b96093605b352a95869f1">OGR_ST_GetParamStr()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#aecadf5738c3b96093605b352a95869f1">OGR_ST_GetParamStr()</a>.</p>

</div>
</div>
<a class="anchor" id="a906f5e2b901413a0ab5fa35d649847fc"></a><!-- doxytag: member="ogr_api.h::OGR_ST_GetRGBFromString" ref="a906f5e2b901413a0ab5fa35d649847fc" args="(OGRStyleToolH hST, const char *pszColor, int *pnRed, int *pnGreen, int *pnBlue, int *pnAlpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_ST_GetRGBFromString </td>
          <td>(</td>
          <td class="paramtype">OGRStyleToolH&nbsp;</td>
          <td class="paramname"> <em>hST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pnRed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pnGreen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pnBlue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pnAlpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the r,g,b,a components of a color encoded in #RRGGBB[AA] format. </p>
<p>Maps to OGRStyleTool::GetRGBFromString().</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hST</em>&nbsp;</td><td>handle to the style tool. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszColor</em>&nbsp;</td><td>the color to parse </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnRed</em>&nbsp;</td><td>pointer to an int in which the red value will be returned </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnGreen</em>&nbsp;</td><td>pointer to an int in which the green value will be returned </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnBlue</em>&nbsp;</td><td>pointer to an int in which the blue value will be returned </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnAlpha</em>&nbsp;</td><td>pointer to an int in which the (optional) alpha value will be returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the color could be succesfully parsed, or FALSE in case of errors. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a906f5e2b901413a0ab5fa35d649847fc">OGR_ST_GetRGBFromString()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a906f5e2b901413a0ab5fa35d649847fc">OGR_ST_GetRGBFromString()</a>.</p>

</div>
</div>
<a class="anchor" id="a4089c70ce3b1cbea0e45c3375d5093f0"></a><!-- doxytag: member="ogr_api.h::OGR_ST_GetStyleString" ref="a4089c70ce3b1cbea0e45c3375d5093f0" args="(OGRStyleToolH hST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_ST_GetStyleString </td>
          <td>(</td>
          <td class="paramtype">OGRStyleToolH&nbsp;</td>
          <td class="paramname"> <em>hST</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the style string for this Style Tool. </p>
<p>Maps to the <a class="el" href="classOGRStyleTool.html">OGRStyleTool</a> subclasses' GetStyleString() methods.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hST</em>&nbsp;</td><td>handle to the style tool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the style string for this style tool or "" if the hST is invalid. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a4089c70ce3b1cbea0e45c3375d5093f0">OGR_ST_GetStyleString()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a4089c70ce3b1cbea0e45c3375d5093f0">OGR_ST_GetStyleString()</a>.</p>

</div>
</div>
<a class="anchor" id="aae8d0ee36b82c9d1d8d1a0e9b36f2d35"></a><!-- doxytag: member="ogr_api.h::OGR_ST_GetType" ref="aae8d0ee36b82c9d1d8d1a0e9b36f2d35" args="(OGRStyleToolH hST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a109ea92417a0152008c7c11eeec4f028">OGRSTClassId</a> OGR_ST_GetType </td>
          <td>(</td>
          <td class="paramtype">OGRStyleToolH&nbsp;</td>
          <td class="paramname"> <em>hST</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine type of Style Tool. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hST</em>&nbsp;</td><td>handle to the style tool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the style tool type, one of OGRSTCPen (1), OGRSTCBrush (2), OGRSTCSymbol (3) or OGRSTCLabel (4). Returns OGRSTCNone (0) if the OGRStyleToolH is invalid. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#aae8d0ee36b82c9d1d8d1a0e9b36f2d35">OGR_ST_GetType()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#aae8d0ee36b82c9d1d8d1a0e9b36f2d35">OGR_ST_GetType()</a>.</p>

</div>
</div>
<a class="anchor" id="afb52e40f289848d1f228849b6dae2463"></a><!-- doxytag: member="ogr_api.h::OGR_ST_GetUnit" ref="afb52e40f289848d1f228849b6dae2463" args="(OGRStyleToolH hST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#af945b904942ebc25abc8f685bb6b20e1">OGRSTUnitId</a> OGR_ST_GetUnit </td>
          <td>(</td>
          <td class="paramtype">OGRStyleToolH&nbsp;</td>
          <td class="paramname"> <em>hST</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get Style Tool units. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hST</em>&nbsp;</td><td>handle to the style tool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the style tool units. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#afb52e40f289848d1f228849b6dae2463">OGR_ST_GetUnit()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#afb52e40f289848d1f228849b6dae2463">OGR_ST_GetUnit()</a>.</p>

</div>
</div>
<a class="anchor" id="a764f52f8a72e950d0a5d84b7a7b37fc8"></a><!-- doxytag: member="ogr_api.h::OGR_ST_SetParamDbl" ref="a764f52f8a72e950d0a5d84b7a7b37fc8" args="(OGRStyleToolH hST, int eParam, double dfValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_ST_SetParamDbl </td>
          <td>(</td>
          <td class="paramtype">OGRStyleToolH&nbsp;</td>
          <td class="paramname"> <em>hST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>eParam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set Style Tool parameter value from a double. </p>
<p>Maps to the <a class="el" href="classOGRStyleTool.html">OGRStyleTool</a> subclasses' SetParamDbl() methods.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hST</em>&nbsp;</td><td>handle to the style tool. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eParam</em>&nbsp;</td><td>the parameter id from the enumeration corresponding to the type of this style tool (one of the OGRSTPenParam, OGRSTBrushParam, OGRSTSymbolParam or OGRSTLabelParam enumerations) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfValue</em>&nbsp;</td><td>the new parameter value </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#a764f52f8a72e950d0a5d84b7a7b37fc8">OGR_ST_SetParamDbl()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a764f52f8a72e950d0a5d84b7a7b37fc8">OGR_ST_SetParamDbl()</a>.</p>

</div>
</div>
<a class="anchor" id="ac0397850aed3282865b444d65d2deb0e"></a><!-- doxytag: member="ogr_api.h::OGR_ST_SetParamNum" ref="ac0397850aed3282865b444d65d2deb0e" args="(OGRStyleToolH hST, int eParam, int nValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_ST_SetParamNum </td>
          <td>(</td>
          <td class="paramtype">OGRStyleToolH&nbsp;</td>
          <td class="paramname"> <em>hST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>eParam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set Style Tool parameter value from an integer. </p>
<p>Maps to the <a class="el" href="classOGRStyleTool.html">OGRStyleTool</a> subclasses' SetParamNum() methods.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hST</em>&nbsp;</td><td>handle to the style tool. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eParam</em>&nbsp;</td><td>the parameter id from the enumeration corresponding to the type of this style tool (one of the OGRSTPenParam, OGRSTBrushParam, OGRSTSymbolParam or OGRSTLabelParam enumerations) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nValue</em>&nbsp;</td><td>the new parameter value </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#ac0397850aed3282865b444d65d2deb0e">OGR_ST_SetParamNum()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ac0397850aed3282865b444d65d2deb0e">OGR_ST_SetParamNum()</a>.</p>

</div>
</div>
<a class="anchor" id="a88e9561d9a62d6f8368d526eb0468b3a"></a><!-- doxytag: member="ogr_api.h::OGR_ST_SetParamStr" ref="a88e9561d9a62d6f8368d526eb0468b3a" args="(OGRStyleToolH hST, int eParam, const char *pszValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_ST_SetParamStr </td>
          <td>(</td>
          <td class="paramtype">OGRStyleToolH&nbsp;</td>
          <td class="paramname"> <em>hST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>eParam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set Style Tool parameter value from a string. </p>
<p>Maps to the <a class="el" href="classOGRStyleTool.html">OGRStyleTool</a> subclasses' SetParamStr() methods.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hST</em>&nbsp;</td><td>handle to the style tool. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eParam</em>&nbsp;</td><td>the parameter id from the enumeration corresponding to the type of this style tool (one of the OGRSTPenParam, OGRSTBrushParam, OGRSTSymbolParam or OGRSTLabelParam enumerations) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszValue</em>&nbsp;</td><td>the new parameter value </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#a88e9561d9a62d6f8368d526eb0468b3a">OGR_ST_SetParamStr()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a88e9561d9a62d6f8368d526eb0468b3a">OGR_ST_SetParamStr()</a>.</p>

</div>
</div>
<a class="anchor" id="ac9c5b94e6ca32cd53c6a7a9ebc73012c"></a><!-- doxytag: member="ogr_api.h::OGR_ST_SetUnit" ref="ac9c5b94e6ca32cd53c6a7a9ebc73012c" args="(OGRStyleToolH hST, OGRSTUnitId eUnit, double dfGroundPaperScale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_ST_SetUnit </td>
          <td>(</td>
          <td class="paramtype">OGRStyleToolH&nbsp;</td>
          <td class="paramname"> <em>hST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#af945b904942ebc25abc8f685bb6b20e1">OGRSTUnitId</a>&nbsp;</td>
          <td class="paramname"> <em>eUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfGroundPaperScale</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set Style Tool units. </p>
<p>This function is the same as OGRStyleTool::SetUnit()</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hST</em>&nbsp;</td><td>handle to the style tool. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eUnit</em>&nbsp;</td><td>the new unit. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfGroundPaperScale</em>&nbsp;</td><td>ground to paper scale factor. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#ac9c5b94e6ca32cd53c6a7a9ebc73012c">OGR_ST_SetUnit()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ac9c5b94e6ca32cd53c6a7a9ebc73012c">OGR_ST_SetUnit()</a>.</p>

</div>
</div>
<a class="anchor" id="aacd2a4f109627f282c42229eaad7cdfd"></a><!-- doxytag: member="ogr_api.h::OGR_STBL_AddStyle" ref="aacd2a4f109627f282c42229eaad7cdfd" args="(OGRStyleTableH hStyleTable, const char *pszName, const char *pszStyleString)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_STBL_AddStyle </td>
          <td>(</td>
          <td class="paramtype">OGRStyleTableH&nbsp;</td>
          <td class="paramname"> <em>hStyleTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszStyleString</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a new style in the table. No comparison will be done on the Style string, only on the name. This function is the same as the C++ method <a class="el" href="classOGRStyleTable.html#aff722d3fc7c167259dd79986a2574993" title="Add a new style in the table. No comparison will be done on the Style string, only on the name...">OGRStyleTable::AddStyle()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hStyleTable</em>&nbsp;</td><td>handle to the style table. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszName</em>&nbsp;</td><td>the name the style to add. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszStyleString</em>&nbsp;</td><td>the style string to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success, FALSE on error </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#aacd2a4f109627f282c42229eaad7cdfd">OGR_STBL_AddStyle()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#aacd2a4f109627f282c42229eaad7cdfd">OGR_STBL_AddStyle()</a>.</p>

</div>
</div>
<a class="anchor" id="a9c2d216b17d9f09ad6285ce61dcbe826"></a><!-- doxytag: member="ogr_api.h::OGR_STBL_Create" ref="a9c2d216b17d9f09ad6285ce61dcbe826" args="(void) CPL_WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRStyleTableH OGR_STBL_Create </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classOGRStyleTable.html">OGRStyleTable</a> factory. </p>
<p>This function is the same as the C++ method OGRStyleTable::OGRStyleTable().</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an handle to the new style table object. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a9c2d216b17d9f09ad6285ce61dcbe826">OGR_STBL_Create()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a9c2d216b17d9f09ad6285ce61dcbe826">OGR_STBL_Create()</a>.</p>

</div>
</div>
<a class="anchor" id="a5cf4e22eb7ef07c4a3249c21dce48764"></a><!-- doxytag: member="ogr_api.h::OGR_STBL_Destroy" ref="a5cf4e22eb7ef07c4a3249c21dce48764" args="(OGRStyleTableH hSTBL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_STBL_Destroy </td>
          <td>(</td>
          <td class="paramtype">OGRStyleTableH&nbsp;</td>
          <td class="paramname"> <em>hSTBL</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy Style Table. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hSTBL</em>&nbsp;</td><td>handle to the style table to destroy. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#a5cf4e22eb7ef07c4a3249c21dce48764">OGR_STBL_Destroy()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a5cf4e22eb7ef07c4a3249c21dce48764">OGR_STBL_Destroy()</a>.</p>

</div>
</div>
<a class="anchor" id="a57ca305147b3b5a6c3f5fafaee7bc06a"></a><!-- doxytag: member="ogr_api.h::OGR_STBL_Find" ref="a57ca305147b3b5a6c3f5fafaee7bc06a" args="(OGRStyleTableH hStyleTable, const char *pszName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_STBL_Find </td>
          <td>(</td>
          <td class="paramtype">OGRStyleTableH&nbsp;</td>
          <td class="paramname"> <em>hStyleTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a style string by name. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRStyleTable.html#a83347c8a447e454b825784c8f7ce1661" title="Get a style string by name.">OGRStyleTable::Find()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hStyleTable</em>&nbsp;</td><td>handle to the style table. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszName</em>&nbsp;</td><td>the name of the style string to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the style string matching the name or NULL if not found or error. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#a57ca305147b3b5a6c3f5fafaee7bc06a">OGR_STBL_Find()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a57ca305147b3b5a6c3f5fafaee7bc06a">OGR_STBL_Find()</a>.</p>

</div>
</div>
<a class="anchor" id="af8214328c6866f0eb85bba376d94a05e"></a><!-- doxytag: member="ogr_api.h::OGR_STBL_GetLastStyleName" ref="af8214328c6866f0eb85bba376d94a05e" args="(OGRStyleTableH hStyleTable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_STBL_GetLastStyleName </td>
          <td>(</td>
          <td class="paramtype">OGRStyleTableH&nbsp;</td>
          <td class="paramname"> <em>hStyleTable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the style name of the last style string fetched with OGR_STBL_GetNextStyle.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRStyleTable.html#afc78310da48449b9f6a79d20d73e5944" title="Get style name by style string.">OGRStyleTable::GetStyleName()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hStyleTable</em>&nbsp;</td><td>handle to the style table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the Name of the last style string or NULL on error. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#af8214328c6866f0eb85bba376d94a05e">OGR_STBL_GetLastStyleName()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#af8214328c6866f0eb85bba376d94a05e">OGR_STBL_GetLastStyleName()</a>.</p>

</div>
</div>
<a class="anchor" id="ad901a29f17b139108cc6390b9a075e89"></a><!-- doxytag: member="ogr_api.h::OGR_STBL_GetNextStyle" ref="ad901a29f17b139108cc6390b9a075e89" args="(OGRStyleTableH hStyleTable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_STBL_GetNextStyle </td>
          <td>(</td>
          <td class="paramtype">OGRStyleTableH&nbsp;</td>
          <td class="paramname"> <em>hStyleTable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the next style string from the table. </p>
<p>This function is the same as the C++ method OGRStyleTable::GetNextStyle().</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hStyleTable</em>&nbsp;</td><td>handle to the style table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the next style string or NULL on error. </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#ad901a29f17b139108cc6390b9a075e89">OGR_STBL_GetNextStyle()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ad901a29f17b139108cc6390b9a075e89">OGR_STBL_GetNextStyle()</a>.</p>

</div>
</div>
<a class="anchor" id="aed731a5a6fbedde73ed5063d62f3004e"></a><!-- doxytag: member="ogr_api.h::OGR_STBL_LoadStyleTable" ref="aed731a5a6fbedde73ed5063d62f3004e" args="(OGRStyleTableH hStyleTable, const char *pszFilename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_STBL_LoadStyleTable </td>
          <td>(</td>
          <td class="paramtype">OGRStyleTableH&nbsp;</td>
          <td class="paramname"> <em>hStyleTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszFilename</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load a style table from a file. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRStyleTable.html#a1d8b2702ca6c6469d03316b6c9341739" title="Load a style table from a file.">OGRStyleTable::LoadStyleTable()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hStyleTable</em>&nbsp;</td><td>handle to the style table. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszFilename</em>&nbsp;</td><td>the name of the file to load from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success, FALSE on error </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#aed731a5a6fbedde73ed5063d62f3004e">OGR_STBL_LoadStyleTable()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#aed731a5a6fbedde73ed5063d62f3004e">OGR_STBL_LoadStyleTable()</a>.</p>

</div>
</div>
<a class="anchor" id="a69ccd53d6d374d66d42266b3543509f7"></a><!-- doxytag: member="ogr_api.h::OGR_STBL_ResetStyleStringReading" ref="a69ccd53d6d374d66d42266b3543509f7" args="(OGRStyleTableH hStyleTable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_STBL_ResetStyleStringReading </td>
          <td>(</td>
          <td class="paramtype">OGRStyleTableH&nbsp;</td>
          <td class="paramname"> <em>hStyleTable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset the next style pointer to 0. </p>
<p>This function is the same as the C++ method OGRStyleTable::ResetStyleStringReading().</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hStyleTable</em>&nbsp;</td><td>handle to the style table. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ogr__api_8h.html#a69ccd53d6d374d66d42266b3543509f7">OGR_STBL_ResetStyleStringReading()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a69ccd53d6d374d66d42266b3543509f7">OGR_STBL_ResetStyleStringReading()</a>.</p>

</div>
</div>
<a class="anchor" id="aa3e3aca0d4f3fefe3dd64da65814dda7"></a><!-- doxytag: member="ogr_api.h::OGR_STBL_SaveStyleTable" ref="aa3e3aca0d4f3fefe3dd64da65814dda7" args="(OGRStyleTableH hStyleTable, const char *pszFilename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_STBL_SaveStyleTable </td>
          <td>(</td>
          <td class="paramtype">OGRStyleTableH&nbsp;</td>
          <td class="paramname"> <em>hStyleTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszFilename</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save a style table to a file. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRStyleTable.html#a5395e712fa91a3d26f6aed779760983c" title="Save a style table to a file.">OGRStyleTable::SaveStyleTable()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hStyleTable</em>&nbsp;</td><td>handle to the style table. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszFilename</em>&nbsp;</td><td>the name of the file to save to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success, FALSE on error </dd></dl>

<p>References <a class="el" href="ogr__api_8h.html#aa3e3aca0d4f3fefe3dd64da65814dda7">OGR_STBL_SaveStyleTable()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#aa3e3aca0d4f3fefe3dd64da65814dda7">OGR_STBL_SaveStyleTable()</a>.</p>

</div>
</div>
<a class="anchor" id="a74f64386be8d675e8da33d289ccc9892"></a><!-- doxytag: member="ogr_api.h::OGRBuildPolygonFromEdges" ref="a74f64386be8d675e8da33d289ccc9892" args="(OGRGeometryH hLinesAsCollection, int bBestEffort, int bAutoClose, double dfTolerance, OGRErr *peErr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRGeometryH OGRBuildPolygonFromEdges </td>
          <td>(</td>
          <td class="paramtype">OGRGeometryH&nbsp;</td>
          <td class="paramname"> <em>hLines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bBestEffort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bAutoClose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfTolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRErr *&nbsp;</td>
          <td class="paramname"> <em>peErr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Build a ring from a bunch of arcs.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hLines</em>&nbsp;</td><td>handle to an <a class="el" href="classOGRGeometryCollection.html">OGRGeometryCollection</a> (or <a class="el" href="classOGRMultiLineString.html">OGRMultiLineString</a>) containing the line string geometries to be built into rings. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bBestEffort</em>&nbsp;</td><td>not yet implemented???. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bAutoClose</em>&nbsp;</td><td>indicates if the ring should be close when first and last points of the ring are the same. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfTolerance</em>&nbsp;</td><td>tolerance into which two arcs are considered close enough to be joined. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>peErr</em>&nbsp;</td><td>OGRERR_NONE on success, or OGRERR_FAILURE on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an handle to the new geometry, a polygon. </dd></dl>

<p>References <a class="el" href="classOGRLineString.html#aeadb4c3f26162e12eadc311d8ec8ef9f">OGRLineString::addPoint()</a>, <a class="el" href="classOGRPolygon.html#a17f7fca852efca8155fba7cbad7572c0">OGRPolygon::addRingDirectly()</a>, <a class="el" href="classOGRGeometryCollection.html#ad609f2c7886918a766dd3d3a4fa52ec3">OGRGeometryCollection::getGeometryRef()</a>, <a class="el" href="classOGRGeometry.html#a5c6bca18682cb933e3227552d480e1a5">OGRGeometry::getGeometryType()</a>, <a class="el" href="classOGRGeometryCollection.html#a878ea43754b6c6dc824d3a0d1b3dd0e3">OGRGeometryCollection::getNumGeometries()</a>, <a class="el" href="classOGRLineString.html#a7ea70605cd6ac71221177586c2ec5cfc">OGRLineString::getNumPoints()</a>, <a class="el" href="classOGRLineString.html#aa4c8c1c903bca56f64bc5856f42b2e5c">OGRLineString::getX()</a>, <a class="el" href="classOGRLineString.html#abe55ebb3fc3c9491eb937d2c5c240771">OGRLineString::getY()</a>, <a class="el" href="classOGRLineString.html#a9bf6ed6cc59d36b79d0f358f50b3b47a">OGRLineString::getZ()</a>, <a class="el" href="ogr__api_8h.html#a74f64386be8d675e8da33d289ccc9892">OGRBuildPolygonFromEdges()</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa7f299e8edaee30fd3c7a40baf19b48b1">wkbGeometryCollection</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa09fd8f51759a1cf351b04e786a2a9058">wkbLineString</a>, and <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa2ecf4d40ab038779cbc1de22ddcb3429">wkbMultiLineString</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a74f64386be8d675e8da33d289ccc9892">OGRBuildPolygonFromEdges()</a>.</p>

</div>
</div>
<a class="anchor" id="ae5d5a052ed1046ec85236fe4a92733e2"></a><!-- doxytag: member="ogr_api.h::OGRCleanupAll" ref="ae5d5a052ed1046ec85236fe4a92733e2" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRCleanupAll </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cleanup all OGR related resources. </p>
<p>This function will destroy the <a class="el" href="classOGRSFDriverRegistrar.html">OGRSFDriverRegistrar</a> along with all registered drivers, and then cleanup long lived OSR (<a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a>) and CPL resources. This may be called in an application when OGR services are no longer needed. It is not normally required, but by freeing all dynamically allocated memory it can make memory leak testing easier.</p>
<p>In addition to destroying the OGRDriverRegistrar, this function also calls:</p>
<ul>
<li><a class="el" href="ogr__srs__api_8h.html#a4bce8a205f56b514b9550d2eb4ff7c76" title="Cleanup cached SRS related memory.">OSRCleanup()</a></li>
<li>CPLFinderClean()</li>
<li>VSICleanupFileManager()</li>
<li>CPLFreeConfig()</li>
<li>CPLCleanupTLS() </li>
</ul>

<p>References <a class="el" href="ogr__api_8h.html#ae5d5a052ed1046ec85236fe4a92733e2">OGRCleanupAll()</a>, and <a class="el" href="ogr__srs__api_8h.html#a4bce8a205f56b514b9550d2eb4ff7c76">OSRCleanup()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ae5d5a052ed1046ec85236fe4a92733e2">OGRCleanupAll()</a>.</p>

</div>
</div>
<a class="anchor" id="a18492d049ef3b65be20c12f5ad7e29a2"></a><!-- doxytag: member="ogr_api.h::OGRDeregisterDriver" ref="a18492d049ef3b65be20c12f5ad7e29a2" args="(OGRSFDriverH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRDeregisterDriver </td>
          <td>(</td>
          <td class="paramtype">OGRSFDriverH&nbsp;</td>
          <td class="paramname"> <em>hDriver</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove the passed driver from the list of registered drivers. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRSFDriverRegistrar.html#a2ed3257e6310a7d14ce9be39498b87ad" title="Remove the passed driver from the list of registered drivers.">OGRSFDriverRegistrar::DeregisterDriver()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDriver</em>&nbsp;</td><td>handle to the driver to deregister.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since"><dt><b>Since:</b></dt><dd>GDAL 1.8.0 </dd></dl>

<p>References <a class="el" href="classOGRSFDriverRegistrar.html#a2ed3257e6310a7d14ce9be39498b87ad">OGRSFDriverRegistrar::DeregisterDriver()</a>, <a class="el" href="classOGRSFDriverRegistrar.html#afbd5602672ac5f1882055cc459375f8e">OGRSFDriverRegistrar::GetRegistrar()</a>, and <a class="el" href="ogr__api_8h.html#a18492d049ef3b65be20c12f5ad7e29a2">OGRDeregisterDriver()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a18492d049ef3b65be20c12f5ad7e29a2">OGRDeregisterDriver()</a>.</p>

</div>
</div>
<a class="anchor" id="a3f8080605cad5aeef9519c38fe160b51"></a><!-- doxytag: member="ogr_api.h::OGRGetDriver" ref="a3f8080605cad5aeef9519c38fe160b51" args="(int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRSFDriverH OGRGetDriver </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iDriver</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch the indicated driver. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRSFDriverRegistrar.html#a359c5bcb65b737b1c59bab9c2ff78e7e" title="Fetch the indicated driver.">OGRSFDriverRegistrar::GetDriver()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iDriver</em>&nbsp;</td><td>the driver index, from 0 to GetDriverCount()-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>handle to the driver, or NULL if iDriver is out of range. </dd></dl>

<p>References <a class="el" href="classOGRSFDriverRegistrar.html#a359c5bcb65b737b1c59bab9c2ff78e7e">OGRSFDriverRegistrar::GetDriver()</a>, and <a class="el" href="ogr__api_8h.html#a3f8080605cad5aeef9519c38fe160b51">OGRGetDriver()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a3f8080605cad5aeef9519c38fe160b51">OGRGetDriver()</a>.</p>

</div>
</div>
<a class="anchor" id="ae814db7e2212b9bbb0fd8c361bee11fe"></a><!-- doxytag: member="ogr_api.h::OGRGetDriverByName" ref="ae814db7e2212b9bbb0fd8c361bee11fe" args="(const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRSFDriverH OGRGetDriverByName </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszName</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch the indicated driver. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRSFDriverRegistrar.html#ad214c51c2e38d486388f77fb9314143c" title="Fetch the indicated driver.">OGRSFDriverRegistrar::GetDriverByName()</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszName</em>&nbsp;</td><td>the driver name</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the driver, or NULL if no driver with that name is found </dd></dl>

<p>References <a class="el" href="classOGRSFDriverRegistrar.html#ad214c51c2e38d486388f77fb9314143c">OGRSFDriverRegistrar::GetDriverByName()</a>, <a class="el" href="classOGRSFDriverRegistrar.html#afbd5602672ac5f1882055cc459375f8e">OGRSFDriverRegistrar::GetRegistrar()</a>, and <a class="el" href="ogr__api_8h.html#ae814db7e2212b9bbb0fd8c361bee11fe">OGRGetDriverByName()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ae814db7e2212b9bbb0fd8c361bee11fe">OGRGetDriverByName()</a>.</p>

</div>
</div>
<a class="anchor" id="ad0f6d2bbd269b56a61d1c1841dac2575"></a><!-- doxytag: member="ogr_api.h::OGRGetDriverCount" ref="ad0f6d2bbd269b56a61d1c1841dac2575" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRGetDriverCount </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch the number of registered drivers. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRSFDriverRegistrar.html#ad6e753df0c4548187f9fd7e3d5af3999" title="Fetch the number of registered drivers.">OGRSFDriverRegistrar::GetDriverCount()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the drivers count. </dd></dl>

<p>References <a class="el" href="classOGRSFDriverRegistrar.html#ad6e753df0c4548187f9fd7e3d5af3999">OGRSFDriverRegistrar::GetDriverCount()</a>, and <a class="el" href="ogr__api_8h.html#ad0f6d2bbd269b56a61d1c1841dac2575">OGRGetDriverCount()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#ad0f6d2bbd269b56a61d1c1841dac2575">OGRGetDriverCount()</a>.</p>

</div>
</div>
<a class="anchor" id="a273626bc189e1734984afa66b5f76918"></a><!-- doxytag: member="ogr_api.h::OGRGetOpenDS" ref="a273626bc189e1734984afa66b5f76918" args="(int iDS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRDataSourceH OGRGetOpenDS </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iDS</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the iDS th datasource opened. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRSFDriverRegistrar.html#ab9bdaa724b3e1cdaa0b808872f49a48b" title="Return the iDS th datasource opened.">OGRSFDriverRegistrar::GetOpenDS</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iDS</em>&nbsp;</td><td>the index of the dataset to return (between 0 and GetOpenDSCount() - 1) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classOGRSFDriverRegistrar.html#ab9bdaa724b3e1cdaa0b808872f49a48b">OGRSFDriverRegistrar::GetOpenDS()</a>, <a class="el" href="classOGRSFDriverRegistrar.html#afbd5602672ac5f1882055cc459375f8e">OGRSFDriverRegistrar::GetRegistrar()</a>, and <a class="el" href="ogr__api_8h.html#a273626bc189e1734984afa66b5f76918">OGRGetOpenDS()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a273626bc189e1734984afa66b5f76918">OGRGetOpenDS()</a>.</p>

</div>
</div>
<a class="anchor" id="a342fa7b65116145ed01f7e5888abb603"></a><!-- doxytag: member="ogr_api.h::OGRGetOpenDSCount" ref="a342fa7b65116145ed01f7e5888abb603" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRGetOpenDSCount </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the number of opened datasources. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRSFDriverRegistrar.html#af22f975ae36d5b12f04e472d97dadd47" title="Return the number of opened datasources.">OGRSFDriverRegistrar::GetOpenDSCount()</a></p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of opened datasources. </dd></dl>

<p>References <a class="el" href="classOGRSFDriverRegistrar.html#af22f975ae36d5b12f04e472d97dadd47">OGRSFDriverRegistrar::GetOpenDSCount()</a>, <a class="el" href="classOGRSFDriverRegistrar.html#afbd5602672ac5f1882055cc459375f8e">OGRSFDriverRegistrar::GetRegistrar()</a>, and <a class="el" href="ogr__api_8h.html#a342fa7b65116145ed01f7e5888abb603">OGRGetOpenDSCount()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a342fa7b65116145ed01f7e5888abb603">OGRGetOpenDSCount()</a>.</p>

</div>
</div>
<a class="anchor" id="a2da3630231780d519543d1679c83e62f"></a><!-- doxytag: member="ogr_api.h::OGROpen" ref="a2da3630231780d519543d1679c83e62f" args="(const char *, int, OGRSFDriverH *) CPL_WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRDataSourceH OGROpen </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bUpdate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRSFDriverH *&nbsp;</td>
          <td class="paramname"> <em>pahDriverList</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open a file / data source with one of the registered drivers. </p>
<p>This function loops through all the drivers registered with the driver manager trying each until one succeeds with the given data source. This function is static. Applications don't normally need to use any other <a class="el" href="classOGRSFDriverRegistrar.html">OGRSFDriverRegistrar</a> function, not do they normally need to have a pointer to an <a class="el" href="classOGRSFDriverRegistrar.html">OGRSFDriverRegistrar</a> instance.</p>
<p>If this function fails, <a class="el" href="cpl__error_8h.html#a7f71ade3bb0a0e9e45802975ec59ff5e">CPLGetLastErrorMsg()</a> can be used to check if there is an error message explaining why.</p>
<p>For drivers supporting the VSI virtual file API, it is possible to open a file in a .zip archive (see <a class="el" href="cpl__vsi_8h.html#a884fac3cd6be2c09deb807e959d78b3a" title="Install ZIP file system handler.">VSIInstallZipFileHandler()</a>), in a .tar/.tar.gz/.tgz archive (see <a class="el" href="cpl__vsi_8h.html#ad6dd983338849e7da4eaa88f6458ab64" title="Install /vsitar/ file system handler.">VSIInstallTarFileHandler()</a>) or on a HTTP / FTP server (see <a class="el" href="cpl__vsi_8h.html#a4f791960f2d86713d16e99e9c0c36258" title="Install /vsicurl/ HTTP/FTP file system handler (requires libcurl).">VSIInstallCurlFileHandler()</a>)</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRSFDriverRegistrar.html#a5ee13e09d55d146f45bb5417fa524f54" title="Open a file / data source with one of the registered drivers.">OGRSFDriverRegistrar::Open()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszName</em>&nbsp;</td><td>the name of the file, or data source to open. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bUpdate</em>&nbsp;</td><td>FALSE for read-only access (the default) or TRUE for read-write access. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pahDriverList</em>&nbsp;</td><td>if non-NULL, this argument will be updated with a pointer to the driver which was used to open the data source.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NULL on error or if the pass name is not supported by this driver, otherwise an handle to an <a class="el" href="classOGRDataSource.html">OGRDataSource</a>. This <a class="el" href="classOGRDataSource.html">OGRDataSource</a> should be closed by deleting the object when it is no longer needed.</dd></dl>
<p><b>Example:</b></p>
<pre>
    OGRDataSourceH	hDS;
    OGRSFDriverH        *pahDriver;</pre><pre>    hDS = OGROpen( "polygon.shp", 0, pahDriver );
    if( hDS == NULL )
    {
        return;
    }</pre><pre>    ... use the data source ...</pre><pre>    OGRReleaseDataSource( hDS );
  </pre> 
<p>References <a class="el" href="ogr__api_8h.html#a2da3630231780d519543d1679c83e62f">OGROpen()</a>, and <a class="el" href="classOGRSFDriverRegistrar.html#a5ee13e09d55d146f45bb5417fa524f54">OGRSFDriverRegistrar::Open()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a2da3630231780d519543d1679c83e62f">OGROpen()</a>.</p>

</div>
</div>
<a class="anchor" id="a7ace3e4b97b55b999e16557a75bf7226"></a><!-- doxytag: member="ogr_api.h::OGRRegisterDriver" ref="a7ace3e4b97b55b999e16557a75bf7226" args="(OGRSFDriverH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRRegisterDriver </td>
          <td>(</td>
          <td class="paramtype">OGRSFDriverH&nbsp;</td>
          <td class="paramname"> <em>hDriver</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a driver to the list of registered drivers. </p>
<p>If the passed driver is already registered (based on handle comparison) then the driver isn't registered. New drivers are added at the end of the list of registered drivers.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRSFDriverRegistrar.html#a56a1c4fbd9bdfd484a2132963f52de1f" title="Add a driver to the list of registered drivers.">OGRSFDriverRegistrar::RegisterDriver()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDriver</em>&nbsp;</td><td>handle to the driver to add. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classOGRSFDriverRegistrar.html#afbd5602672ac5f1882055cc459375f8e">OGRSFDriverRegistrar::GetRegistrar()</a>, <a class="el" href="ogr__api_8h.html#a7ace3e4b97b55b999e16557a75bf7226">OGRRegisterDriver()</a>, and <a class="el" href="classOGRSFDriverRegistrar.html#a56a1c4fbd9bdfd484a2132963f52de1f">OGRSFDriverRegistrar::RegisterDriver()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a7ace3e4b97b55b999e16557a75bf7226">OGRRegisterDriver()</a>.</p>

</div>
</div>
<a class="anchor" id="ad3abed0c3b232fe55a580726536fe6fa"></a><!-- doxytag: member="ogr_api.h::OGRReleaseDataSource" ref="ad3abed0c3b232fe55a580726536fe6fa" args="(OGRDataSourceH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRReleaseDataSource </td>
          <td>(</td>
          <td class="paramtype">OGRDataSourceH&nbsp;</td>
          <td class="paramname"> <em>hDS</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Drop a reference to this datasource, and if the reference count drops to zero close (destroy) the datasource. </p>
<p>Internally this actually calls the OGRSFDriverRegistrar::ReleaseDataSource() method. This method is essentially a convenient alias.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRDataSource.html#ae4b1cb2d75f251cfb70d8a9c185a001d" title="Drop a reference to this datasource, and if the reference count drops to zero close (destroy) the dat...">OGRDataSource::Release()</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hDS</em>&nbsp;</td><td>handle to the data source to release</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE on success or an error code. </dd></dl>

<p>References <a class="el" href="classOGRSFDriverRegistrar.html#afbd5602672ac5f1882055cc459375f8e">OGRSFDriverRegistrar::GetRegistrar()</a>, and <a class="el" href="ogr__api_8h.html#ad3abed0c3b232fe55a580726536fe6fa">OGRReleaseDataSource()</a>.</p>

<p>Referenced by <a class="el" href="ogr__geocoding_8h.html#aaa63dc51f49e998ef667bff176e9986c">OGRGeocodeDestroySession()</a>, and <a class="el" href="ogr__api_8h.html#ad3abed0c3b232fe55a580726536fe6fa">OGRReleaseDataSource()</a>.</p>

</div>
</div>
<a class="anchor" id="a6d61898bb6267c18ff4a7ec909b0f040"></a><!-- doxytag: member="ogr_api.h::OGRSetGenerate_DB2_V72_BYTE_ORDER" ref="a6d61898bb6267c18ff4a7ec909b0f040" args="(int bGenerate_DB2_V72_BYTE_ORDER)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRSetGenerate_DB2_V72_BYTE_ORDER </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bGenerate_DB2_V72_BYTE_ORDER</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Special entry point to enable the hack for generating DB2 V7.2 style WKB. </p>
<p>DB2 seems to have placed (and require) an extra 0x30 or'ed with the byte order in WKB. This entry point is used to turn on or off the generation of such WKB. </p>

<p>References <a class="el" href="ogr__api_8h.html#a6d61898bb6267c18ff4a7ec909b0f040">OGRSetGenerate_DB2_V72_BYTE_ORDER()</a>.</p>

<p>Referenced by <a class="el" href="ogr__api_8h.html#a6d61898bb6267c18ff4a7ec909b0f040">OGRSetGenerate_DB2_V72_BYTE_ORDER()</a>.</p>

</div>
</div>
</div>
<hr>

Generated for GDAL by 
<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.7.1.
</body>
</html>

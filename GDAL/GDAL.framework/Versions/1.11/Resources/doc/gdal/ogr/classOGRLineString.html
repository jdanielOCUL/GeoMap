<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OGR: OGRLineString Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>OGRLineString Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="OGRLineString" --><!-- doxytag: inherits="OGRCurve" -->
<p><code>#include &lt;<a class="el" href="ogr__geometry_8h_source.html">ogr_geometry.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for OGRLineString:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classOGRLineString.png" usemap="#OGRLineString_map" alt=""/>
  <map id="OGRLineString_map" name="OGRLineString_map">
<area href="classOGRCurve.html" alt="OGRCurve" shape="rect" coords="0,56,100,80"/>
<area href="classOGRGeometry.html" alt="OGRGeometry" shape="rect" coords="0,0,100,24"/>
<area href="classOGRLinearRing.html" alt="OGRLinearRing" shape="rect" coords="0,168,100,192"/>
</map>
</div>

<p><a href="classOGRLineString-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab78f4aaaf619a045be8ebd97b33745d4"></a><!-- doxytag: member="OGRLineString::OGRLineString" ref="ab78f4aaaf619a045be8ebd97b33745d4" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#ab78f4aaaf619a045be8ebd97b33745d4">OGRLineString</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an empty line string. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#a1aabd7032d6579f4fa17fc3849c6a353">WkbSize</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns size of related binary representation.  <a href="#a1aabd7032d6579f4fa17fc3849c6a353"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#ae594aeb14deec56cf957ce54a9f299a7">importFromWkb</a> (unsigned char *, int=-1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign geometry from well known binary data.  <a href="#ae594aeb14deec56cf957ce54a9f299a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#a5f42f63e964b2dff78b7b5529de79731">exportToWkb</a> (OGRwkbByteOrder, unsigned char *, <a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6">OGRwkbVariant</a>=wkbVariantOgc) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a geometry into well known binary format.  <a href="#a5f42f63e964b2dff78b7b5529de79731"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#ada0f0873c302eee9e1c763e06ff9d788">importFromWkt</a> (char **)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign geometry from well known text data.  <a href="#ada0f0873c302eee9e1c763e06ff9d788"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#a80aa40481584eca17808d1abacb435f9">exportToWkt</a> (char **ppszDstText) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a geometry into well known text format.  <a href="#a80aa40481584eca17808d1abacb435f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#a9ef03e6376a2dbaa10181f282f2b1f42">getDimension</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the dimension of this object.  <a href="#a9ef03e6376a2dbaa10181f282f2b1f42"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#aa3274a231b53c920584257e15119b0f6">clone</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a copy of this object.  <a href="#aa3274a231b53c920584257e15119b0f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#a958cec2e062c6372131139be247aecdb">empty</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear geometry information. This restores the geometry to it's initial state after construction, and before assignment of actual geometry.  <a href="#a958cec2e062c6372131139be247aecdb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#acd1805288a923f93a147b643f45e8e68">getEnvelope</a> (<a class="el" href="classOGREnvelope.html">OGREnvelope</a> *psEnvelope) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure.  <a href="#acd1805288a923f93a147b643f45e8e68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#a5f955da6f1d8563a6690b4290c46ae85">getEnvelope</a> (<a class="el" href="classOGREnvelope3D.html">OGREnvelope3D</a> *psEnvelope) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes and returns the bounding envelope (3D) for this geometry in the passed psEnvelope structure.  <a href="#a5f955da6f1d8563a6690b4290c46ae85"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRBoolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#aae5521135ad94d8ea523b9d4d614ffee">IsEmpty</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns TRUE (non-zero) if the object has no points.  <a href="#aae5521135ad94d8ea523b9d4d614ffee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#a7b3dc3abefd16aea17ac9fcc0ccd0010">get_Length</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the length of the curve.  <a href="#a7b3dc3abefd16aea17ac9fcc0ccd0010"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#a48a9e983559b88ecad0629db15f0c790">StartPoint</a> (<a class="el" href="classOGRPoint.html">OGRPoint</a> *) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the curve start point.  <a href="#a48a9e983559b88ecad0629db15f0c790"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#a99daa05665aef02aa0601eb53af814c1">EndPoint</a> (<a class="el" href="classOGRPoint.html">OGRPoint</a> *) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the curve end point.  <a href="#a99daa05665aef02aa0601eb53af814c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#a1298b99690b359cc37aa7314a6c150a0">Value</a> (double, <a class="el" href="classOGRPoint.html">OGRPoint</a> *) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch point at given distance along curve.  <a href="#a1298b99690b359cc37aa7314a6c150a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#a5d68c266dedcd2fa0719fd4c9cb063e2">Project</a> (const <a class="el" href="classOGRPoint.html">OGRPoint</a> *) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Project point on linestring.  <a href="#a5d68c266dedcd2fa0719fd4c9cb063e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRLineString.html">OGRLineString</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#ac1f06067f941e08a4446014be51cdae6">getSubLine</a> (double, double, int) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the portion of linestring.  <a href="#ac1f06067f941e08a4446014be51cdae6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#a7ea70605cd6ac71221177586c2ec5cfc">getNumPoints</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch vertex count.  <a href="#a7ea70605cd6ac71221177586c2ec5cfc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#aab63760022e49a795477f2fd31da059f">getPoint</a> (int, <a class="el" href="classOGRPoint.html">OGRPoint</a> *) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch a point in line string.  <a href="#aab63760022e49a795477f2fd31da059f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#aa4c8c1c903bca56f64bc5856f42b2e5c">getX</a> (int i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get X at vertex.  <a href="#aa4c8c1c903bca56f64bc5856f42b2e5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#abe55ebb3fc3c9491eb937d2c5c240771">getY</a> (int i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get Y at vertex.  <a href="#abe55ebb3fc3c9491eb937d2c5c240771"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#a9bf6ed6cc59d36b79d0f358f50b3b47a">getZ</a> (int i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get Z at vertex.  <a href="#a9bf6ed6cc59d36b79d0f358f50b3b47a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRBoolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#a8568a09caf084295b39df28c31586c01">Equals</a> (<a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns TRUE if two geometries are equivalent.  <a href="#a8568a09caf084295b39df28c31586c01"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#aed2edaf7e5af02f2724ec073f0957ee0">setCoordinateDimension</a> (int nDimension)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the coordinate dimension.  <a href="#aed2edaf7e5af02f2724ec073f0957ee0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#a7d7d288f869c9431a88d2012d96132b9">setNumPoints</a> (int nNewPointCount, int bZeroizeNewContent=TRUE)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set number of points in geometry.  <a href="#a7d7d288f869c9431a88d2012d96132b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#a68fe89e30ccbfaf76c481349c13968c4">setPoint</a> (int, <a class="el" href="classOGRPoint.html">OGRPoint</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the location of a vertex in line string.  <a href="#a68fe89e30ccbfaf76c481349c13968c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#a7f4e168b7c4533613e53a5e24eeb63ab">setPoint</a> (int, double, double, double)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the location of a vertex in line string.  <a href="#a7f4e168b7c4533613e53a5e24eeb63ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#a49a2c161f48b2bd5ad6c7e2832c0cf15">setPoints</a> (int, <a class="el" href="classOGRRawPoint.html">OGRRawPoint</a> *, double *=NULL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign all points in a line string.  <a href="#a49a2c161f48b2bd5ad6c7e2832c0cf15"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#a1806abce9d10d92c3b1de838796811f1">setPoints</a> (int, double *padfX, double *padfY, double *padfZ=NULL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign all points in a line string.  <a href="#a1806abce9d10d92c3b1de838796811f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#aeadb4c3f26162e12eadc311d8ec8ef9f">addPoint</a> (<a class="el" href="classOGRPoint.html">OGRPoint</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a point to a line string.  <a href="#aeadb4c3f26162e12eadc311d8ec8ef9f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#a8bee5999f1ffe9f4debb452d552c46d5">addPoint</a> (double, double, double)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a point to a line string.  <a href="#a8bee5999f1ffe9f4debb452d552c46d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#a3cf1133f3f80193a74cb89daafa69021">getPoints</a> (<a class="el" href="classOGRRawPoint.html">OGRRawPoint</a> *, double *=NULL) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns all points of line string.  <a href="#a3cf1133f3f80193a74cb89daafa69021"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#afce9d376582a994366814b741f598a63">getPoints</a> (void *pabyX, int nXStride, void *pabyY, int nYStride, void *pabyZ=NULL, int nZStride=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns all points of line string.  <a href="#afce9d376582a994366814b741f598a63"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#ae43246dc54357517eeca68c7112ae0f5">addSubLineString</a> (const <a class="el" href="classOGRLineString.html">OGRLineString</a> *, int nStartVertex=0, int nEndVertex=-1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a segment of another linestring to this one.  <a href="#ae43246dc54357517eeca68c7112ae0f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#ac8299e2d3d5a3d6cf4bc9323d842db3a">reversePoints</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reverse point order.  <a href="#ac8299e2d3d5a3d6cf4bc9323d842db3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#a5654b3123a1b296d09f32ee3c5c68bfa">getGeometryType</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch geometry type.  <a href="#a5654b3123a1b296d09f32ee3c5c68bfa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#ab6f7736ff4bd435528b793374f9544ea">getGeometryName</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch WKT name for geometry type.  <a href="#ab6f7736ff4bd435528b793374f9544ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OGRErr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#a75675b1f158fd1d5d35cc431227ed000">transform</a> (<a class="el" href="classOGRCoordinateTransformation.html">OGRCoordinateTransformation</a> *poCT)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Apply arbitrary coordinate transformation to geometry.  <a href="#a75675b1f158fd1d5d35cc431227ed000"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#a79882a4aba981daf0f2af80d1fbb9b21">flattenTo2D</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert geometry to strictly 2D. In a sense this converts all Z coordinates to 0.0.  <a href="#a79882a4aba981daf0f2af80d1fbb9b21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#aee1a3d911818f745cf22e30d53ed160d">segmentize</a> (double dfMaxLength)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modify the geometry such it has no segment longer then the given distance.  <a href="#aee1a3d911818f745cf22e30d53ed160d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLineString.html#a31c99de8c53fbd8c3e719dd1b56d915d">swapXY</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swap x and y coordinates.  <a href="#a31c99de8c53fbd8c3e719dd1b56d915d"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Concrete representation of a multi-vertex line. </p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aeadb4c3f26162e12eadc311d8ec8ef9f"></a><!-- doxytag: member="OGRLineString::addPoint" ref="aeadb4c3f26162e12eadc311d8ec8ef9f" args="(OGRPoint *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRLineString::addPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRPoint.html">OGRPoint</a> *&nbsp;</td>
          <td class="paramname"> <em>poPoint</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a point to a line string. </p>
<p>The vertex count of the line string is increased by one, and assigned from the passed location value.</p>
<p>There is no SFCOM analog to this method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poPoint</em>&nbsp;</td><td>the point to assign to the new vertex. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classOGRGeometry.html#a2a93f43a3b66462195b46f7fd2196dfc">OGRGeometry::getCoordinateDimension()</a>, <a class="el" href="classOGRPoint.html#a1d7f8cb579cd0d029efda38026bf4b68">OGRPoint::getX()</a>, <a class="el" href="classOGRPoint.html#a235eac8e50f6ce105ff5c16655d05ba9">OGRPoint::getY()</a>, <a class="el" href="classOGRPoint.html#aab4cdc7e562cf4725a189698bb5f4075">OGRPoint::getZ()</a>, and <a class="el" href="classOGRLineString.html#a68fe89e30ccbfaf76c481349c13968c4">setPoint()</a>.</p>

<p>Referenced by <a class="el" href="classOGRLinearRing.html#a78d316c3e146dc8ee23a58336162d68a">OGRLinearRing::closeRings()</a>, <a class="el" href="classOGRLineString.html#ac1f06067f941e08a4446014be51cdae6">getSubLine()</a>, <a class="el" href="ogr__api_8h.html#a74f64386be8d675e8da33d289ccc9892">OGRBuildPolygonFromEdges()</a>, and <a class="el" href="classOGRLayer.html#a5cd4ceb8f4ec20594be63280c8e4498a">OGRLayer::SetSpatialFilterRect()</a>.</p>

</div>
</div>
<a class="anchor" id="a8bee5999f1ffe9f4debb452d552c46d5"></a><!-- doxytag: member="OGRLineString::addPoint" ref="a8bee5999f1ffe9f4debb452d552c46d5" args="(double, double, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRLineString::addPoint </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a point to a line string. </p>
<p>The vertex count of the line string is increased by one, and assigned from the passed location value.</p>
<p>There is no SFCOM analog to this method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>the X coordinate to assign to the new point. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>the Y coordinate to assign to the new point. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>z</em>&nbsp;</td><td>the Z coordinate to assign to the new point (defaults to zero). </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classOGRLineString.html#a68fe89e30ccbfaf76c481349c13968c4">setPoint()</a>.</p>

</div>
</div>
<a class="anchor" id="ae43246dc54357517eeca68c7112ae0f5"></a><!-- doxytag: member="OGRLineString::addSubLineString" ref="ae43246dc54357517eeca68c7112ae0f5" args="(const OGRLineString *, int nStartVertex=0, int nEndVertex=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRLineString::addSubLineString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRLineString.html">OGRLineString</a> *&nbsp;</td>
          <td class="paramname"> <em>poOtherLine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nStartVertex</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nEndVertex</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a segment of another linestring to this one. </p>
<p>Adds the request range of vertices to the end of this line string in an efficient manner. If the nStartVertex is larger than the nEndVertex then the vertices will be reversed as they are copied.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poOtherLine</em>&nbsp;</td><td>the other <a class="el" href="classOGRLineString.html">OGRLineString</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nStartVertex</em>&nbsp;</td><td>the first vertex to copy, defaults to 0 to start with the first vertex in the other linestring. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nEndVertex</em>&nbsp;</td><td>the last vertex to copy, defaults to -1 indicating the last vertex of the other line string. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classOGRLineString.html#a7ea70605cd6ac71221177586c2ec5cfc">getNumPoints()</a>, and <a class="el" href="classOGRLineString.html#a7d7d288f869c9431a88d2012d96132b9">setNumPoints()</a>.</p>

<p>Referenced by <a class="el" href="classOGRGeometryFactory.html#adcae79ea28620e332a3d1df87f1180f3">OGRGeometryFactory::forceToLineString()</a>, and <a class="el" href="classOGRGeometryFactory.html#a1c00a78cec110d71175726d6f26b1b39">OGRGeometryFactory::forceToMultiLineString()</a>.</p>

</div>
</div>
<a class="anchor" id="aa3274a231b53c920584257e15119b0f6"></a><!-- doxytag: member="OGRLineString::clone" ref="aa3274a231b53c920584257e15119b0f6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRLineString::clone </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a copy of this object. </p>
<p>This method relates to the SFCOM IGeometry::clone() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a1725918932da7d59f9ee72829ac171fa" title="Make a copy of this object.">OGR_G_Clone()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new object instance with the same geometry, and spatial reference system as the original. </dd></dl>

<p>Implements <a class="el" href="classOGRGeometry.html#af4cf9f6eee1997268a481b39401c3161">OGRGeometry</a>.</p>

<p>Reimplemented in <a class="el" href="classOGRLinearRing.html#a7f64b5d73de1fc1df6e0de938e5fac63">OGRLinearRing</a>.</p>

<p>References <a class="el" href="classOGRGeometry.html#a4308e3549c65aa12cc2ba41be15d99a0">OGRGeometry::assignSpatialReference()</a>, <a class="el" href="classOGRGeometry.html#a2a93f43a3b66462195b46f7fd2196dfc">OGRGeometry::getCoordinateDimension()</a>, <a class="el" href="classOGRGeometry.html#a194f0bbdae896539852106cafbffbe87">OGRGeometry::getSpatialReference()</a>, <a class="el" href="classOGRLineString.html#ab78f4aaaf619a045be8ebd97b33745d4">OGRLineString()</a>, <a class="el" href="classOGRLineString.html#aed2edaf7e5af02f2724ec073f0957ee0">setCoordinateDimension()</a>, and <a class="el" href="classOGRLineString.html#a49a2c161f48b2bd5ad6c7e2832c0cf15">setPoints()</a>.</p>

</div>
</div>
<a class="anchor" id="a958cec2e062c6372131139be247aecdb"></a><!-- doxytag: member="OGRLineString::empty" ref="a958cec2e062c6372131139be247aecdb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRLineString::empty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear geometry information. This restores the geometry to it's initial state after construction, and before assignment of actual geometry. </p>
<p>This method relates to the SFCOM IGeometry::Empty() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a90cc83b0a3052b8fbe2ed77a86323bf2" title="Clear geometry information. This restores the geometry to it&#39;s initial state after construction...">OGR_G_Empty()</a>. </p>

<p>Implements <a class="el" href="classOGRGeometry.html#a1702b5b8142abe761061a6cd44e50b05">OGRGeometry</a>.</p>

<p>References <a class="el" href="classOGRLineString.html#a7d7d288f869c9431a88d2012d96132b9">setNumPoints()</a>.</p>

<p>Referenced by <a class="el" href="classOGRLineString.html#ada0f0873c302eee9e1c763e06ff9d788">importFromWkt()</a>.</p>

</div>
</div>
<a class="anchor" id="a99daa05665aef02aa0601eb53af814c1"></a><!-- doxytag: member="OGRLineString::EndPoint" ref="a99daa05665aef02aa0601eb53af814c1" args="(OGRPoint *) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRLineString::EndPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRPoint.html">OGRPoint</a> *&nbsp;</td>
          <td class="paramname"> <em>poPoint</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the curve end point. </p>
<p>This method relates to the SF COM ICurve::get_EndPoint() method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poPoint</em>&nbsp;</td><td>the point to be assigned the end location. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classOGRCurve.html#a2e9e8e178c7e70efdecd1c50d95d537e">OGRCurve</a>.</p>

<p>References <a class="el" href="classOGRLineString.html#aab63760022e49a795477f2fd31da059f">getPoint()</a>.</p>

<p>Referenced by <a class="el" href="classOGRGeometryFactory.html#adcae79ea28620e332a3d1df87f1180f3">OGRGeometryFactory::forceToLineString()</a>, and <a class="el" href="classOGRLineString.html#a1298b99690b359cc37aa7314a6c150a0">Value()</a>.</p>

</div>
</div>
<a class="anchor" id="a8568a09caf084295b39df28c31586c01"></a><!-- doxytag: member="OGRLineString::Equals" ref="a8568a09caf084295b39df28c31586c01" args="(OGRGeometry *) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRBoolean OGRLineString::Equals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&nbsp;</td>
          <td class="paramname"> <em>poOtherGeom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns TRUE if two geometries are equivalent. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#abaed0c4fb6f08abc280f91619e2e47d3" title="Returns TRUE if two geometries are equivalent.">OGR_G_Equals()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if equivalent or FALSE otherwise. </dd></dl>

<p>Implements <a class="el" href="classOGRGeometry.html#ae751513a46c7e7b154796bfe494faf16">OGRGeometry</a>.</p>

<p>References <a class="el" href="classOGRLineString.html#a5654b3123a1b296d09f32ee3c5c68bfa">getGeometryType()</a>, <a class="el" href="classOGRGeometry.html#a5c6bca18682cb933e3227552d480e1a5">OGRGeometry::getGeometryType()</a>, <a class="el" href="classOGRLineString.html#a7ea70605cd6ac71221177586c2ec5cfc">getNumPoints()</a>, <a class="el" href="classOGRLineString.html#aa4c8c1c903bca56f64bc5856f42b2e5c">getX()</a>, <a class="el" href="classOGRLineString.html#abe55ebb3fc3c9491eb937d2c5c240771">getY()</a>, <a class="el" href="classOGRLineString.html#a9bf6ed6cc59d36b79d0f358f50b3b47a">getZ()</a>, <a class="el" href="classOGRGeometry.html#ac8653ba97e53f3e3b041946ca2acc111">OGRGeometry::IsEmpty()</a>, and <a class="el" href="classOGRLineString.html#aae5521135ad94d8ea523b9d4d614ffee">IsEmpty()</a>.</p>

<p>Referenced by <a class="el" href="classOGRPolygon.html#a5daaf7cbfb1263a4b9fc126f5c51cf37">OGRPolygon::Equals()</a>.</p>

</div>
</div>
<a class="anchor" id="a5f42f63e964b2dff78b7b5529de79731"></a><!-- doxytag: member="OGRLineString::exportToWkb" ref="a5f42f63e964b2dff78b7b5529de79731" args="(OGRwkbByteOrder, unsigned char *, OGRwkbVariant=wkbVariantOgc) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRLineString::exportToWkb </td>
          <td>(</td>
          <td class="paramtype">OGRwkbByteOrder&nbsp;</td>
          <td class="paramname"> <em>eByteOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>pabyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6">OGRwkbVariant</a>&nbsp;</td>
          <td class="paramname"> <em>eWkbVariant</em> = <code>wkbVariantOgc</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a geometry into well known binary format. </p>
<p>This method relates to the SFCOM IWks::ExportToWKB() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ad5c94ae76c09774dba8725c24daeefd6" title="Convert a geometry into well known binary format.">OGR_G_ExportToWkb()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>eByteOrder</em>&nbsp;</td><td>One of wkbXDR or wkbNDR indicating MSB or LSB byte order respectively. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pabyData</em>&nbsp;</td><td>a buffer into which the binary representation is written. This buffer must be at least <a class="el" href="classOGRGeometry.html#acd1a8164dae2e44e50990756ed6b8b4a" title="Returns size of related binary representation.">OGRGeometry::WkbSize()</a> byte in size. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eWkbVariant</em>&nbsp;</td><td>What standard to use when exporting geometries with three dimensions (or more). The default wkbVariantOgc is the historical OGR variant. wkbVariantIso is the variant defined in ISO SQL/MM and adopted by OGC for SFSQL 1.2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Currently OGRERR_NONE is always returned. </dd></dl>

<p>Implements <a class="el" href="classOGRGeometry.html#ad46eeb33da8b6de99f1697f8de9cbea7">OGRGeometry</a>.</p>

<p>Reimplemented in <a class="el" href="classOGRLinearRing.html#ad76cb37e03397d966c76855c422f3975">OGRLinearRing</a>.</p>

<p>References <a class="el" href="classOGRGeometry.html#a2a93f43a3b66462195b46f7fd2196dfc">OGRGeometry::getCoordinateDimension()</a>, <a class="el" href="classOGRLineString.html#a5654b3123a1b296d09f32ee3c5c68bfa">getGeometryType()</a>, and <a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6ac103ec17c4045fb9f3013638726a8bd5">wkbVariantIso</a>.</p>

</div>
</div>
<a class="anchor" id="a80aa40481584eca17808d1abacb435f9"></a><!-- doxytag: member="OGRLineString::exportToWkt" ref="a80aa40481584eca17808d1abacb435f9" args="(char **ppszDstText) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRLineString::exportToWkt </td>
          <td>(</td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>ppszDstText</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a geometry into well known text format. </p>
<p>This method relates to the SFCOM IWks::ExportToWKT() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a3bc9310302e2dbfaab1690de9e2fd2fb" title="Convert a geometry into well known text format.">OGR_G_ExportToWkt()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ppszDstText</em>&nbsp;</td><td>a text buffer is allocated by the program, and assigned to the passed pointer. After use, *ppszDstText should be freed with OGRFree().</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Currently OGRERR_NONE is always returned. </dd></dl>

<p>Implements <a class="el" href="classOGRGeometry.html#a0c941d5efdff84666af5a6f6b540aafb">OGRGeometry</a>.</p>

<p>References <a class="el" href="classOGRGeometry.html#a2a93f43a3b66462195b46f7fd2196dfc">OGRGeometry::getCoordinateDimension()</a>, <a class="el" href="classOGRLineString.html#ab6f7736ff4bd435528b793374f9544ea">getGeometryName()</a>, and <a class="el" href="classOGRLineString.html#aae5521135ad94d8ea523b9d4d614ffee">IsEmpty()</a>.</p>

<p>Referenced by <a class="el" href="classOGRPolygon.html#ade6a6d5d628f3ad57d0ce9dca8e26618">OGRPolygon::exportToWkt()</a>.</p>

</div>
</div>
<a class="anchor" id="a79882a4aba981daf0f2af80d1fbb9b21"></a><!-- doxytag: member="OGRLineString::flattenTo2D" ref="a79882a4aba981daf0f2af80d1fbb9b21" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRLineString::flattenTo2D </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert geometry to strictly 2D. In a sense this converts all Z coordinates to 0.0. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#afdb7354b55c7448b60b44cd9e36073b8" title="Convert geometry to strictly 2D. In a sense this converts all Z coordinates to 0.0.">OGR_G_FlattenTo2D()</a>. </p>

<p>Implements <a class="el" href="classOGRGeometry.html#aaae1a2ced937a5900b2bfeb717bad6c9">OGRGeometry</a>.</p>

</div>
</div>
<a class="anchor" id="a7b3dc3abefd16aea17ac9fcc0ccd0010"></a><!-- doxytag: member="OGRLineString::get_Length" ref="a7b3dc3abefd16aea17ac9fcc0ccd0010" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGRLineString::get_Length </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the length of the curve. </p>
<p>This method relates to the SFCOM ICurve::get_Length() method.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the length of the curve, zero if the curve hasn't been initialized. </dd></dl>

<p>Implements <a class="el" href="classOGRCurve.html#a09d2e65489ca56fc4f09a281b50f3e74">OGRCurve</a>.</p>

<p>Referenced by <a class="el" href="classOGRLineString.html#ac1f06067f941e08a4446014be51cdae6">getSubLine()</a>.</p>

</div>
</div>
<a class="anchor" id="a9ef03e6376a2dbaa10181f282f2b1f42"></a><!-- doxytag: member="OGRLineString::getDimension" ref="a9ef03e6376a2dbaa10181f282f2b1f42" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRLineString::getDimension </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the dimension of this object. </p>
<p>This method corresponds to the SFCOM IGeometry::GetDimension() method. It indicates the dimension of the object, but does not indicate the dimension of the underlying space (as indicated by <a class="el" href="classOGRGeometry.html#a2a93f43a3b66462195b46f7fd2196dfc" title="Get the dimension of the coordinates in this object.">OGRGeometry::getCoordinateDimension()</a>).</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a94b633e1acd208c258ad49f8d4fd4104" title="Get the dimension of this geometry.">OGR_G_GetDimension()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 for points, 1 for lines and 2 for surfaces. </dd></dl>

<p>Implements <a class="el" href="classOGRGeometry.html#aadca09471fa9917452e087ba12d73eeb">OGRGeometry</a>.</p>

</div>
</div>
<a class="anchor" id="acd1805288a923f93a147b643f45e8e68"></a><!-- doxytag: member="OGRLineString::getEnvelope" ref="acd1805288a923f93a147b643f45e8e68" args="(OGREnvelope *psEnvelope) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRLineString::getEnvelope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGREnvelope.html">OGREnvelope</a> *&nbsp;</td>
          <td class="paramname"> <em>psEnvelope</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a617a9c9ea85157661619a1d8f0a69cf9" title="Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure...">OGR_G_GetEnvelope()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psEnvelope</em>&nbsp;</td><td>the structure in which to place the results. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classOGRGeometry.html#aa3d42b06ae6f7bbef6d1a2886da8d398">OGRGeometry</a>.</p>

<p>References <a class="el" href="classOGRLineString.html#aae5521135ad94d8ea523b9d4d614ffee">IsEmpty()</a>.</p>

<p>Referenced by <a class="el" href="classOGRPolygon.html#a00a97e4a76eafe94b5cbb9d52d722457">OGRPolygon::getEnvelope()</a>, and <a class="el" href="classOGRLineString.html#a5f955da6f1d8563a6690b4290c46ae85">getEnvelope()</a>.</p>

</div>
</div>
<a class="anchor" id="a5f955da6f1d8563a6690b4290c46ae85"></a><!-- doxytag: member="OGRLineString::getEnvelope" ref="a5f955da6f1d8563a6690b4290c46ae85" args="(OGREnvelope3D *psEnvelope) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRLineString::getEnvelope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGREnvelope3D.html">OGREnvelope3D</a> *&nbsp;</td>
          <td class="paramname"> <em>psEnvelope</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes and returns the bounding envelope (3D) for this geometry in the passed psEnvelope structure. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a9a950633ac824042b0afdb88c670c5ce" title="Computes and returns the bounding envelope (3D) for this geometry in the passed psEnvelope structure...">OGR_G_GetEnvelope3D()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psEnvelope</em>&nbsp;</td><td>the structure in which to place the results.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.9.0 </dd></dl>

<p>Implements <a class="el" href="classOGRGeometry.html#a3926892dbde299ffd652ee109b5967c5">OGRGeometry</a>.</p>

<p>References <a class="el" href="classOGRLineString.html#acd1805288a923f93a147b643f45e8e68">getEnvelope()</a>, and <a class="el" href="classOGRLineString.html#aae5521135ad94d8ea523b9d4d614ffee">IsEmpty()</a>.</p>

</div>
</div>
<a class="anchor" id="ab6f7736ff4bd435528b793374f9544ea"></a><!-- doxytag: member="OGRLineString::getGeometryName" ref="ab6f7736ff4bd435528b793374f9544ea" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * OGRLineString::getGeometryName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch WKT name for geometry type. </p>
<p>There is no SFCOM analog to this method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a18121f835b2fb724a0c1a87beb1a437a" title="Fetch WKT name for geometry type.">OGR_G_GetGeometryName()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>name used for this geometry type in well known text format. The returned pointer is to a static internal string and should not be modified or freed. </dd></dl>

<p>Implements <a class="el" href="classOGRGeometry.html#aba109e1c53ce1452942f85eae66d88b8">OGRGeometry</a>.</p>

<p>Reimplemented in <a class="el" href="classOGRLinearRing.html#a1db244dfa8106d5068046f50c6b8dd37">OGRLinearRing</a>.</p>

<p>Referenced by <a class="el" href="classOGRLineString.html#a80aa40481584eca17808d1abacb435f9">exportToWkt()</a>, and <a class="el" href="classOGRLineString.html#ada0f0873c302eee9e1c763e06ff9d788">importFromWkt()</a>.</p>

</div>
</div>
<a class="anchor" id="a5654b3123a1b296d09f32ee3c5c68bfa"></a><!-- doxytag: member="OGRLineString::getGeometryType" ref="a5654b3123a1b296d09f32ee3c5c68bfa" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a> OGRLineString::getGeometryType </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch geometry type. </p>
<p>Note that the geometry type may include the 2.5D flag. To get a 2D flattened version of the geometry type apply the wkbFlatten() macro to the return result.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a8fae58102f5c4a4cf2526e5ca8369a76" title="Fetch geometry type.">OGR_G_GetGeometryType()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the geometry type code. </dd></dl>

<p>Implements <a class="el" href="classOGRGeometry.html#a5c6bca18682cb933e3227552d480e1a5">OGRGeometry</a>.</p>

<p>Referenced by <a class="el" href="classOGRLineString.html#a8568a09caf084295b39df28c31586c01">Equals()</a>, and <a class="el" href="classOGRLineString.html#a5f42f63e964b2dff78b7b5529de79731">exportToWkb()</a>.</p>

</div>
</div>
<a class="anchor" id="a7ea70605cd6ac71221177586c2ec5cfc"></a><!-- doxytag: member="OGRLineString::getNumPoints" ref="a7ea70605cd6ac71221177586c2ec5cfc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRLineString::getNumPoints </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch vertex count. </p>
<p>Returns the number of vertices in the line string.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>vertex count. </dd></dl>

<p>Referenced by <a class="el" href="classOGRLineString.html#ae43246dc54357517eeca68c7112ae0f5">addSubLineString()</a>, <a class="el" href="classOGRGeometry.html#a2e70f05d61566a5ddaa29b44f637cfff">OGRGeometry::dumpReadable()</a>, <a class="el" href="classOGRLineString.html#a8568a09caf084295b39df28c31586c01">Equals()</a>, <a class="el" href="classOGRGeometryFactory.html#adcae79ea28620e332a3d1df87f1180f3">OGRGeometryFactory::forceToLineString()</a>, <a class="el" href="classOGRGeometryFactory.html#a1c00a78cec110d71175726d6f26b1b39">OGRGeometryFactory::forceToMultiLineString()</a>, <a class="el" href="classOGRLineString.html#ac1f06067f941e08a4446014be51cdae6">getSubLine()</a>, <a class="el" href="ogr__api_8h.html#a67b897ffcd88a83832964c3735fa1dcb">OGR_G_GetPoint()</a>, <a class="el" href="ogr__api_8h.html#aec43cbe83609bc7b43739d67858846c1">OGR_G_GetPointCount()</a>, <a class="el" href="ogr__api_8h.html#a6c22d91b27d7a42c225a7dfde28f09c4">OGR_G_GetPoints()</a>, <a class="el" href="ogr__api_8h.html#a354146161d0a087b63ab6e350bae4d86">OGR_G_GetX()</a>, <a class="el" href="ogr__api_8h.html#a8405350c9aea2ab7d0f759f0b09b926f">OGR_G_GetY()</a>, <a class="el" href="ogr__api_8h.html#a1d8c6aeb013325f33b8e642003fc17ad">OGR_G_GetZ()</a>, <a class="el" href="ogr__api_8h.html#a74f64386be8d675e8da33d289ccc9892">OGRBuildPolygonFromEdges()</a>, and <a class="el" href="classOGRGeometryFactory.html#afa3e76499553c3dc0a1621af98b88be6">OGRGeometryFactory::organizePolygons()</a>.</p>

</div>
</div>
<a class="anchor" id="aab63760022e49a795477f2fd31da059f"></a><!-- doxytag: member="OGRLineString::getPoint" ref="aab63760022e49a795477f2fd31da059f" args="(int, OGRPoint *) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRLineString::getPoint </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRPoint.html">OGRPoint</a> *&nbsp;</td>
          <td class="paramname"> <em>poPoint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch a point in line string. </p>
<p>This method relates to the SFCOM ILineString::get_Point() method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>the vertex to fetch, from 0 to <a class="el" href="classOGRLineString.html#a7ea70605cd6ac71221177586c2ec5cfc" title="Fetch vertex count.">getNumPoints()</a>-1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>poPoint</em>&nbsp;</td><td>a point to initialize with the fetched point. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classOGRGeometry.html#a2a93f43a3b66462195b46f7fd2196dfc">OGRGeometry::getCoordinateDimension()</a>, <a class="el" href="classOGRPoint.html#a0eef5e2d9e0edeca0e0f06c7527facb4">OGRPoint::setX()</a>, <a class="el" href="classOGRPoint.html#ab064eaaedb2140ed1410e7c2ce4ad1ca">OGRPoint::setY()</a>, and <a class="el" href="classOGRPoint.html#a4330c36258125d939a4ecbbc3bfe66ce">OGRPoint::setZ()</a>.</p>

<p>Referenced by <a class="el" href="classOGRLinearRing.html#a78d316c3e146dc8ee23a58336162d68a">OGRLinearRing::closeRings()</a>, <a class="el" href="classOGRLineString.html#a99daa05665aef02aa0601eb53af814c1">EndPoint()</a>, <a class="el" href="classOGRGeometryFactory.html#afa3e76499553c3dc0a1621af98b88be6">OGRGeometryFactory::organizePolygons()</a>, and <a class="el" href="classOGRLineString.html#a48a9e983559b88ecad0629db15f0c790">StartPoint()</a>.</p>

</div>
</div>
<a class="anchor" id="a3cf1133f3f80193a74cb89daafa69021"></a><!-- doxytag: member="OGRLineString::getPoints" ref="a3cf1133f3f80193a74cb89daafa69021" args="(OGRRawPoint *, double *=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRLineString::getPoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRRawPoint.html">OGRRawPoint</a> *&nbsp;</td>
          <td class="paramname"> <em>paoPointsOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>padfZ</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns all points of line string. </p>
<p>This method copies all points into user list. This list must be at least sizeof(OGRRawPoint) * OGRGeometry::getNumPoints() byte in size. It also copies all Z coordinates.</p>
<p>There is no SFCOM analog to this method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>paoPointsOut</em>&nbsp;</td><td>a buffer into which the points is written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfZ</em>&nbsp;</td><td>the Z values that go with the points (optional, may be NULL). </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="classOGRLineString.html#afce9d376582a994366814b741f598a63">getPoints()</a>, and <a class="el" href="ogr__api_8h.html#a6c22d91b27d7a42c225a7dfde28f09c4">OGR_G_GetPoints()</a>.</p>

</div>
</div>
<a class="anchor" id="afce9d376582a994366814b741f598a63"></a><!-- doxytag: member="OGRLineString::getPoints" ref="afce9d376582a994366814b741f598a63" args="(void *pabyX, int nXStride, void *pabyY, int nYStride, void *pabyZ=NULL, int nZStride=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRLineString::getPoints </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pabyX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nXStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pabyY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nYStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pabyZ</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nZStride</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns all points of line string. </p>
<p>This method copies all points into user arrays. The user provides the stride between 2 consecutives elements of the array.</p>
<p>On some CPU architectures, care must be taken so that the arrays are properly aligned.</p>
<p>There is no SFCOM analog to this method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pabyX</em>&nbsp;</td><td>a buffer of at least (sizeof(double) * nXStride * nPointCount) bytes, may be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nXStride</em>&nbsp;</td><td>the number of bytes between 2 elements of pabyX. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pabyY</em>&nbsp;</td><td>a buffer of at least (sizeof(double) * nYStride * nPointCount) bytes, may be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nYStride</em>&nbsp;</td><td>the number of bytes between 2 elements of pabyY. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pabyZ</em>&nbsp;</td><td>a buffer of at last size (sizeof(double) * nZStride * nPointCount) bytes, may be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nZStride</em>&nbsp;</td><td>the number of bytes between 2 elements of pabyZ.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.9.0 </dd></dl>

<p>References <a class="el" href="classOGRLineString.html#a3cf1133f3f80193a74cb89daafa69021">getPoints()</a>.</p>

</div>
</div>
<a class="anchor" id="ac1f06067f941e08a4446014be51cdae6"></a><!-- doxytag: member="OGRLineString::getSubLine" ref="ac1f06067f941e08a4446014be51cdae6" args="(double, double, int) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRLineString.html">OGRLineString</a> * OGRLineString::getSubLine </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfDistanceFrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfDistanceTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bAsRatio</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the portion of linestring. </p>
<p>The portion of the linestring extracted to new one. The input distances (maybe present as ratio of length of linestring) set begin and end of extracted portion.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dfDistanceFrom</em>&nbsp;</td><td>The distance from the origin of linestring, where the subline should begins </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dfDistanceTo</em>&nbsp;</td><td>The distance from the origin of linestring, where the subline should ends </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bAsRatio</em>&nbsp;</td><td>The flag indicating that distances are the ratio of the linestring length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a newly allocated linestring now owned by the caller, or NULL on failure.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.11.0 </dd></dl>

<p>References <a class="el" href="classOGRLineString.html#aeadb4c3f26162e12eadc311d8ec8ef9f">addPoint()</a>, <a class="el" href="classOGRGeometry.html#a4308e3549c65aa12cc2ba41be15d99a0">OGRGeometry::assignSpatialReference()</a>, <a class="el" href="classOGRLineString.html#a7b3dc3abefd16aea17ac9fcc0ccd0010">get_Length()</a>, <a class="el" href="classOGRGeometry.html#a2a93f43a3b66462195b46f7fd2196dfc">OGRGeometry::getCoordinateDimension()</a>, <a class="el" href="classOGRLineString.html#a7ea70605cd6ac71221177586c2ec5cfc">getNumPoints()</a>, <a class="el" href="classOGRGeometry.html#a194f0bbdae896539852106cafbffbe87">OGRGeometry::getSpatialReference()</a>, <a class="el" href="classOGRLineString.html#ab78f4aaaf619a045be8ebd97b33745d4">OGRLineString()</a>, and <a class="el" href="classOGRLineString.html#aed2edaf7e5af02f2724ec073f0957ee0">setCoordinateDimension()</a>.</p>

</div>
</div>
<a class="anchor" id="aa4c8c1c903bca56f64bc5856f42b2e5c"></a><!-- doxytag: member="OGRLineString::getX" ref="aa4c8c1c903bca56f64bc5856f42b2e5c" args="(int i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGRLineString::getX </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iVertex</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get X at vertex. </p>
<p>Returns the X value at the indicated vertex. If iVertex is out of range a crash may occur, no internal range checking is performed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iVertex</em>&nbsp;</td><td>the vertex to return, between 0 and <a class="el" href="classOGRLineString.html#a7ea70605cd6ac71221177586c2ec5cfc" title="Fetch vertex count.">getNumPoints()</a>-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>X value. </dd></dl>

<p>Referenced by <a class="el" href="classOGRLinearRing.html#a78d316c3e146dc8ee23a58336162d68a">OGRLinearRing::closeRings()</a>, <a class="el" href="classOGRLineString.html#a8568a09caf084295b39df28c31586c01">Equals()</a>, <a class="el" href="ogr__api_8h.html#a67b897ffcd88a83832964c3735fa1dcb">OGR_G_GetPoint()</a>, <a class="el" href="ogr__api_8h.html#a354146161d0a087b63ab6e350bae4d86">OGR_G_GetX()</a>, and <a class="el" href="ogr__api_8h.html#a74f64386be8d675e8da33d289ccc9892">OGRBuildPolygonFromEdges()</a>.</p>

</div>
</div>
<a class="anchor" id="abe55ebb3fc3c9491eb937d2c5c240771"></a><!-- doxytag: member="OGRLineString::getY" ref="abe55ebb3fc3c9491eb937d2c5c240771" args="(int i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGRLineString::getY </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iVertex</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get Y at vertex. </p>
<p>Returns the Y value at the indicated vertex. If iVertex is out of range a crash may occur, no internal range checking is performed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iVertex</em>&nbsp;</td><td>the vertex to return, between 0 and <a class="el" href="classOGRLineString.html#a7ea70605cd6ac71221177586c2ec5cfc" title="Fetch vertex count.">getNumPoints()</a>-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>X value. </dd></dl>

<p>Referenced by <a class="el" href="classOGRLinearRing.html#a78d316c3e146dc8ee23a58336162d68a">OGRLinearRing::closeRings()</a>, <a class="el" href="classOGRLineString.html#a8568a09caf084295b39df28c31586c01">Equals()</a>, <a class="el" href="ogr__api_8h.html#a67b897ffcd88a83832964c3735fa1dcb">OGR_G_GetPoint()</a>, <a class="el" href="ogr__api_8h.html#a8405350c9aea2ab7d0f759f0b09b926f">OGR_G_GetY()</a>, and <a class="el" href="ogr__api_8h.html#a74f64386be8d675e8da33d289ccc9892">OGRBuildPolygonFromEdges()</a>.</p>

</div>
</div>
<a class="anchor" id="a9bf6ed6cc59d36b79d0f358f50b3b47a"></a><!-- doxytag: member="OGRLineString::getZ" ref="a9bf6ed6cc59d36b79d0f358f50b3b47a" args="(int i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGRLineString::getZ </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iVertex</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get Z at vertex. </p>
<p>Returns the Z (elevation) value at the indicated vertex. If no Z value is available, 0.0 is returned. If iVertex is out of range a crash may occur, no internal range checking is performed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iVertex</em>&nbsp;</td><td>the vertex to return, between 0 and <a class="el" href="classOGRLineString.html#a7ea70605cd6ac71221177586c2ec5cfc" title="Fetch vertex count.">getNumPoints()</a>-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Z value. </dd></dl>

<p>Referenced by <a class="el" href="classOGRLinearRing.html#a78d316c3e146dc8ee23a58336162d68a">OGRLinearRing::closeRings()</a>, <a class="el" href="classOGRLineString.html#a8568a09caf084295b39df28c31586c01">Equals()</a>, <a class="el" href="ogr__api_8h.html#a67b897ffcd88a83832964c3735fa1dcb">OGR_G_GetPoint()</a>, <a class="el" href="ogr__api_8h.html#a1d8c6aeb013325f33b8e642003fc17ad">OGR_G_GetZ()</a>, and <a class="el" href="ogr__api_8h.html#a74f64386be8d675e8da33d289ccc9892">OGRBuildPolygonFromEdges()</a>.</p>

</div>
</div>
<a class="anchor" id="ae594aeb14deec56cf957ce54a9f299a7"></a><!-- doxytag: member="OGRLineString::importFromWkb" ref="ae594aeb14deec56cf957ce54a9f299a7" args="(unsigned char *, int=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRLineString::importFromWkb </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>pabyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nSize</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assign geometry from well known binary data. </p>
<p>The object must have already been instantiated as the correct derived type of geometry object to match the binaries type. This method is used by the <a class="el" href="classOGRGeometryFactory.html">OGRGeometryFactory</a> class, but not normally called by application code.</p>
<p>This method relates to the SFCOM IWks::ImportFromWKB() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#afa5a9173aa3b10a4db09ed696a92ba4a" title="Assign geometry from well known binary data.">OGR_G_ImportFromWkb()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pabyData</em>&nbsp;</td><td>the binary input data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nSize</em>&nbsp;</td><td>the size of pabyData in bytes, or zero if not known.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE if all goes well, otherwise any of OGRERR_NOT_ENOUGH_DATA, OGRERR_UNSUPPORTED_GEOMETRY_TYPE, or OGRERR_CORRUPT_DATA may be returned. </dd></dl>

<p>Implements <a class="el" href="classOGRGeometry.html#ab2c6583c2b7c3e526dcfe54a61470c1f">OGRGeometry</a>.</p>

<p>Reimplemented in <a class="el" href="classOGRLinearRing.html#a80fa5c79e98e92a1b58f30b9904c272c">OGRLinearRing</a>.</p>

<p>References <a class="el" href="classOGRLineString.html#a7d7d288f869c9431a88d2012d96132b9">setNumPoints()</a>, and <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa09fd8f51759a1cf351b04e786a2a9058">wkbLineString</a>.</p>

</div>
</div>
<a class="anchor" id="ada0f0873c302eee9e1c763e06ff9d788"></a><!-- doxytag: member="OGRLineString::importFromWkt" ref="ada0f0873c302eee9e1c763e06ff9d788" args="(char **)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRLineString::importFromWkt </td>
          <td>(</td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>ppszInput</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assign geometry from well known text data. </p>
<p>The object must have already been instantiated as the correct derived type of geometry object to match the text type. This method is used by the <a class="el" href="classOGRGeometryFactory.html">OGRGeometryFactory</a> class, but not normally called by application code.</p>
<p>This method relates to the SFCOM IWks::ImportFromWKT() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a4286ba243fb05a831a49f52aabcbc6f8" title="Assign geometry from well known text data.">OGR_G_ImportFromWkt()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ppszInput</em>&nbsp;</td><td>pointer to a pointer to the source text. The pointer is updated to pointer after the consumed text.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE if all goes well, otherwise any of OGRERR_NOT_ENOUGH_DATA, OGRERR_UNSUPPORTED_GEOMETRY_TYPE, or OGRERR_CORRUPT_DATA may be returned. </dd></dl>

<p>Implements <a class="el" href="classOGRGeometry.html#a30561a301d44b1f90393ea4a78a5b0a5">OGRGeometry</a>.</p>

<p>References <a class="el" href="classOGRLineString.html#a958cec2e062c6372131139be247aecdb">empty()</a>, and <a class="el" href="classOGRLineString.html#ab6f7736ff4bd435528b793374f9544ea">getGeometryName()</a>.</p>

</div>
</div>
<a class="anchor" id="aae5521135ad94d8ea523b9d4d614ffee"></a><!-- doxytag: member="OGRLineString::IsEmpty" ref="aae5521135ad94d8ea523b9d4d614ffee" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRBoolean OGRLineString::IsEmpty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns TRUE (non-zero) if the object has no points. </p>
<p>Normally this returns FALSE except between when an object is instantiated and points have been assigned.</p>
<p>This method relates to the SFCOM IGeometry::IsEmpty() method.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if object is empty, otherwise FALSE. </dd></dl>

<p>Implements <a class="el" href="classOGRGeometry.html#ac8653ba97e53f3e3b041946ca2acc111">OGRGeometry</a>.</p>

<p>Referenced by <a class="el" href="classOGRLineString.html#a8568a09caf084295b39df28c31586c01">Equals()</a>, <a class="el" href="classOGRLineString.html#a80aa40481584eca17808d1abacb435f9">exportToWkt()</a>, and <a class="el" href="classOGRLineString.html#acd1805288a923f93a147b643f45e8e68">getEnvelope()</a>.</p>

</div>
</div>
<a class="anchor" id="a5d68c266dedcd2fa0719fd4c9cb063e2"></a><!-- doxytag: member="OGRLineString::Project" ref="a5d68c266dedcd2fa0719fd4c9cb063e2" args="(const OGRPoint *) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGRLineString::Project </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRPoint.html">OGRPoint</a> *&nbsp;</td>
          <td class="paramname"> <em>poPoint</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Project point on linestring. </p>
<p>The input point projeted on linestring. This is the shortest distance from point to the linestring. The distance from begin of linestring to the point projection returned.</p>
<p>This method is built on the GEOS library (GEOS &gt;= 3.2.0), check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always return -1, issuing a CPLE_NotSupported error.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a distance from the begin of the linestring to the projected point.</dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.11.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ac8299e2d3d5a3d6cf4bc9323d842db3a"></a><!-- doxytag: member="OGRLineString::reversePoints" ref="ac8299e2d3d5a3d6cf4bc9323d842db3a" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRLineString::reversePoints </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reverse point order. </p>
<p>This method updates the points in this line string in place reversing the point ordering (first for last, etc). </p>

<p>Referenced by <a class="el" href="classOGRGeometryFactory.html#adcae79ea28620e332a3d1df87f1180f3">OGRGeometryFactory::forceToLineString()</a>.</p>

</div>
</div>
<a class="anchor" id="aee1a3d911818f745cf22e30d53ed160d"></a><!-- doxytag: member="OGRLineString::segmentize" ref="aee1a3d911818f745cf22e30d53ed160d" args="(double dfMaxLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRLineString::segmentize </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfMaxLength</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modify the geometry such it has no segment longer then the given distance. </p>
<p>Interpolated points will have Z and M values (if needed) set to 0. Distance computation is performed in 2d only</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#ade9f08c8d63bc0e726cb20c201c86423" title="Modify the geometry such it has no segment longer then the given distance.">OGR_G_Segmentize()</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dfMaxLength</em>&nbsp;</td><td>the maximum distance between 2 points after segmentization </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classOGRGeometry.html#a91685bd7c0bdd67cd073a8b4da3c06a5">OGRGeometry</a>.</p>

<p>References <a class="el" href="classOGRGeometry.html#a2a93f43a3b66462195b46f7fd2196dfc">OGRGeometry::getCoordinateDimension()</a>.</p>

</div>
</div>
<a class="anchor" id="aed2edaf7e5af02f2724ec073f0957ee0"></a><!-- doxytag: member="OGRLineString::setCoordinateDimension" ref="aed2edaf7e5af02f2724ec073f0957ee0" args="(int nDimension)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRLineString::setCoordinateDimension </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nNewDimension</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the coordinate dimension. </p>
<p>This method sets the explicit coordinate dimension. Setting the coordinate dimension of a geometry to 2 should zero out any existing Z values. Setting the dimension of a geometry collection will not necessarily affect the children geometries.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nNewDimension</em>&nbsp;</td><td>New coordinate dimension value, either 2 or 3. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classOGRGeometry.html#a79f84a2b948d511f28c47c47577dea49">OGRGeometry</a>.</p>

<p>Referenced by <a class="el" href="classOGRLineString.html#aa3274a231b53c920584257e15119b0f6">clone()</a>, <a class="el" href="classOGRPolygon.html#ade6a6d5d628f3ad57d0ce9dca8e26618">OGRPolygon::exportToWkt()</a>, and <a class="el" href="classOGRLineString.html#ac1f06067f941e08a4446014be51cdae6">getSubLine()</a>.</p>

</div>
</div>
<a class="anchor" id="a7d7d288f869c9431a88d2012d96132b9"></a><!-- doxytag: member="OGRLineString::setNumPoints" ref="a7d7d288f869c9431a88d2012d96132b9" args="(int nNewPointCount, int bZeroizeNewContent=TRUE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRLineString::setNumPoints </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nNewPointCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bZeroizeNewContent</em> = <code>TRUE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set number of points in geometry. </p>
<p>This method primary exists to preset the number of points in a linestring geometry before <a class="el" href="classOGRLineString.html#a68fe89e30ccbfaf76c481349c13968c4" title="Set the location of a vertex in line string.">setPoint()</a> is used to assign them to avoid reallocating the array larger with each call to <a class="el" href="classOGRLineString.html#aeadb4c3f26162e12eadc311d8ec8ef9f" title="Add a point to a line string.">addPoint()</a>.</p>
<p>This method has no SFCOM analog.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nNewPointCount</em>&nbsp;</td><td>the new number of points for geometry. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classOGRGeometry.html#a2a93f43a3b66462195b46f7fd2196dfc">OGRGeometry::getCoordinateDimension()</a>.</p>

<p>Referenced by <a class="el" href="classOGRLineString.html#ae43246dc54357517eeca68c7112ae0f5">addSubLineString()</a>, <a class="el" href="classOGRLineString.html#a958cec2e062c6372131139be247aecdb">empty()</a>, <a class="el" href="classOGRLineString.html#ae594aeb14deec56cf957ce54a9f299a7">importFromWkb()</a>, <a class="el" href="ogr__api_8h.html#a4f4f7bff0d685b2713504bd89b14d0fc">OGR_G_SetPointCount()</a>, <a class="el" href="ogr__api_8h.html#a20abd3bb0d4a31b758883312db11cb70">OGR_G_SetPoints()</a>, <a class="el" href="classOGRLineString.html#a7f4e168b7c4533613e53a5e24eeb63ab">setPoint()</a>, and <a class="el" href="classOGRLineString.html#a49a2c161f48b2bd5ad6c7e2832c0cf15">setPoints()</a>.</p>

</div>
</div>
<a class="anchor" id="a68fe89e30ccbfaf76c481349c13968c4"></a><!-- doxytag: member="OGRLineString::setPoint" ref="a68fe89e30ccbfaf76c481349c13968c4" args="(int, OGRPoint *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRLineString::setPoint </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRPoint.html">OGRPoint</a> *&nbsp;</td>
          <td class="paramname"> <em>poPoint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the location of a vertex in line string. </p>
<p>If iPoint is larger than the number of necessary the number of existing points in the line string, the point count will be increased to accomodate the request.</p>
<p>There is no SFCOM analog to this method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iPoint</em>&nbsp;</td><td>the index of the vertex to assign (zero based). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>poPoint</em>&nbsp;</td><td>the value to assign to the vertex. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classOGRGeometry.html#a2a93f43a3b66462195b46f7fd2196dfc">OGRGeometry::getCoordinateDimension()</a>, <a class="el" href="classOGRPoint.html#a1d7f8cb579cd0d029efda38026bf4b68">OGRPoint::getX()</a>, <a class="el" href="classOGRPoint.html#a235eac8e50f6ce105ff5c16655d05ba9">OGRPoint::getY()</a>, and <a class="el" href="classOGRPoint.html#aab4cdc7e562cf4725a189698bb5f4075">OGRPoint::getZ()</a>.</p>

<p>Referenced by <a class="el" href="classOGRLineString.html#aeadb4c3f26162e12eadc311d8ec8ef9f">addPoint()</a>, <a class="el" href="classOGRGeometryFactory.html#a3b8d418c534cc7d909d706b4483316ae">OGRGeometryFactory::approximateArcAngles()</a>, and <a class="el" href="ogr__api_8h.html#a20abd3bb0d4a31b758883312db11cb70">OGR_G_SetPoints()</a>.</p>

</div>
</div>
<a class="anchor" id="a7f4e168b7c4533613e53a5e24eeb63ab"></a><!-- doxytag: member="OGRLineString::setPoint" ref="a7f4e168b7c4533613e53a5e24eeb63ab" args="(int, double, double, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRLineString::setPoint </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>xIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>yIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>zIn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the location of a vertex in line string. </p>
<p>If iPoint is larger than the number of necessary the number of existing points in the line string, the point count will be increased to accomodate the request.</p>
<p>There is no SFCOM analog to this method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iPoint</em>&nbsp;</td><td>the index of the vertex to assign (zero based). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>xIn</em>&nbsp;</td><td>input X coordinate to assign. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>yIn</em>&nbsp;</td><td>input Y coordinate to assign. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>zIn</em>&nbsp;</td><td>input Z coordinate to assign (defaults to zero). </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classOGRGeometry.html#a2a93f43a3b66462195b46f7fd2196dfc">OGRGeometry::getCoordinateDimension()</a>, and <a class="el" href="classOGRLineString.html#a7d7d288f869c9431a88d2012d96132b9">setNumPoints()</a>.</p>

</div>
</div>
<a class="anchor" id="a49a2c161f48b2bd5ad6c7e2832c0cf15"></a><!-- doxytag: member="OGRLineString::setPoints" ref="a49a2c161f48b2bd5ad6c7e2832c0cf15" args="(int, OGRRawPoint *, double *=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRLineString::setPoints </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nPointsIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRRawPoint.html">OGRRawPoint</a> *&nbsp;</td>
          <td class="paramname"> <em>paoPointsIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>padfZ</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assign all points in a line string. </p>
<p>This method clears any existing points assigned to this line string, and assigns a whole new set. It is the most efficient way of assigning the value of a line string.</p>
<p>There is no SFCOM analog to this method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nPointsIn</em>&nbsp;</td><td>number of points being passed in paoPointsIn </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paoPointsIn</em>&nbsp;</td><td>list of points being assigned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfZ</em>&nbsp;</td><td>the Z values that go with the points (optional, may be NULL). </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classOGRGeometry.html#a2a93f43a3b66462195b46f7fd2196dfc">OGRGeometry::getCoordinateDimension()</a>, and <a class="el" href="classOGRLineString.html#a7d7d288f869c9431a88d2012d96132b9">setNumPoints()</a>.</p>

<p>Referenced by <a class="el" href="classOGRLineString.html#aa3274a231b53c920584257e15119b0f6">clone()</a>, <a class="el" href="classOGRLinearRing.html#a7f64b5d73de1fc1df6e0de938e5fac63">OGRLinearRing::clone()</a>, <a class="el" href="classOGRPolygon.html#a84d3b6e0ee2b098528a537bb874b4856">OGRPolygon::importFromWkt()</a>, <a class="el" href="classOGRMultiPolygon.html#a23b4a553c2b3ccde257359c78782eaf8">OGRMultiPolygon::importFromWkt()</a>, <a class="el" href="classOGRMultiLineString.html#a1a71908c13cbe25e4c7b8e2d9cc99af3">OGRMultiLineString::importFromWkt()</a>, <a class="el" href="ogr__api_8h.html#a20abd3bb0d4a31b758883312db11cb70">OGR_G_SetPoints()</a>, and <a class="el" href="classOGRLineString.html#a75675b1f158fd1d5d35cc431227ed000">transform()</a>.</p>

</div>
</div>
<a class="anchor" id="a1806abce9d10d92c3b1de838796811f1"></a><!-- doxytag: member="OGRLineString::setPoints" ref="a1806abce9d10d92c3b1de838796811f1" args="(int, double *padfX, double *padfY, double *padfZ=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRLineString::setPoints </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nPointsIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>padfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>padfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>padfZ</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assign all points in a line string. </p>
<p>This method clear any existing points assigned to this line string, and assigns a whole new set.</p>
<p>There is no SFCOM analog to this method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nPointsIn</em>&nbsp;</td><td>number of points being passed in padfX and padfY. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfX</em>&nbsp;</td><td>list of X coordinates of points being assigned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfY</em>&nbsp;</td><td>list of Y coordinates of points being assigned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>padfZ</em>&nbsp;</td><td>list of Z coordinates of points being assigned (defaults to NULL for 2D objects). </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classOGRLineString.html#a7d7d288f869c9431a88d2012d96132b9">setNumPoints()</a>.</p>

</div>
</div>
<a class="anchor" id="a48a9e983559b88ecad0629db15f0c790"></a><!-- doxytag: member="OGRLineString::StartPoint" ref="a48a9e983559b88ecad0629db15f0c790" args="(OGRPoint *) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRLineString::StartPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRPoint.html">OGRPoint</a> *&nbsp;</td>
          <td class="paramname"> <em>poPoint</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the curve start point. </p>
<p>This method relates to the SF COM ICurve::get_StartPoint() method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poPoint</em>&nbsp;</td><td>the point to be assigned the start location. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classOGRCurve.html#a28510cf9de71e098b50d241f6ab99cd1">OGRCurve</a>.</p>

<p>References <a class="el" href="classOGRLineString.html#aab63760022e49a795477f2fd31da059f">getPoint()</a>.</p>

<p>Referenced by <a class="el" href="classOGRGeometryFactory.html#adcae79ea28620e332a3d1df87f1180f3">OGRGeometryFactory::forceToLineString()</a>, and <a class="el" href="classOGRLineString.html#a1298b99690b359cc37aa7314a6c150a0">Value()</a>.</p>

</div>
</div>
<a class="anchor" id="a31c99de8c53fbd8c3e719dd1b56d915d"></a><!-- doxytag: member="OGRLineString::swapXY" ref="a31c99de8c53fbd8c3e719dd1b56d915d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRLineString::swapXY </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swap x and y coordinates. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>OGR 1.8.0 </dd></dl>

<p>Reimplemented from <a class="el" href="classOGRGeometry.html#a3ffd51d4998a8e2ae422c69b6adf480a">OGRGeometry</a>.</p>

</div>
</div>
<a class="anchor" id="a75675b1f158fd1d5d35cc431227ed000"></a><!-- doxytag: member="OGRLineString::transform" ref="a75675b1f158fd1d5d35cc431227ed000" args="(OGRCoordinateTransformation *poCT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRErr OGRLineString::transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRCoordinateTransformation.html">OGRCoordinateTransformation</a> *&nbsp;</td>
          <td class="paramname"> <em>poCT</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply arbitrary coordinate transformation to geometry. </p>
<p>This method will transform the coordinates of a geometry from their current spatial reference system to a new target spatial reference system. Normally this means reprojecting the vectors, but it could include datum shifts, and changes of units.</p>
<p>Note that this method does not require that the geometry already have a spatial reference system. It will be assumed that they can be treated as having the source spatial reference system of the <a class="el" href="classOGRCoordinateTransformation.html">OGRCoordinateTransformation</a> object, and the actual SRS of the geometry will be ignored. On successful completion the output <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> of the <a class="el" href="classOGRCoordinateTransformation.html">OGRCoordinateTransformation</a> will be assigned to the geometry.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a59a5b3f954b11cfbf6e78807c28d6090" title="Apply arbitrary coordinate transformation to geometry.">OGR_G_Transform()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poCT</em>&nbsp;</td><td>the transformation to apply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OGRERR_NONE on success or an error code. </dd></dl>

<p>Implements <a class="el" href="classOGRGeometry.html#aa9e8bfb3c2129f25cf622660f734e1ba">OGRGeometry</a>.</p>

<p>References <a class="el" href="classOGRGeometry.html#a4308e3549c65aa12cc2ba41be15d99a0">OGRGeometry::assignSpatialReference()</a>, <a class="el" href="classOGRCoordinateTransformation.html#ae56218b826d186a8b7dcaf63d9b14fdd">OGRCoordinateTransformation::GetTargetCS()</a>, <a class="el" href="classOGRLineString.html#a49a2c161f48b2bd5ad6c7e2832c0cf15">setPoints()</a>, and <a class="el" href="classOGRCoordinateTransformation.html#aa8cc3f483b85d633dc88d56bd44f3cd1">OGRCoordinateTransformation::TransformEx()</a>.</p>

<p>Referenced by <a class="el" href="classOGRPolygon.html#aa974efb0dd2bdc7b62fa23dfdc4f8c72">OGRPolygon::transform()</a>.</p>

</div>
</div>
<a class="anchor" id="a1298b99690b359cc37aa7314a6c150a0"></a><!-- doxytag: member="OGRLineString::Value" ref="a1298b99690b359cc37aa7314a6c150a0" args="(double, OGRPoint *) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRLineString::Value </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dfDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRPoint.html">OGRPoint</a> *&nbsp;</td>
          <td class="paramname"> <em>poPoint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch point at given distance along curve. </p>
<p>This method relates to the SF COM ICurve::get_Value() method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dfDistance</em>&nbsp;</td><td>distance along the curve at which to sample position. This distance should be between zero and <a class="el" href="classOGRLineString.html#a7b3dc3abefd16aea17ac9fcc0ccd0010" title="Returns the length of the curve.">get_Length()</a> for this curve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>poPoint</em>&nbsp;</td><td>the point to be assigned the curve position. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classOGRCurve.html#a690570c5282483c043c0badbf94ce38b">OGRCurve</a>.</p>

<p>References <a class="el" href="classOGRLineString.html#a99daa05665aef02aa0601eb53af814c1">EndPoint()</a>, <a class="el" href="classOGRGeometry.html#a2a93f43a3b66462195b46f7fd2196dfc">OGRGeometry::getCoordinateDimension()</a>, <a class="el" href="classOGRPoint.html#a0eef5e2d9e0edeca0e0f06c7527facb4">OGRPoint::setX()</a>, <a class="el" href="classOGRPoint.html#ab064eaaedb2140ed1410e7c2ce4ad1ca">OGRPoint::setY()</a>, <a class="el" href="classOGRPoint.html#a4330c36258125d939a4ecbbc3bfe66ce">OGRPoint::setZ()</a>, and <a class="el" href="classOGRLineString.html#a48a9e983559b88ecad0629db15f0c790">StartPoint()</a>.</p>

</div>
</div>
<a class="anchor" id="a1aabd7032d6579f4fa17fc3849c6a353"></a><!-- doxytag: member="OGRLineString::WkbSize" ref="a1aabd7032d6579f4fa17fc3849c6a353" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRLineString::WkbSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns size of related binary representation. </p>
<p>This method returns the exact number of bytes required to hold the well known binary representation of this geometry object. Its computation may be slightly expensive for complex geometries.</p>
<p>This method relates to the SFCOM IWks::WkbSize() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a5f7035a933b957a9d453184c154c237c" title="Returns size of related binary representation.">OGR_G_WkbSize()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>size of binary representation in bytes. </dd></dl>

<p>Implements <a class="el" href="classOGRGeometry.html#acd1a8164dae2e44e50990756ed6b8b4a">OGRGeometry</a>.</p>

<p>Reimplemented in <a class="el" href="classOGRLinearRing.html#a87b3bfc9b96b5d86e3cc6df4cc5e98ab">OGRLinearRing</a>.</p>

<p>References <a class="el" href="classOGRGeometry.html#a2a93f43a3b66462195b46f7fd2196dfc">OGRGeometry::getCoordinateDimension()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="ogr__geometry_8h_source.html">ogr_geometry.h</a></li>
<li>ogrlinestring.cpp</li>
</ul>
</div>
<hr>

Generated for GDAL by 
<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.7.1.
</body>
</html>

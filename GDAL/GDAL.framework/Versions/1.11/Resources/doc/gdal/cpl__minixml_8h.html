<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>GDAL: cpl_minixml.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>cpl_minixml.h File Reference</h1>  </div>
</div>
<div class="contents">

<p>Definitions for CPL mini XML Parser/Serializer.  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="cpl__port_8h_source.html">cpl_port.h</a>&quot;</code><br/>

<p><a href="cpl__minixml_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Document node structure.  <a href="structCPLXMLNode.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structCPLXMLNode.html">CPLXMLNode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__minixml_8h.html#a0f6327e895fb94bf1d5fec958054599a">CPLXMLNode</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Document node structure.  <a href="#a0f6327e895fb94bf1d5fec958054599a"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__minixml_8h.html#ae2767267ad31c092d81a2380ee3474a1">CPLXMLNodeType</a> { <br/>
&nbsp;&nbsp;<a class="el" href="cpl__minixml_8h.html#ae2767267ad31c092d81a2380ee3474a1a420845ac8b18bb784ec09e50a9bf3d1e">CXT_Element</a> =  0, 
<a class="el" href="cpl__minixml_8h.html#ae2767267ad31c092d81a2380ee3474a1ad3f6532b3d5e40b96af1fe17b6df25a1">CXT_Text</a> =  1, 
<a class="el" href="cpl__minixml_8h.html#ae2767267ad31c092d81a2380ee3474a1ad4a32b8961ea4b6caa7a471fd5c1412d">CXT_Attribute</a> =  2, 
<a class="el" href="cpl__minixml_8h.html#ae2767267ad31c092d81a2380ee3474a1ab3bea14871a8fa6136365aaef2d6ff15">CXT_Comment</a> =  3, 
<br/>
&nbsp;&nbsp;<a class="el" href="cpl__minixml_8h.html#ae2767267ad31c092d81a2380ee3474a1a0e4a04d69bb7e75b6955a282475867f4">CXT_Literal</a> =  4
<br/>
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__minixml_8h.html#ad2770716fe2b8dac4969df728e274c9b">CPLParseXMLString</a> (const char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse an XML string into tree form.  <a href="#ad2770716fe2b8dac4969df728e274c9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__minixml_8h.html#a9e05eabc54728fb3266576404200da40">CPLDestroyXMLNode</a> (<a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy a tree.  <a href="#a9e05eabc54728fb3266576404200da40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__minixml_8h.html#acb137728b61e42765ea7e5188a24f90e">CPLGetXMLNode</a> (<a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *poRoot, const char *pszPath)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find node by path.  <a href="#acb137728b61e42765ea7e5188a24f90e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__minixml_8h.html#aa1d07b7ebe279176dafa455a70043680">CPLSearchXMLNode</a> (<a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *poRoot, const char *pszTarget)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Search for a node in document.  <a href="#aa1d07b7ebe279176dafa455a70043680"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__minixml_8h.html#a17930604c1a02ccf01cee16bc5c170e6">CPLGetXMLValue</a> (<a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *poRoot, const char *pszPath, const char *pszDefault)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch element/attribute value.  <a href="#a17930604c1a02ccf01cee16bc5c170e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__minixml_8h.html#a8779ff560dde3b2cd076a16059e66771">CPLCreateXMLNode</a> (<a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *poParent, <a class="el" href="cpl__minixml_8h.html#ae2767267ad31c092d81a2380ee3474a1">CPLXMLNodeType</a> eType, const char *pszText)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an document tree item.  <a href="#a8779ff560dde3b2cd076a16059e66771"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__minixml_8h.html#a17562c5f454d236e6749c73f4c93de6e">CPLSerializeXMLTree</a> (const <a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *psNode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert tree into string document.  <a href="#a17562c5f454d236e6749c73f4c93de6e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__minixml_8h.html#acf4fd469090f44089221811f1c550742">CPLAddXMLChild</a> (<a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *psParent, <a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *psChild)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add child node to parent.  <a href="#acf4fd469090f44089221811f1c550742"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__minixml_8h.html#aabe9f99875faf356b34d2b97a0668ffb">CPLRemoveXMLChild</a> (<a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *psParent, <a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *psChild)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove child node from parent.  <a href="#aabe9f99875faf356b34d2b97a0668ffb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__minixml_8h.html#aae812ae18fd78d7f8feb387e8f0fc03c">CPLAddXMLSibling</a> (<a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *psOlderSibling, <a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *psNewSibling)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add new sibling.  <a href="#aae812ae18fd78d7f8feb387e8f0fc03c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__minixml_8h.html#afd42dc2352a406a884d77591253e775e">CPLCreateXMLElementAndValue</a> (<a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *psParent, const char *pszName, const char *pszValue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an element and text value.  <a href="#afd42dc2352a406a884d77591253e775e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__minixml_8h.html#a4c39a48d1488b782097730d8aa4508b1">CPLCloneXMLTree</a> (<a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *psTree)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy tree.  <a href="#a4c39a48d1488b782097730d8aa4508b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__minixml_8h.html#a7abd72304d9ba159c965f5095c97b074">CPLSetXMLValue</a> (<a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *psRoot, const char *pszPath, const char *pszValue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set element value by path.  <a href="#a7abd72304d9ba159c965f5095c97b074"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__minixml_8h.html#a47c03d9f9d692128d6fa906c17c44bfc">CPLStripXMLNamespace</a> (<a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *psRoot, const char *pszNameSpace, int bRecurse)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Strip indicated namespaces.  <a href="#a47c03d9f9d692128d6fa906c17c44bfc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__minixml_8h.html#a50df16661471484493d009bb57a18b88">CPLCleanXMLElementName</a> (char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make string into safe XML token.  <a href="#a50df16661471484493d009bb57a18b88"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__minixml_8h.html#aebe69e0041052c5bf04f5ba90ad77234">CPLParseXMLFile</a> (const char *pszFilename)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse XML file into tree.  <a href="#aebe69e0041052c5bf04f5ba90ad77234"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__minixml_8h.html#af44f5b9702a469037e7df18dda8d982c">CPLSerializeXMLTreeToFile</a> (const <a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *psTree, const char *pszFilename)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write document tree to a file.  <a href="#af44f5b9702a469037e7df18dda8d982c"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Definitions for CPL mini XML Parser/Serializer. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a0f6327e895fb94bf1d5fec958054599a"></a><!-- doxytag: member="cpl_minixml.h::CPLXMLNode" ref="a0f6327e895fb94bf1d5fec958054599a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structCPLXMLNode.html">CPLXMLNode</a>  <a class="el" href="structCPLXMLNode.html">CPLXMLNode</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Document node structure. </p>
<p>This C structure is used to hold a single text fragment representing a component of the document when parsed. It should be allocated with the appropriate CPL function, and freed with <a class="el" href="cpl__minixml_8h.html#a9e05eabc54728fb3266576404200da40" title="Destroy a tree.">CPLDestroyXMLNode()</a>. The structure contents should not normally be altered by application code, but may be freely examined by application code.</p>
<p>Using the psChild and psNext pointers, a heirarchical tree structure for a document can be represented as a tree of <a class="el" href="structCPLXMLNode.html" title="Document node structure.">CPLXMLNode</a> structures. </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ae2767267ad31c092d81a2380ee3474a1"></a><!-- doxytag: member="cpl_minixml.h::CPLXMLNodeType" ref="ae2767267ad31c092d81a2380ee3474a1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="cpl__minixml_8h.html#ae2767267ad31c092d81a2380ee3474a1">CPLXMLNodeType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ae2767267ad31c092d81a2380ee3474a1a420845ac8b18bb784ec09e50a9bf3d1e"></a><!-- doxytag: member="CXT_Element" ref="ae2767267ad31c092d81a2380ee3474a1a420845ac8b18bb784ec09e50a9bf3d1e" args="" -->CXT_Element</em>&nbsp;</td><td>
<p>Node is an element </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae2767267ad31c092d81a2380ee3474a1ad3f6532b3d5e40b96af1fe17b6df25a1"></a><!-- doxytag: member="CXT_Text" ref="ae2767267ad31c092d81a2380ee3474a1ad3f6532b3d5e40b96af1fe17b6df25a1" args="" -->CXT_Text</em>&nbsp;</td><td>
<p>Node is a raw text value </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae2767267ad31c092d81a2380ee3474a1ad4a32b8961ea4b6caa7a471fd5c1412d"></a><!-- doxytag: member="CXT_Attribute" ref="ae2767267ad31c092d81a2380ee3474a1ad4a32b8961ea4b6caa7a471fd5c1412d" args="" -->CXT_Attribute</em>&nbsp;</td><td>
<p>Node is attribute </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae2767267ad31c092d81a2380ee3474a1ab3bea14871a8fa6136365aaef2d6ff15"></a><!-- doxytag: member="CXT_Comment" ref="ae2767267ad31c092d81a2380ee3474a1ab3bea14871a8fa6136365aaef2d6ff15" args="" -->CXT_Comment</em>&nbsp;</td><td>
<p>Node is an XML comment. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae2767267ad31c092d81a2380ee3474a1a0e4a04d69bb7e75b6955a282475867f4"></a><!-- doxytag: member="CXT_Literal" ref="ae2767267ad31c092d81a2380ee3474a1a0e4a04d69bb7e75b6955a282475867f4" args="" -->CXT_Literal</em>&nbsp;</td><td>
<p>Node is a special literal </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="acf4fd469090f44089221811f1c550742"></a><!-- doxytag: member="cpl_minixml.h::CPLAddXMLChild" ref="acf4fd469090f44089221811f1c550742" args="(CPLXMLNode *psParent, CPLXMLNode *psChild)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CPLAddXMLChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&nbsp;</td>
          <td class="paramname"> <em>psParent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&nbsp;</td>
          <td class="paramname"> <em>psChild</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add child node to parent. </p>
<p>The passed child is added to the list of children of the indicated parent. Normally the child is added at the end of the parents child list, but attributes (CXT_Attribute) will be inserted after any other attributes but before any other element type. Ownership of the child node is effectively assumed by the parent node. If the child has siblings (it's psNext is not NULL) they will be trimmed, but if the child has children they are carried with it.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psParent</em>&nbsp;</td><td>the node to attach the child to. May not be NULL.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>psChild</em>&nbsp;</td><td>the child to add to the parent. May not be NULL. Should not be a child of any other parent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aae812ae18fd78d7f8feb387e8f0fc03c"></a><!-- doxytag: member="cpl_minixml.h::CPLAddXMLSibling" ref="aae812ae18fd78d7f8feb387e8f0fc03c" args="(CPLXMLNode *psOlderSibling, CPLXMLNode *psNewSibling)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CPLAddXMLSibling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&nbsp;</td>
          <td class="paramname"> <em>psOlderSibling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&nbsp;</td>
          <td class="paramname"> <em>psNewSibling</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add new sibling. </p>
<p>The passed psNewSibling is added to the end of siblings of the psOlderSibling node. That is, it is added to the end of the psNext chain. There is no special handling if psNewSibling is an attribute. If this is required, use <a class="el" href="cpl__minixml_8h.html#acf4fd469090f44089221811f1c550742" title="Add child node to parent.">CPLAddXMLChild()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psOlderSibling</em>&nbsp;</td><td>the node to attach the sibling after.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>psNewSibling</em>&nbsp;</td><td>the node to add at the end of psOlderSiblings psNext chain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a50df16661471484493d009bb57a18b88"></a><!-- doxytag: member="cpl_minixml.h::CPLCleanXMLElementName" ref="a50df16661471484493d009bb57a18b88" args="(char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CPLCleanXMLElementName </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pszTarget</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make string into safe XML token. </p>
<p>Modififies a string in place to try and make it into a legal XML token that can be used as an element name. This is accomplished by changing any characters not legal in a token into an underscore.</p>
<p>NOTE: This function should implement the rules in section 2.3 of <a href="http://www.w3.org/TR/xml11/">http://www.w3.org/TR/xml11/</a> but it doesn't yet do that properly. We only do a rough approximation of that.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszTarget</em>&nbsp;</td><td>the string to be adjusted. It is altered in place. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4c39a48d1488b782097730d8aa4508b1"></a><!-- doxytag: member="cpl_minixml.h::CPLCloneXMLTree" ref="a4c39a48d1488b782097730d8aa4508b1" args="(CPLXMLNode *psTree)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a>* CPLCloneXMLTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&nbsp;</td>
          <td class="paramname"> <em>psTree</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy tree. </p>
<p>Creates a deep copy of a <a class="el" href="structCPLXMLNode.html" title="Document node structure.">CPLXMLNode</a> tree.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psTree</em>&nbsp;</td><td>the tree to duplicate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a copy of the whole tree. </dd></dl>

</div>
</div>
<a class="anchor" id="afd42dc2352a406a884d77591253e775e"></a><!-- doxytag: member="cpl_minixml.h::CPLCreateXMLElementAndValue" ref="afd42dc2352a406a884d77591253e775e" args="(CPLXMLNode *psParent, const char *pszName, const char *pszValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a>* CPLCreateXMLElementAndValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&nbsp;</td>
          <td class="paramname"> <em>psParent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an element and text value. </p>
<p>This is function is a convenient short form for:</p>
<div class="fragment"><pre class="fragment">     <a class="code" href="structCPLXMLNode.html" title="Document node structure.">CPLXMLNode</a> *psTextNode;
     <a class="code" href="structCPLXMLNode.html" title="Document node structure.">CPLXMLNode</a> *psElementNode;

     psElementNode = CPLCreateXMLNode( psParent, <a class="code" href="cpl__minixml_8h.html#ae2767267ad31c092d81a2380ee3474a1a420845ac8b18bb784ec09e50a9bf3d1e">CXT_Element</a>, pszName );
     psTextNode = CPLCreateXMLNode( psElementNode, <a class="code" href="cpl__minixml_8h.html#ae2767267ad31c092d81a2380ee3474a1ad3f6532b3d5e40b96af1fe17b6df25a1">CXT_Text</a>, pszValue );
 
     <span class="keywordflow">return</span> psElementNode;
</pre></div><p>It creates a CXT_Element node, with a CXT_Text child, and attaches the element to the passed parent.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psParent</em>&nbsp;</td><td>the parent node to which the resulting node should be attached. May be NULL to keep as freestanding.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszName</em>&nbsp;</td><td>the element name to create. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszValue</em>&nbsp;</td><td>the text to attach to the element. Must not be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the pointer to the new element node. </dd></dl>

</div>
</div>
<a class="anchor" id="a8779ff560dde3b2cd076a16059e66771"></a><!-- doxytag: member="cpl_minixml.h::CPLCreateXMLNode" ref="a8779ff560dde3b2cd076a16059e66771" args="(CPLXMLNode *poParent, CPLXMLNodeType eType, const char *pszText)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a>* CPLCreateXMLNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&nbsp;</td>
          <td class="paramname"> <em>poParent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__minixml_8h.html#ae2767267ad31c092d81a2380ee3474a1">CPLXMLNodeType</a>&nbsp;</td>
          <td class="paramname"> <em>eType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszText</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an document tree item. </p>
<p>Create a single <a class="el" href="structCPLXMLNode.html" title="Document node structure.">CPLXMLNode</a> object with the desired value and type, and attach it as a child of the indicated parent.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>poParent</em>&nbsp;</td><td>the parent to which this node should be attached as a child. May be NULL to keep as free standing. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eType</em>&nbsp;</td><td>the type of the newly created node </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszText</em>&nbsp;</td><td>the value of the newly created node</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly created node, now owned by the caller (or parent node). </dd></dl>

</div>
</div>
<a class="anchor" id="a9e05eabc54728fb3266576404200da40"></a><!-- doxytag: member="cpl_minixml.h::CPLDestroyXMLNode" ref="a9e05eabc54728fb3266576404200da40" args="(CPLXMLNode *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CPLDestroyXMLNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&nbsp;</td>
          <td class="paramname"> <em>psNode</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy a tree. </p>
<p>This function frees resources associated with a <a class="el" href="structCPLXMLNode.html" title="Document node structure.">CPLXMLNode</a> and all its children nodes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psNode</em>&nbsp;</td><td>the tree to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acb137728b61e42765ea7e5188a24f90e"></a><!-- doxytag: member="cpl_minixml.h::CPLGetXMLNode" ref="acb137728b61e42765ea7e5188a24f90e" args="(CPLXMLNode *poRoot, const char *pszPath)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a>* CPLGetXMLNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&nbsp;</td>
          <td class="paramname"> <em>psRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszPath</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find node by path. </p>
<p>Searches the document or subdocument indicated by psRoot for an element (or attribute) with the given path. The path should consist of a set of element names separated by dots, not including the name of the root element (psRoot). If the requested element is not found NULL is returned.</p>
<p>Attribute names may only appear as the last item in the path.</p>
<p>The search is done from the root nodes children, but all intermediate nodes in the path must be specified. Seaching for "name" would only find a name element or attribute if it is a direct child of the root, not at any level in the subdocument.</p>
<p>If the pszPath is prefixed by "=" then the search will begin with the root node, and it's siblings, instead of the root nodes children. This is particularly useful when searching within a whole document which is often prefixed by one or more "junk" nodes like the &lt;?xml&gt; declaration.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psRoot</em>&nbsp;</td><td>the subtree in which to search. This should be a node of type CXT_Element. NULL is safe.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszPath</em>&nbsp;</td><td>the list of element names in the path (dot separated).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the requested element node, or NULL if not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a17930604c1a02ccf01cee16bc5c170e6"></a><!-- doxytag: member="cpl_minixml.h::CPLGetXMLValue" ref="a17930604c1a02ccf01cee16bc5c170e6" args="(CPLXMLNode *poRoot, const char *pszPath, const char *pszDefault)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* CPLGetXMLValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&nbsp;</td>
          <td class="paramname"> <em>psRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszDefault</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch element/attribute value. </p>
<p>Searches the document for the element/attribute value associated with the path. The corresponding node is internally found with <a class="el" href="cpl__minixml_8h.html#acb137728b61e42765ea7e5188a24f90e" title="Find node by path.">CPLGetXMLNode()</a> (see there for details on path handling). Once found, the value is considered to be the first CXT_Text child of the node.</p>
<p>If the attribute/element search fails, or if the found node has not value then the passed default value is returned.</p>
<p>The returned value points to memory within the document tree, and should not be altered or freed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psRoot</em>&nbsp;</td><td>the subtree in which to search. This should be a node of type CXT_Element. NULL is safe.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszPath</em>&nbsp;</td><td>the list of element names in the path (dot separated). An empty path means get the value of the psRoot node.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszDefault</em>&nbsp;</td><td>the value to return if a corresponding value is not found, may be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the requested value or pszDefault if not found. </dd></dl>

</div>
</div>
<a class="anchor" id="aebe69e0041052c5bf04f5ba90ad77234"></a><!-- doxytag: member="cpl_minixml.h::CPLParseXMLFile" ref="aebe69e0041052c5bf04f5ba90ad77234" args="(const char *pszFilename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a>* CPLParseXMLFile </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszFilename</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Parse XML file into tree. </p>
<p>The named file is opened, loaded into memory as a big string, and parsed with <a class="el" href="cpl__minixml_8h.html#ad2770716fe2b8dac4969df728e274c9b" title="Parse an XML string into tree form.">CPLParseXMLString()</a>. Errors in reading the file or parsing the XML will be reported by <a class="el" href="cpl__error_8h.html#aad2b98dd58e4de706a245faddac90403" title="Report an error.">CPLError()</a>.</p>
<p>The "large file" API is used, so XML files can come from virtualized files.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszFilename</em>&nbsp;</td><td>the file to open.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NULL on failure, or the document tree on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ad2770716fe2b8dac4969df728e274c9b"></a><!-- doxytag: member="cpl_minixml.h::CPLParseXMLString" ref="ad2770716fe2b8dac4969df728e274c9b" args="(const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a>* CPLParseXMLString </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszString</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Parse an XML string into tree form. </p>
<p>The passed document is parsed into a <a class="el" href="structCPLXMLNode.html" title="Document node structure.">CPLXMLNode</a> tree representation. If the document is not well formed XML then NULL is returned, and errors are reported via <a class="el" href="cpl__error_8h.html#aad2b98dd58e4de706a245faddac90403" title="Report an error.">CPLError()</a>. No validation beyond wellformedness is done. The <a class="el" href="cpl__minixml_8h.html#aebe69e0041052c5bf04f5ba90ad77234" title="Parse XML file into tree.">CPLParseXMLFile()</a> convenience function can be used to parse from a file.</p>
<p>The returned document tree is is owned by the caller and should be freed with <a class="el" href="cpl__minixml_8h.html#a9e05eabc54728fb3266576404200da40" title="Destroy a tree.">CPLDestroyXMLNode()</a> when no longer needed.</p>
<p>If the document has more than one "root level" element then those after the first will be attached to the first as siblings (via the psNext pointers) even though there is no common parent. A document with no XML structure (no angle brackets for instance) would be considered well formed, and returned as a single CXT_Text node.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszString</em>&nbsp;</td><td>the document to parse.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>parsed tree or NULL on error. </dd></dl>

</div>
</div>
<a class="anchor" id="aabe9f99875faf356b34d2b97a0668ffb"></a><!-- doxytag: member="cpl_minixml.h::CPLRemoveXMLChild" ref="aabe9f99875faf356b34d2b97a0668ffb" args="(CPLXMLNode *psParent, CPLXMLNode *psChild)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLRemoveXMLChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&nbsp;</td>
          <td class="paramname"> <em>psParent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&nbsp;</td>
          <td class="paramname"> <em>psChild</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove child node from parent. </p>
<p>The passed child is removed from the child list of the passed parent, but the child is not destroyed. The child retains ownership of it's own children, but is cleanly removed from the child list of the parent.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psParent</em>&nbsp;</td><td>the node to the child is attached to.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>psChild</em>&nbsp;</td><td>the child to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success or FALSE if the child was not found. </dd></dl>

</div>
</div>
<a class="anchor" id="aa1d07b7ebe279176dafa455a70043680"></a><!-- doxytag: member="cpl_minixml.h::CPLSearchXMLNode" ref="aa1d07b7ebe279176dafa455a70043680" args="(CPLXMLNode *poRoot, const char *pszTarget)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a>* CPLSearchXMLNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&nbsp;</td>
          <td class="paramname"> <em>psRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszElement</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Search for a node in document. </p>
<p>Searches the children (and potentially siblings) of the documented passed in for the named element or attribute. To search following siblings as well as children, prefix the pszElement name with an equal sign. This function does an in-order traversal of the document tree. So it will first match against the current node, then it's first child, that childs first child, and so on.</p>
<p>Use <a class="el" href="cpl__minixml_8h.html#acb137728b61e42765ea7e5188a24f90e" title="Find node by path.">CPLGetXMLNode()</a> to find a specific child, or along a specific node path.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psRoot</em>&nbsp;</td><td>the subtree to search. This should be a node of type CXT_Element. NULL is safe.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszElement</em>&nbsp;</td><td>the name of the element or attribute to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The matching node or NULL on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a17562c5f454d236e6749c73f4c93de6e"></a><!-- doxytag: member="cpl_minixml.h::CPLSerializeXMLTree" ref="a17562c5f454d236e6749c73f4c93de6e" args="(const CPLXMLNode *psNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* CPLSerializeXMLTree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&nbsp;</td>
          <td class="paramname"> <em>psNode</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert tree into string document. </p>
<p>This function converts a <a class="el" href="structCPLXMLNode.html" title="Document node structure.">CPLXMLNode</a> tree representation of a document into a flat string representation. White space indentation is used visually preserve the tree structure of the document. The returned document becomes owned by the caller and should be freed with CPLFree() when no longer needed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psNode</em>&nbsp;</td><td>the node to serialize.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the document on success or NULL on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="af44f5b9702a469037e7df18dda8d982c"></a><!-- doxytag: member="cpl_minixml.h::CPLSerializeXMLTreeToFile" ref="af44f5b9702a469037e7df18dda8d982c" args="(const CPLXMLNode *psTree, const char *pszFilename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLSerializeXMLTreeToFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&nbsp;</td>
          <td class="paramname"> <em>psTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszFilename</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write document tree to a file. </p>
<p>The passed document tree is converted into one big string (with <a class="el" href="cpl__minixml_8h.html#a17562c5f454d236e6749c73f4c93de6e" title="Convert tree into string document.">CPLSerializeXMLTree()</a>) and then written to the named file. Errors writing the file will be reported by <a class="el" href="cpl__error_8h.html#aad2b98dd58e4de706a245faddac90403" title="Report an error.">CPLError()</a>. The source document tree is not altered. If the output file already exists it will be overwritten.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psTree</em>&nbsp;</td><td>the document tree to write. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszFilename</em>&nbsp;</td><td>the name of the file to write to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success, FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a7abd72304d9ba159c965f5095c97b074"></a><!-- doxytag: member="cpl_minixml.h::CPLSetXMLValue" ref="a7abd72304d9ba159c965f5095c97b074" args="(CPLXMLNode *psRoot, const char *pszPath, const char *pszValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLSetXMLValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&nbsp;</td>
          <td class="paramname"> <em>psRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set element value by path. </p>
<p>Find (or create) the target element or attribute specified in the path, and assign it the indicated value.</p>
<p>Any path elements that do not already exist will be created. The target nodes value (the first CXT_Text child) will be replaced with the provided value.</p>
<p>If the target node is an attribute instead of an element, the name should be prefixed with a #.</p>
<p>Example: CPLSetXMLValue( "Citation.Id.Description", "DOQ dataset" ); CPLSetXMLValue( "Citation.Id.Description.#name", "doq" );</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psRoot</em>&nbsp;</td><td>the subdocument to be updated.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszPath</em>&nbsp;</td><td>the dot seperated path to the target element/attribute.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszValue</em>&nbsp;</td><td>the text value to assign.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a47c03d9f9d692128d6fa906c17c44bfc"></a><!-- doxytag: member="cpl_minixml.h::CPLStripXMLNamespace" ref="a47c03d9f9d692128d6fa906c17c44bfc" args="(CPLXMLNode *psRoot, const char *pszNameSpace, int bRecurse)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CPLStripXMLNamespace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&nbsp;</td>
          <td class="paramname"> <em>psRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszNamespace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bRecurse</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Strip indicated namespaces. </p>
<p>The subdocument (psRoot) is recursively examined, and any elements with the indicated namespace prefix will have the namespace prefix stripped from the element names. If the passed namespace is NULL, then all namespace prefixes will be stripped.</p>
<p>Nodes other than elements should remain unaffected. The changes are made "in place", and should not alter any node locations, only the pszValue field of affected nodes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psRoot</em>&nbsp;</td><td>the document to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszNamespace</em>&nbsp;</td><td>the name space prefix (not including colon), or NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bRecurse</em>&nbsp;</td><td>TRUE to recurse over whole document, or FALSE to only operate on the passed node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<hr>

Generated for GDAL by 
<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.7.1.
</body>
</html>
